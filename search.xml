<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[AT2377]Blue and Red Tree]]></title>
    <url>%2F2019%2F09%2F28%2FAT2377-Blue-and-Red-Tree%2F</url>
    <content type="text"><![CDATA[题目链接 AtCoder 题意简述 给定一棵边的颜色全为蓝色的树和一棵边的颜色全为红色的树，一次操作如下：选择蓝树上的一条路径\((u,v)\)，任意选择路径上的一条边删去，然后在\(u\)和\(v\)之间连一条红色的边，问能否在\(n-1\)次操作内将蓝树变为与红树形态和颜色都一致。 解题思路 手玩一下就可以发现，原题中的操作可以转化为这样：在红树上找一条边，对应到蓝树上的一条路径，在这个路径上删去一条边，要求每次这个红色边的两个端点联通。 所以我们每次只需要找到恰好被红树上的边所对应的蓝树上的路径覆盖一次的边，将其删去就好了，然后链上\(-1\)，用树剖维护，时间复杂度\(O(n \log^2n)\)。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/*Program from Luvwgyx*/#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e5+10;struct edge&#123;int to,nxt;&#125;e[maxn&lt;&lt;1];int n,tot,idx=-1,pos,head[maxn],dfn[maxn],del[maxn],a[maxn],b[maxn],c[maxn],d[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void add(int u,int v)&#123;e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;&#125;struct Segment_Tree&#123; struct node&#123;int w,f;vector&lt;int &gt;id;&#125;tree[maxn&lt;&lt;2]; void update(int k)&#123;tree[k].w=min(tree[k&lt;&lt;1].w,tree[k&lt;&lt;1|1].w);&#125; void down(int k)&#123; if(tree[k].f)&#123; tree[k&lt;&lt;1].w+=tree[k].f;tree[k&lt;&lt;1|1].w+=tree[k].f; tree[k&lt;&lt;1].f+=tree[k].f;tree[k&lt;&lt;1|1].f+=tree[k].f; tree[k].f=0; &#125; &#125; void insert(int k,int l,int r,int x,int y,int v)&#123; if(x&lt;=l&amp;&amp;r&lt;=y)&#123;tree[k].id.push_back(v);tree[k].w++;tree[k].f++;return ;&#125; down(k);int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)insert(k&lt;&lt;1,l,mid,x,y,v); if(mid&lt;y)insert(k&lt;&lt;1|1,mid+1,r,x,y,v); update(k); &#125; void change(int k,int l,int r,int x,int y,int v)&#123; if(x&lt;=l&amp;&amp;r&lt;=y)&#123;tree[k].w+=v;tree[k].f+=v;return ;&#125; down(k);int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)change(k&lt;&lt;1,l,mid,x,y,v); if(mid&lt;y)change(k&lt;&lt;1|1,mid+1,r,x,y,v); update(k); &#125; int query(int k,int l,int r)&#123; if(tree[k].w&gt;1)return -1;int ret=0; while(!tree[k].id.empty()&amp;&amp;del[tree[k].id.back()])tree[k].id.pop_back(); if(!tree[k].id.empty())ret=tree[k].id.back(); if(l==r)&#123;pos=l;return ret;&#125;int mid=(l+r)&gt;&gt;1,now;down(k); now=query(k&lt;&lt;1,l,mid);if(now!=-1)&#123;if(now)return now;if(ret)return ret;&#125; now=query(k&lt;&lt;1|1,mid+1,r);if(now!=-1)&#123;if(now)return now;if(ret)return ret;&#125; return ret; &#125;&#125;T;struct Heavy_Light_Decomposition&#123; int dep[maxn],size[maxn],fa[maxn],top[maxn],son[maxn]; void build(int x,int deep)&#123; dep[x]=deep;size[x]=1;int mx=0; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(v!=fa[x])&#123; fa[v]=x;build(v,deep+1);size[x]+=size[v]; if(size[v]&gt;mx)mx=size[v],son[x]=v; &#125; &#125; void dfs(int x)&#123; if(!x)return ;dfn[x]=++idx; top[x]=son[fa[x]]==x?top[fa[x]]:x;dfs(son[x]); for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(v!=fa[x]&amp;&amp;v!=son[x])dfs(v); &#125; void insert(int x,int y,int id)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); T.insert(1,1,n-1,dfn[top[x]],dfn[x],id); x=fa[top[x]]; &#125;if(dfn[x]&gt;dfn[y])swap(x,y); if(x!=y)T.insert(1,1,n-1,dfn[x]+1,dfn[y],id); &#125; void change(int x,int y,int v)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); T.change(1,1,n-1,dfn[top[x]],dfn[x],v); x=fa[top[x]]; &#125;if(dfn[x]&gt;dfn[y])swap(x,y); if(x!=y)T.change(1,1,n-1,dfn[x]+1,dfn[y],v); &#125;&#125;HLD;signed main()&#123; n=read(); for(int i=1;i&lt;n;i++)&#123; a[i]=read();b[i]=read(); add(a[i],b[i]);add(b[i],a[i]); &#125;HLD.build(1,1);HLD.dfs(1); for(int i=1;i&lt;n;i++)&#123; c[i]=read();d[i]=read(); HLD.insert(c[i],d[i],i); &#125; for(int i=1;i&lt;n;i++)&#123; if(T.tree[1].w!=1)&#123;puts("NO");return 0;&#125; int now=T.query(1,1,n-1);del[now]=1; T.change(1,1,n-1,pos,pos,maxn); HLD.change(c[now],d[now],-1); &#125;puts("YES"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AT2164]Rabbit Exercise]]></title>
    <url>%2F2019%2F09%2F27%2FAT2164-Rabbit-Exercise%2F</url>
    <content type="text"><![CDATA[题目链接 AtCoder 题意简述 有\(n\)只兔子在数轴上，数轴编号从\(1\)到\(n\)，第\(i\)只兔子的初始位置是\(X_i\)。 他们会以如下方式进行锻炼： 一轮包含\(m\)个跳跃，第\(j\)个进行跳跃的是兔子\(a_j(1 &lt; a_j &lt; n)\)，对于每一个跳跃，兔子\(a_j\)都会等概率地从\(a_j-1\)和\(a_j+1\)中选择一个（假设选择的是\(x\)），那么兔子\(a_j\)会跳到他当前坐标关于\(x\)的对称坐标。 兔子们会进行连续\(k\)轮这样的跳跃，对于每个兔子求出最后他的期望坐标。 \(3 \leqslant n \leqslant 10^5,X_i \in {\rm Z},|a_i| \leqslant 10^9,1 \leqslant m \leqslant 10^5,2 \leqslant a_i \leqslant n-1,1\leqslant k \leqslant 10^{18}\)。 解题思路 首先翻转操作相当于\(A_i=2x-a_i\)，由期望的线性性可知\(E(A_i)=E(2x)-E(a_i)\)。 那么问题就转化为每次做操作\(a_i&#39;=\frac{2a_{i+1}-a_i+2a_{i-1}-a_i}{2}=a_{i-1}+a_{i+1}-a_i\)，移项后变为\(a_i&#39;-a_{i-1}=a_{i+1}-a_i\)和\(a_{i+1}-a_i&#39;=a_i-a_{i-1}\)，那么我们将原序列差分出来，就将原题意的翻转操作转化为交换两个差分了。 那么我们只需要倍增一下求出坐标\(i\)在\(k\)轮变换后变成了什么，然后前缀和还原\(X\)数组就好了。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e5+10;int n,m,K,a[maxn],X[maxn],nxt[maxn],ans[maxn],tmp[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts(".0");&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)tmp[i]=read(),X[i]=tmp[i]-tmp[i-1]; m=read();K=read(); for(int i=1;i&lt;=m;i++)a[i]=read(); for(int i=1;i&lt;=n;i++)nxt[i]=i; for(int i=1;i&lt;=m;i++)swap(nxt[a[i]],nxt[a[i]+1]); for(int i=1;i&lt;=n;i++)ans[i]=i; while(K)&#123; if(K&amp;1)&#123; for(int i=1;i&lt;=n;i++)tmp[i]=ans[nxt[i]]; for(int i=1;i&lt;=n;i++)ans[i]=tmp[i]; &#125; for(int i=1;i&lt;=n;i++)tmp[i]=nxt[nxt[i]]; for(int i=1;i&lt;=n;i++)nxt[i]=tmp[i];K&gt;&gt;=1; &#125; for(int i=1;i&lt;=n;i++)tmp[i]=X[ans[i]]; for(int i=1;i&lt;=n;i++)X[i]=tmp[i];int now=0; for(int i=1;i&lt;=n;i++)now+=X[i],write(now); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JOI 2018 Final]]></title>
    <url>%2F2019%2F09%2F25%2FJOI-2018-Final%2F</url>
    <content type="text"><![CDATA[比赛链接 LOJ 寒冬暖炉 解题思路 将客人来的时间汇总，那么要开启暖炉的时间就变成一个个时间段了，考虑最优的方案肯定是将时间段之间的间隔拎出来从大到小排序，取最大的前\(K-1\)个，因为最开始开启暖炉也是要用火柴的。 参考代码 12345678910111213141516171819202122232425262728293031/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e5+10;int n,K,tot,a[maxn],b[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; n=read();K=read()-1; for(int i=1;i&lt;=n;i++)a[i]=read(); sort(a+1,a+n+1);int ans=a[n]-a[1]+1; for(int i=2;i&lt;=n;i++)&#123; int ret=a[i]-a[i-1]-1; if(ret)b[++tot]=ret; &#125;sort(b+1,b+tot+1); for(int i=tot;i&gt;=max(1,tot-K+1);i--)ans-=b[i]; write(ans); return 0;&#125; 美术展览 解题思路 考虑若将所有的展品都按尺寸排序，那么选择的展品必然是连续的一段，那么我们只需要前缀和一下然后贪心就好了。 参考代码 1234567891011121314151617181920212223242526272829303132333435/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long long#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)using namespace std;const int inf=1e18;const int maxn=5e5+10;int n,mn,sum[maxn],mx[maxn];pi a[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i].fir=read(),a[i].sec=read();//a[i]=mp(read(),read()); sort(a+1,a+n+1);int ans=0;mx[0]=-inf;mn=inf; for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i].sec; for(int i=1;i&lt;=n;i++)mx[i]=max(mx[i-1],a[i].fir-sum[i-1]); for(int i=n;i&gt;=1;i--)mn=min(mn,a[i].fir-sum[i]),ans=max(ans,mx[i]-mn); write(ans); return 0;&#125; 团子制作 解题思路 考虑串一串团子，能影响到的能串团子的位置只有是以G团子作对角线，对角线穿过的G团子所能串的团子（语文不好别吐槽），那么我们在对角线上\(\rm DP\)就好了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=3e3+10;char mp[maxn][maxn];int n,m,cnt,ans,f[maxn*maxn][3];bool ok[maxn*maxn][2];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void calc()&#123; for(int i=1;i&lt;=cnt+1;i++)&#123; f[i][2]=max(f[i-1][0],max(f[i-1][1],f[i-1][2])); f[i][0]=ok[i][0]?(max(f[i-1][0],f[i-1][2])+1):0; f[i][1]=ok[i][1]?(max(f[i-1][1],f[i-1][2])+1):0; &#125;ans+=f[cnt+1][2];&#125;signed main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++)scanf("%s",mp[i]+1); for(int k=2;k&lt;=n+m;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; int j=k-i; if(j&lt;1||j&gt;m)continue; if(mp[i][j]!='G')&#123;if(cnt)calc(),cnt=0;&#125; else &#123; cnt++; ok[cnt][0]=(mp[i-1][j]=='R'&amp;&amp;mp[i+1][j]=='W'); ok[cnt][1]=(mp[i][j-1]=='R'&amp;&amp;mp[i][j+1]=='W'); &#125; &#125;if(cnt)calc(),cnt=0; &#125; write(ans); return 0;&#125; 月票购买 解题思路 因为要买月票，所以先将\(S\)到\(T\)之间的最短路径图整出来，很显然是一个有向无环图。 再考虑\(U\)到\(V\)之间的路径，与最短路径图有交的部分一定是连续的一段，所以我们直接在\(DAG\)上\(\rm DP\)就好了。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*Program from Luvwgyx*/#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fir first#define sec second#define int long long#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)using namespace std;const int maxn=1e5+10;const int maxm=2e5+10;struct node&#123;int from,to,nxt,w;&#125;e[maxm&lt;&lt;1],ee[maxm&lt;&lt;1];int n,m,S,T,U,V,tot,ttot,head[maxn],hhead[maxn],dis[4][maxn];priority_queue&lt;pi &gt;q;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void add(int u,int v,int w)&#123;e[++tot].from=u;e[tot].to=v;e[tot].w=w;e[tot].nxt=head[u];head[u]=tot;&#125;void addd(int u,int v,int w)&#123;ee[++ttot].from=u;ee[ttot].to=v;ee[ttot].w=w;ee[ttot].nxt=hhead[u];hhead[u]=ttot;&#125;void insert(int u,int v,int w)&#123;add(u,v,w);add(v,u,w);&#125;bool vis[maxn];void dijkstra(int S,int opt)&#123; memset(vis,0,sizeof(vis)); memset(dis[opt],63,sizeof(dis[opt])); dis[opt][S]=0;q.push(mp(0,S)); while(q.size())&#123; int x=q.top().sec;q.pop(); if(vis[x])continue;vis[x]=1; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(dis[opt][v]&gt;dis[opt][x]+e[i].w)&#123; dis[opt][v]=dis[opt][x]+e[i].w; q.push(make_pair(-dis[opt][v],v)); &#125; &#125;&#125;int cnt,now[maxn],f[maxn],g[maxn];void dfs(int x)&#123; vis[x]=1; for(int i=hhead[x],v=ee[i].to;i;i=ee[i].nxt,v=ee[i].to) if(!vis[v])dfs(v); now[++cnt]=x;&#125;signed main()&#123; n=read();m=read();S=read();T=read();U=read();V=read(); for(int i=1;i&lt;=m;i++)insert(read(),read(),read()); dijkstra(S,0);dijkstra(T,1);dijkstra(U,2);dijkstra(V,3); for(int i=1;i&lt;=tot;i++)&#123; int u=e[i].from,v=e[i].to,w=e[i].w; if(dis[0][u]+w+dis[1][v]==dis[0][T])addd(u,v,w); &#125;memset(vis,0,sizeof(vis));dfs(S);int ans=dis[2][V]; for(int i=1;i&lt;=cnt;i++)&#123; int x=now[i];f[x]=dis[2][x];g[x]=dis[3][x]; for(int i=hhead[x],v=ee[i].to;i;i=ee[i].nxt,v=ee[i].to)&#123; f[x]=min(f[x],f[v]); g[x]=min(g[x],g[v]); &#125;ans=min(ans,min(f[x]+dis[3][x],g[x]+dis[2][x])); &#125;write(ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ1972][Sdoi2010]猪国杀]]></title>
    <url>%2F2019%2F09%2F19%2FBZOJ1972-Sdoi2010-%E7%8C%AA%E5%9B%BD%E6%9D%80%2F</url>
    <content type="text"><![CDATA[题目链接 BZOJ LOJ 解题思路 大模拟... 对于每只猪记录身份，牌数，牌的种类，死了没，用没用过杀，跳了身份没，是不是类反猪，然后直接模拟就行。 注意： 无懈可击是从自己开始判断。 可能会把自己决斗死 结束了不要再摸牌 在万箭齐发和南蛮入侵的时候注意要判是不是结束 无懈可击也是锦囊牌，也就是说别人可以用无懈可击来让你的无懈可击失效，然后你们可以循环下去 牌不要担心会用完 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=20;const int maxm=2e4+10;struct node&#123; char card[maxm]; int cnt,hp,kind,fst,f[maxm]; bool arms,like,jump,dead,killed;&#125;a[maxn];int n,m,pos,now;char P[maxm];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void print_cards(int x)&#123; for(int i=a[x].fst;i&lt;=a[x].cnt;i++) if(!a[x].f[i])putchar(a[x].card[i]),putchar(' '); putchar('\n');&#125;void usecard(int x,int y)&#123; a[x].f[y]=1; if(y==a[x].fst)while(a[x].f[a[x].fst])a[x].fst++;&#125;void debug()&#123; printf("%lld: \n",now); for(int i=1;i&lt;=n;i++) if(!a[i].dead)&#123; printf("%lld : %lld %lld : ",i,a[i].hp,a[i].jump); print_cards(i); &#125;&#125;int get(char s)&#123; if(s=='P')return 1; if(s=='K')return 2; if(s=='D')return 3; if(s=='F')return 4; if(s=='N')return 5; if(s=='W')return 6; if(s=='J')return 7; if(s=='Z')return 8; return 0;&#125;bool check_end()&#123; bool flag1=0,flag2=0; for(int i=1;i&lt;=n;i++)if(a[i].kind==1&amp;&amp;!a[i].dead)flag1=1; for(int i=1;i&lt;=n;i++)if(a[i].kind==3&amp;&amp;!a[i].dead)flag2=1; return flag1^flag2;&#125;int have_K(int x)&#123; if(a[x].dead)return 0; for(int i=a[x].fst;i&lt;=a[x].cnt;i++)if(a[x].card[i]=='K'&amp;&amp;!a[x].f[i])return i; return 0;&#125;int have_D(int x)&#123; if(a[x].dead)return 0; for(int i=a[x].fst;i&lt;=a[x].cnt;i++)if(a[x].card[i]=='D'&amp;&amp;!a[x].f[i])return i; return 0;&#125;int have_J(int x)&#123; if(a[x].dead)return 0; for(int i=a[x].fst;i&lt;=a[x].cnt;i++)if(a[x].card[i]=='J'&amp;&amp;!a[x].f[i])return i; return 0;&#125;int have_P(int x)&#123; if(a[x].dead)return 0; for(int i=a[x].fst;i&lt;=a[x].cnt;i++)if(a[x].card[i]=='P'&amp;&amp;!a[x].f[i])return i; return 0;&#125;bool dead(int x)&#123; if(a[x].hp)return 0; int Pos=have_P(x); if(Pos)&#123;a[x].hp++;usecard(x,Pos);return 0;&#125; return 1;&#125;void damage(int x,int y)&#123; if(a[y].hp)return ; if(!dead(y))return ; a[y].dead=1;if(check_end())return ; if(a[y].kind==3)&#123; int tot=3,Tot=0; while(++Tot&lt;=tot)a[x].card[++a[x].cnt]=P[min(++pos,m)]; //printf("Cards::\n");debug(); return ; &#125; if(a[y].kind==2&amp;&amp;a[x].kind==1)&#123; for(int i=a[x].fst;i&lt;=a[x].cnt;i++)a[x].f[i]=1; a[x].arms=0; &#125;&#125;bool wxkj(int x,int y)&#123; //printf("\n%lld %lld\n",x,y); int Now=x;bool flag=0; for(int i=1;i&lt;=n;i++)&#123; if(a[Now].dead)&#123;Now=Now%n+1;continue;&#125; int Pos=have_J(Now);if(!Pos)&#123;Now=Now%n+1;continue;&#125; if(a[Now].kind==a[y].kind&amp;&amp;a[y].jump)flag=1; if((a[Now].kind==2&amp;&amp;a[y].kind==1)||(a[Now].kind==1&amp;&amp;a[y].kind==2&amp;&amp;a[y].jump))flag=1; if(flag)&#123;a[Now].jump=1;usecard(Now,Pos);break;&#125; Now=Now%n+1; &#125;if(!flag)return 1;y=x;x=Now;int opt=0; //printf("%lld %lld\n",x,y); while(1)&#123; flag=0; for(int i=1;i&lt;=n;i++)&#123; if(a[Now].dead)&#123;Now=Now%n+1;continue;&#125; //printf("%lld ",Now); int Pos=have_J(Now);if(!Pos)&#123;Now=Now%n+1;continue;&#125; if(a[Now].kind==1&amp;&amp;(a[x].kind==3||(!a[x].jump&amp;&amp;a[x].like)))flag=1; if(a[Now].kind==2&amp;&amp;a[x].kind==3&amp;&amp;a[x].jump)flag=1; if(a[Now].kind==3&amp;&amp;(a[x].kind==1||(a[x].kind==2&amp;&amp;a[x].jump)))flag=1; if(flag)&#123;a[Now].jump=1;usecard(Now,Pos);opt^=1;x=Now;break;&#125; Now=Now%n+1; &#125;if(!flag)break;//puts(""); //printf("%lld %lld %lld\n",a[x].kind,x,opt); &#125;//puts(""); return opt;&#125;void fight(int x,int y)&#123; if(a[x].kind==1&amp;&amp;a[y].kind==2)&#123;a[y].hp--;damage(x,y);return ;&#125; while(1)&#123; int Pos=have_K(y); if(!Pos)&#123;a[y].hp--;damage(x,y);break;&#125; usecard(y,Pos);swap(x,y); &#125;&#125;void nmrq(int x)&#123; int Now=x%n+1; while(Now!=x)&#123; if(a[Now].dead)&#123;Now=Now%n+1;continue;&#125; if(!wxkj(x,Now))&#123;Now=Now%n+1;continue;&#125; int Pos=have_K(Now); if(!Pos)&#123; a[Now].hp--;damage(x,Now); if(a[Now].kind==1)&#123; if(a[x].kind==2&amp;&amp;!a[x].jump)a[x].like=1; if(a[x].kind==3)a[x].jump=1,a[x].like=1; &#125; &#125;else usecard(Now,Pos); if(check_end())return ; Now=Now%n+1; &#125;&#125;void wjqf(int x)&#123; int Now=x%n+1;//printf("WJQF:\n"); while(Now!=x)&#123; if(a[Now].dead)&#123;Now=Now%n+1;continue;&#125; if(!wxkj(x,Now))&#123;Now=Now%n+1;continue;&#125; int Pos=have_D(Now); if(!Pos)&#123; a[Now].hp--;damage(x,Now); if(a[Now].kind==1)&#123; if(a[x].kind==2&amp;&amp;!a[x].jump)a[x].like=1; if(a[x].kind==3)a[x].jump=1,a[x].like=1; &#125; &#125;else usecard(Now,Pos); if(check_end())return ; Now=Now%n+1; &#125;&#125;signed main()&#123; //freopen("a.in","r",stdin); //freopen("19.ans","w",stdout); n=read();m=read();char opt[10]; for(int i=1;i&lt;=n;i++)&#123; scanf("%s",opt); if(opt[0]=='M')a[i].kind=1,a[i].jump=1; else if(opt[0]=='Z')a[i].kind=2; else a[i].kind=3;a[i].hp=4;a[i].fst=1; for(int j=1;j&lt;=4;j++)&#123; scanf("%s",opt); a[i].card[++a[i].cnt]=opt[0]; &#125; &#125;pos=0;now=0; for(int i=1;i&lt;=m;i++)&#123; char ch=getchar(); while(ch&lt;'A'||ch&gt;'Z')ch=getchar(); P[i]=ch; &#125; while(!check_end())&#123; now=now%n+1;while(a[now].dead)now=now%n+1;a[now].killed=0; int tot=2,Tot=0; while(++Tot&lt;=tot)a[now].card[++a[now].cnt]=P[min(++pos,m)]; //debug(); while(1)&#123; bool FLAG=0;//if(now==3)debug(); for(int i=a[now].fst;i&lt;=a[now].cnt;i++)&#123; if(a[now].f[i])continue;int kind=get(a[now].card[i]); //puts("ok"); if(kind==1)&#123; if(a[now].hp&lt;4)a[now].hp++,usecard(now,i),FLAG=1; //printf("%lld used the peach\n",now); &#125;else if(kind==2)&#123; if(!a[now].arms)if(a[now].killed)continue; int Now=now%n+1;bool flag=0; while(a[Now].dead&amp;&amp;Now!=now)Now=Now%n+1; if(Now==now)continue; if(a[now].kind==1||a[now].kind==2)&#123; if(a[Now].kind==3&amp;&amp;a[Now].jump)&#123;flag=1;&#125; else &#123;if(a[now].kind==1&amp;&amp;a[Now].like)flag=1;&#125; &#125;else &#123; if(a[Now].kind==1)&#123;flag=1;&#125; else &#123;if(a[Now].kind==2&amp;&amp;a[Now].jump)flag=1;&#125; &#125;if(flag)&#123; a[now].killed=1;usecard(now,i); int Pos=have_D(Now);a[now].jump=1; if(!Pos)&#123;a[Now].hp--;damage(now,Now);&#125; else &#123;usecard(Now,Pos);&#125; FLAG=1; &#125; &#125;else if(kind==3)continue; else if(kind==4)&#123; if(a[now].kind==1)&#123; int Now=now%n+1; while((a[Now].dead||(!((a[Now].kind==3&amp;&amp;a[Now].jump)||a[Now].like)))&amp;&amp;Now!=now)Now=Now%n+1; if(Now==now)continue;usecard(now,i);FLAG=1; if(!wxkj(now,Now))break;fight(now,Now); &#125;else if(a[now].kind==2)&#123; int Now=now%n+1; while((a[Now].dead||(!(a[Now].kind==3&amp;&amp;a[Now].jump)))&amp;&amp;Now!=now)Now=Now%n+1; if(Now==now)continue;usecard(now,i);a[now].jump=1;FLAG=1; if(!wxkj(now,Now))break;fight(now,Now); &#125;else &#123; int Now=now%n+1; while(a[Now].kind!=1&amp;&amp;Now!=now)Now=Now%n+1; if(Now==now)continue;usecard(now,i);a[now].jump=1;FLAG=1; if(!wxkj(now,Now))break;fight(now,Now); &#125; &#125;else if(kind==5)&#123;usecard(now,i);nmrq(now);FLAG=1;&#125; else if(kind==6)&#123;usecard(now,i);wjqf(now);FLAG=1;&#125; else if(kind==7)continue; else if(kind==8)&#123;usecard(now,i);a[now].arms=1;FLAG=1;&#125; if(FLAG)break; &#125;if(!FLAG)break;if(check_end())break; if(a[now].dead)break; &#125;//debug(); &#125;bool flag=0; for(int i=1;i&lt;=n;i++)if(a[i].kind==1&amp;&amp;!a[i].dead)&#123;flag=1;break;&#125; puts(flag?"MP":"FP"); for(int i=1;i&lt;=n;i++)&#123; if(a[i].dead)&#123;puts("DEAD");continue;&#125; print_cards(i); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数论学习(Part 2)]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0-Part-2%2F</url>
    <content type="text"><![CDATA[乘法逆元 如果一个线性同余方程\(ax \equiv 1 ({\rm mod}~p)\)，则称\(x\)为\(p\)在\({\rm mod} ~ p\)意义下的逆元，记作\(a^{-1}\)。 扩展欧几里得法 与求解线性同余方程同理。 快速幂法 由费马小定理有： 若\(a\)为正整数，\(p\)为质数，且\(a\)与\(p\)互质，则\(a^{p-1} \equiv 1 ({\rm mod}~p)\)。 那么当我们要求解的是模一个质数意义下的逆元时，我们可以得到\(ax \equiv a^{p-1} ( {\rm mod}~p) \Leftrightarrow x \equiv a^{p-2} ({\rm mod}~p)\)，这样我们就可以用快速幂求解了。 线性求\(1\)到\(n\)的逆元 求\(1,2, \cdots , n\)这些数的逆元，单个求的复杂度为\(O(n \log n)\)，我们考虑如何\(O(n)\)求解。 设\(t=\frac{p}{i},k=p~{\rm mod}~i\)，那么 \[ ti+k \equiv 0 ({\rm mod }~p)\\ -ti \equiv k ({\rm mod } ~ p)\\ -t\times inv_k \equiv inv_i ({\rm mod } ~ p)\\ inv_i=-(p/i)~inv_{p~{\rm mod}~i}\\ \] 这样我们就可以线性递推求出\(1\)到\(n\)的逆元了： 1234void init()&#123; inv[1]=1; for(int i=2;i&lt;=n;i++)inv[i]=(-mod/i)*inv[mod%i]%mod;&#125; 但是我们发现这样子做会出现负数，我们处理一下： 1234void get()&#123; inv[1]=1; for(int i=2;i&lt;=n;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;&#125; 线性求任意\(n\)个数的逆元 求给定的\(n\)个数\(1 \leqslant a_i \leqslant p\)的逆元： 首先计算前\(i\)个数的前缀积\(mul_i\)，然后用快速幂或者扩展欧几里得求出\(mul_n\)的逆元\(invv_n\)。 由于\(invv_n\)是\(n\)个数的积的逆元，所以我们将其乘以\(a_i\)时会抵消掉\(a_i\)的逆元，这样我们可以倒序递推求出前\(i\)个数的积的逆元。 然后我们就可以用\(mul_{i-1} \times invv_i\)来得出\(a_i\)的逆元。 参考代码： 123456void init()&#123; mul[0]=1;for(int i=1;i&lt;=n;i++)mul[i]=mul[i-1]*a[i]%mod; invv[n]=power(mul[n],mod-2); for(int i=n;i&gt;=1;i--)invv[i-1]=invv[i]*a[i]%mod; for(int i=1;i&lt;=n;i++)inv[i]=invv[i]*mul[i-1]%mod; &#125;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论学习(Part 1)]]></title>
    <url>%2F2019%2F09%2F10%2F%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0-Part-1%2F</url>
    <content type="text"><![CDATA[扩展欧几里得 形如\(ax+by=\gcd(a,b)\)，可以用扩展欧几里得求得整数解。 设\(ax_1+by_1=\gcd(a,b)\)，且我们已求得\(bx_2+(a\%b)y_2=\gcd(a,b)\)的解\(x_2,y_2\)，考虑如何推出\(x_1,y_1\)。 \[ \because a\%b=a- b\lfloor \frac{a}{b} \rfloor\\ \therefore ax_1+by_1=bx_2+(a- b\lfloor \frac{a}{b} \rfloor)y_2\\ \begin{align*} ax_1+by_1 &amp;= bx_2+ay_2-b\lfloor \frac{a}{b} \rfloor y_2\\ &amp;=ay_2+b(x_2-\lfloor \frac{a}{b} \rfloor y_2)\\ \end{align*} \\ \therefore x_1=y_2,y_1=x_2-\lfloor \frac{a}{b} \rfloor y_2 \] 费马小定理 若\(p\)为素数，\(\gcd(a,p)=1\)，则\(a^{p-1}\equiv 1({\rm{mod}}~p)\)。 欧拉函数 欧拉函数\(\varphi(n)\)表示小于等于\(n\)且和\(n\)互质的数的个数。 \(\varphi(1)=1\)，\(n\)为质数时\(\varphi(n)=n-1\)。 根据唯一分解定理，我们可以把一个整数唯一地分解为质数幂次的乘积，设\(n=p_1^{k_1}p_2^{k_2}...p_s^{k_s}\)，其中\(p_i\)是质数，那么\(\varphi(n)=n\times\prod_{i=1}^s\frac{p_i-1}{p_i}\)。 性质 积性函数。即若\(\gcd(a,b)=1\)，则\(\varphi(a\times b)=\varphi(a)\times \varphi(b)\)。 \(n=\sum_{d|n}\varphi(d)\)，可以利用莫比乌斯反演的相关知识得出。 也可以这样理解：若\(\gcd(n,k)=d\)，那么\(\gcd(\frac{n}{d},\frac{k}{d})=1\)，其中\(k&lt;n\)。 设\(f(x)\)表示\(\gcd(n,k)=x\)的数的个数，那么\(n=\sum_{i=1}^nf(i)\)，由于\(f(x)=\varphi(\frac{n}{x})\)，则\(n=\sum_{d|n}\varphi(\frac{n}{d})\)，由于\(d\)和\(\varphi(\frac{n}{d})\)具有对称性，所以\(n=\sum_{d|n}\varphi(d)\)。 若\(n=p^k\)，其中\(p\)为质数，那么\(\varphi(n)=p^k-p^{k-1}\)。 欧拉定理 若\(\gcd(a,m)=1\)，则\(a^{\varphi(m)} \equiv 1({\rm{mod}}~m)\)。 证明： 简化剩余系：所有\(\gcd(n,m)=1,1\leqslant n \leqslant m\)的\(n\)构成了\(m\)的简化剩余系，简称缩系。 设\(r_1,r_2,...,r_{\varphi(m)}\)为模\(m\)意义下的缩系，那么\(ar_1,ar_2,...,ar_{\varphi(m)}\)同为模\(m\)意义下 的缩系。 \[ r_1r_2\cdots r_{\varphi(m)}=ar_1\cdot ar_2 \cdots ar_{\varphi(m)}=a^{\varphi(m)}r_1r_2\cdots r_{\varphi(m)}\\ \therefore a^{\varphi(m)} \equiv 1({\rm{mod}}~m) \] 当\(m\)为素数时，由于\(\varphi(m)=m-1\)，代入欧拉定理即可得费马小定理。 类欧几里得 引入 设 \[ f(a,b,c,n)=\sum_{i=0}^n\lfloor \frac{ai+b}{c} \rfloor \] 其中\(a,b,c,n\)均为常数，考虑如何在\(O(\log n)\)时间内求解答案。 向下取整很容易想到数论分块，然后用在这里似乎不好做，但是我们也可以做一些优化：如果\(a \geqslant c,b\geqslant c\)，我们考虑对式子进行取模处理： \[ \begin{align*} f(a,b,c,n) &amp;= \sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor\\ &amp;=\sum_{i=0}^n\lfloor \frac{(\lfloor \frac{a}{c} \rfloor c +a~{\rm mod}~ c)i+(\lfloor \frac{b}{c} \rfloor c+ b~{\rm mod}~c)}{c} \rfloor\\ &amp;=\lfloor\frac{a}{c} \rfloor\frac{n(n+1)}{2}+\lfloor \frac{b}{c} \rfloor(n+1)+\sum_{i=0}^n\lfloor \frac{(a~{\rm mod}~c)i+b~{\rm mod}~c}{c} \rfloor\\ &amp;=\lfloor\frac{a}{c} \rfloor\frac{n(n+1)}{2}+\lfloor \frac{b}{c} \rfloor(n+1)+f(a~{\rm mod}~c,b~{\rm mod}~c,c,n)\\ \end{align*} \] 那么现在问题就转化为如何求解\(a &lt; c,b&lt;c\)情况下的\(f\)函数值了。 由于只有\(i\)一个变量，所以只能考虑对\(i\)进行一些操作。在推求和式子中有一个常见的技巧，就是条件与贡献的放缩与转化。具体地说，在原式中，\(0 \leqslant i \leqslant n\)是条件，而\(\lfloor\frac{ai+b}{c}\rfloor\)是对总和的贡献。我们要加速和式的计算都是将贡献合并计算，但是这个式子的贡献并不好合并计算，因此我们考虑将贡献和条件互相转化变成新形式的和式来计算贡献，我们直接把贡献变成条件： \[ \begin{align*} f(a,b,c,n) &amp;= \sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor\\ &amp;=\sum_{i=0}^n\sum_{j=0}^{\lfloor\frac{ai+b}{c}\rfloor-1}1\\ \end{align*} \] 现在我们多了一个变量\(j\)，由于并不好计算\(i\)的贡献，我们考虑计算\(j\)的贡献。由于\(j\)的贡献是受\(i\)的限制的，而我们现在要单独计算\(j\)的贡献，因此我们将\(i\)和\(j\)的求和式子交换，把\(j\)放到贡献式子里，强制用\(n\)限制\(j\)的范围： \[ \begin{align*} f(a,b,c,n) &amp;=\sum_{i=0}^n\sum_{j=0}^{\lfloor\frac{ai+b}{c}\rfloor-1}1\\ &amp;=\sum_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}\sum_{i=0}^n[j &lt; \lfloor\frac{ai+b}{c}\rfloor] \end{align*} \] 这样\(j\)就不受\(i\)的限制，而是与\(i\)一样受\(n\)的限制，我们再将贡献式变形变成与\(i\)相关的式子： \[ j &lt; \lfloor\frac{ai+b}{c}\rfloor \Leftrightarrow j+1 \leqslant \lfloor\frac{ai+b}{c}\rfloor \Leftrightarrow j+1 \leqslant \frac{ai+b}{c}\\ jc+c-b \leqslant ai \Leftrightarrow jc+c-b-1 &lt;ai \Leftrightarrow i &gt; \lfloor \frac{jc+c-b-1}{a} \rfloor\\ \] 设\(m= \lfloor\frac{an+b}{c}\rfloor\)，那么式子就变为： \[ \begin{align*} f(a,b,c,n) &amp;= \sum_{j=0}^{m-1} \sum_{i=0}^n [i &gt; \lfloor \frac{jc+c-b-1}{a} \rfloor]\\ &amp;=\sum_{j=0}^{m-1} n - \lfloor \frac{jc+c-b-1}{a} \rfloor\\ &amp;=nm-f(c,c-b-1,a,m-1) \end{align*} \] 因此 \[ f(a,b,c,n)= \begin{cases} \lfloor\frac{a}{c} \rfloor\frac{n(n+1)}{2}+\lfloor \frac{b}{c} \rfloor(n+1)+f(a~{\rm mod}~c,b~{\rm mod}~c,c,n) &amp; {a \geqslant c,b \geqslant c}\\ n\lfloor\frac{an+b}{c}\rfloor -f(c,c-b-1,a,m-1) &amp; {a &lt; c,b &lt; c}\\ \end{cases} \] 很显然这是一个递归式，并且在\(a&lt;c,b&lt;c\)的时候分子分母换了位置，又可以重复上述过程。先取模，再递归。这就是一个辗转相除的过程，这也是类欧几里德算法的得名。 时间复杂度为\(O(\log n)\)。 扩展 现在我们得出了最基本的类欧几里得算法，我们考虑求解下面两个变式： \[ g(a,b,c,n)=\sum_{i=0}^n i\lfloor \frac{ai+b}{c} \rfloor\\ h(a,b,c,n)=\sum_{i=0}^n\lfloor \frac{ai+b}{c} \rfloor^2 \] \(g\)函数的推导 同理，对于\(a \geqslant c,b \geqslant c\)的情况，取模： \[ \begin{align*} g(a,b,c,n) &amp;= \sum_{i=0}^n i \lfloor \frac{ai+b}{c} \rfloor\\ &amp;= \sum_{i=0}^n i \lfloor \frac{(\lfloor \frac{a}{c} \rfloor c + a~{\rm mod}~i)i+(\lfloor \frac{b}{c} \rfloor c + b~{\rm mod}~i)}{c} \rfloor\\ &amp;= \sum_{i=0}^n (i \frac{(a~{\rm mod}~i)i+b~{\rm mod}~i}{c}+i(i\lfloor \frac{a}{c} \rfloor + \lfloor \frac{b}{c} \rfloor )\\ &amp;= g(a~{\rm mod}~c,b~{\rm mod}~c,c,n)+\sum_{i=0}^n (i^2 \lfloor \frac{a}{c} \rfloor + i \lfloor \frac{b}{c} \rfloor)\\ &amp;= g(a~{\rm mod}~c,b~{\rm mod}~c,c,n)+\frac{n(2n+1)(n+1)}{6} \lfloor \frac{a}{c} \rfloor +\frac{n(n+1)}{2} \lfloor \frac{b}{c} \rfloor\\ \end{align*} \] 对于\(a&lt;c,b&lt;c\)的情况，令\(m=\lfloor\frac{an+b}{c}\rfloor\)，同理可得： \[ \begin{align*} g(a,b,c,n)&amp;=\sum_{i=0}^n i \lfloor \frac{ai+b}{c} \rfloor\\ &amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n i [j &lt; \lfloor \frac{ai+b}{c} \rfloor]\\ &amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n i [i &gt; \lfloor \frac{cj-c-b-1}{a} \rfloor ]\\ \end{align*} \] 令\(t=\lfloor \frac{cj-c-b-1}{a} \rfloor\)，那么： \[ \begin{align*} g(a,b,c,n) &amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n i [i &gt; \lfloor \frac{cj-c-b-1}{a} \rfloor ]\\ &amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n i [i &gt; t]\\ &amp;=\sum_{j=0}^{m-1}\frac{(t+1+n)(n-t)}{2}\\ &amp;=\frac{1}{2}\sum_{j=0}^{m-1}(nt-t^2+n^2-nt+n-t)\\ &amp;=\frac{1}{2}[mn(n+1) - \sum_{j=0}^{m-1}t^2-\sum_{j=0}^{m-1}t]\\ &amp;=\frac{1}{2}[mn(n+1) - h(c,c-b-1,a,m-1) - f(c,c-b-1,a,m-1)]\\ \end{align*} \] \(h\)函数的推导 同样的，对于\(a \geqslant c , b \geqslant c\)的情况，取模： \[ \begin{align*} h(a,b,c,n) =&amp; \sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor ^2\\ =&amp;\sum_{i=0}^n\lfloor \frac{(\lfloor \frac{a}{c} \rfloor c +a~{\rm mod}~ c)i+(\lfloor \frac{b}{c} \rfloor c+ b~{\rm mod}~c)}{c} \rfloor^2\\ =&amp;\sum_{i=0}^n\lfloor \lfloor\frac{a}{c}\rfloor i +\lfloor\frac{b}{c}\rfloor + \frac{(a~{\rm mod}~c)i+b~{\rm mod}~c}{2} \rfloor^2\\ =&amp;\sum_{i=0}^n(\lfloor \frac{a}{c} \rfloor i + \lfloor \frac{b}{c} \rfloor ) ^2 +2(\lfloor \frac{a}{c} \rfloor i + \lfloor \frac{b}{c} \rfloor )(\frac{(a~{\rm mod}~c)i+b~{\rm mod}~c}{2})\\ &amp;+(\frac{(a~{\rm mod}~c)i+b~{\rm mod}~c}{2})^2\\ =&amp;\sum_{i=0}^n[(i\lfloor \frac{a}{c} \rfloor)^2+2i\lfloor \frac{a}{c} \rfloor \lfloor \frac{b}{c} \rfloor + \lfloor \frac{b}{c} \rfloor ^2] + 2\lfloor \frac{a}{c} \rfloor g(a~{\rm mod}~c,b~{\rm mod}~c,c,n)\\ &amp;+2 \lfloor \frac{b}{c} \rfloor f(a~{\rm mod}~c,b~{\rm mod}~c,c,n)+h(a~{\rm mod}~c,b~{\rm mod}~c,c,n)\\ =&amp;\frac{n(2n+1)(n+1)}{6}\lfloor \frac{a}{c} \rfloor ^2 + n(n+1)\lfloor \frac{a}{c} \rfloor \lfloor \frac{b}{c} \rfloor +(n+1) \lfloor \frac{b}{c} \rfloor^2\\ &amp;+2\lfloor \frac{a}{c} \rfloor g(a~{\rm mod}~c,b~{\rm mod}~c,c,n)+2 \lfloor \frac{b}{c} \rfloor f(a~{\rm mod}~c,b~{\rm mod}~c,c,n)\\ &amp;+h(a~{\rm mod}~c,b~{\rm mod}~c,c,n)\\ \end{align*} \] 对于\(a &lt; c , b &lt; c\)的情况，由于平方不好处理，我们考虑将其变换形式： \[ n^2 \Leftrightarrow n^2+n-n \Leftrightarrow 2\frac{n(n+1)}{2}-n \Leftrightarrow (2\sum_{i=1}^ni)-n \] 那么 \[ \begin{align*} h(a,b,c,n)=&amp;\sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor ^2\\ =&amp;\sum_{i=0}^n[(2\sum_{j=1}^{\lfloor \frac{ai+b}{c} \rfloor}j)-\lfloor \frac{ai+b}{c} \rfloor]\\ =&amp;(2\sum_{i=0}^n\sum_{j=1}^{\lfloor \frac{ai+b}{c} \rfloor}j)-f(a,b,c,n)\\ \end{align*} \] 令\(m= \lfloor \frac{an+b}{c} \rfloor\)，\(t=\lfloor \frac{cj+c-b-1}{a} \rfloor\)，则 \[ \begin{align*} \sum_{i=0}^n\sum_{j=1}^{\lfloor \frac{ai+b}{c} \rfloor}j =&amp; \sum_{i=0}^n \sum_{j=0}^{\lfloor \frac{ai+b}{c} \rfloor-1}(j+1)\\ =&amp;\sum_{j=0}^{m-1}(j+1)\sum_{i=0}^n (j&lt; \lfloor \frac{ai+b}{c} \rfloor)\\ =&amp;\sum_{j=0}^{m-1}(j+1)\sum_{i=0}^n(i&gt;t)\\ =&amp;\sum_{j=0}^{m-1}(j+1)(n-t)\\ =&amp;\frac{1}{2}nm(m+1) - \sum_{j=0}^{m-1}j\lfloor \frac{cj+c-b-1}{a} \rfloor-\sum_{j=0}^{m-1}\lfloor \frac{cj+c-b-1}{a} \rfloor\\ =&amp;\frac{1}{2}nm(m+1)-g(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1) \end{align*} \] 所以 \[ h(a,b,c,n)=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n) \] 综上所述， \[ \begin{align*} f(a,b,c,n)&amp;= \begin{cases} \lfloor\frac{a}{c} \rfloor\frac{n(n+1)}{2}+\lfloor \frac{b}{c} \rfloor(n+1)+f(a~{\rm mod}~c,b~{\rm mod}~c,c,n) &amp; {a \geqslant c,b \geqslant c}\\ n\lfloor\frac{an+b}{c}\rfloor -f(c,c-b-1,a,m-1) &amp; {a &lt; c,b &lt; c}\\ \end{cases}\\ g(a,b,c,n)&amp;= \begin{cases} g(a~{\rm mod}~c,b~{\rm mod}~c,c,n)+\frac{n(2n+1)(n+1)}{6} \lfloor \frac{a}{c} \rfloor +\frac{n(n+1)}{2} \lfloor \frac{b}{c} \rfloor &amp; {a \geqslant c,b \geqslant c}\\ \frac{1}{2}[mn(n+1) - h(c,c-b-1,a,m-1) - f(c,c-b-1,a,m-1)] &amp; {a&lt;c,b&lt;c}\\ \end{cases}\\ h(a,b,c,n)&amp;= \begin{cases} {\frac{n(2n+1)(n+1)}{6}\lfloor \frac{a}{c} \rfloor ^2 + n(n+1)\lfloor \frac{a}{c} \rfloor \lfloor \frac{b}{c} \rfloor +(n+1) \lfloor \frac{b}{c} \rfloor^2\\+2\lfloor \frac{a}{c} \rfloor g(a~{\rm mod}~c,b~{\rm mod}~c,c,n)+2 \lfloor \frac{b}{c} \rfloor f(a~{\rm mod}~c,b~{\rm mod}~c,c,n)\\+h(a~{\rm mod}~c,b~{\rm mod}~c,c,n)} &amp; {a \geqslant c , b\geqslant c}\\ {nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)\\-f(a,b,c,n)} &amp; {a&lt;c,b&lt;c} \end{cases} \end{align*} \] 在计算的时侯，因为\(3\)个函数各有交错递归，因此可以考虑三个一起整体递归，同步计算，否则有很多项会被多次计算。这样实现的复杂度是\(O(\log n)\)。 部分公式推导 \(\sum_{i=1}^{n} i^2 = \frac{n(n+1)(2n+1)}{6}\)的推导： 我们知道\(\sum_{i=1}^n i =\frac{n(n+1)}{2}\)，但是我们没法直接从一次硬推到二次，我们考虑先求取其它包含\(i^2\)的二次多项式，然后用其它项表示\(i^2\)。 我们找一个比较优美的式子，\((n+1)^3-n^3=n^3+3n^2+3n+1-n^3=3n^2+3n+1\)，我们考虑对它求和\(\sum_{i=1}^{n}(n+1)^3-n^3\)。 我们将项列出来： \[ \begin{align*} \sum_{i=1}^n (n+1)^3-n^3 &amp;=2^3-1^3+3^3-2^3+4^3-3^3+ \cdots +(n+1)^3-n^3\\ &amp;=(n+1)^3-1^3 \end{align*} \] 又由\((n+1)^3=3n^2+3n+1\)可得： \[ \sum_{i=1}^n(n+1)^3 = 3 \sum_{i=1}^n i^2 + 3 \frac{n(n+1)}{2} + n \] 综合两式可得： \[ (n+1)^3-1=3\sum_{i=1}^n i^2 + \frac{3n(n+1)}{2}+n \] 考虑\(\sum_{i=1}^ni^2\)是我们所要求的，所以将它设成\(x\)： \[ 2n^3+6n^2+6n=6x+3n^2+3n+2n\\ \begin{align*} x&amp;=\frac{2n^3+3n^2+n}{2}\\ &amp;=\frac{n(n+1)(2n+1)}{6}\\ \end{align*} \] PS：推完之后才知道必修教材里是有的，然而我没上课... 例题 [洛谷5170]类欧几里得算法 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int mod=998244353;const int inv2=499122177;const int inv6=166374059;struct node&#123; int f,g,h; node()&#123;f=g=h=0;&#125;&#125;;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;node calc(int a,int b,int c,int n)&#123; node ret; int ac=a/c,bc=b/c,n1=n+1,n21=n*2+1,m=(a*n+b)/c; if(!a)&#123; ret.f=bc*n1%mod; ret.g=n*n1%mod*inv2%mod*bc%mod; ret.h=n1*bc%mod*bc%mod; return ret; &#125; if(a&gt;=c||b&gt;=c)&#123; ret.f=(ac*n%mod*n1%mod*inv2%mod+bc*n1%mod)%mod; ret.g=(n*n21%mod*n1%mod*inv6%mod*ac%mod+n*n1%mod*inv2%mod*bc%mod)%mod; ret.h=((n*n21%mod*n1%mod*inv6%mod*ac%mod*ac%mod+n*n1%mod*ac%mod*bc%mod)%mod+n1*bc%mod*bc%mod)%mod; node tmp=calc(a%c,b%c,c,n); ret.f=(ret.f+tmp.f)%mod; ret.g=(ret.g+tmp.g)%mod; ret.h=(ret.h+((2*ac%mod*tmp.g%mod+2*bc%mod*tmp.f%mod)%mod+tmp.h)%mod)%mod; return ret; &#125;node tmp=calc(c,c-b-1,a,m-1); ret.f=(n*m%mod-tmp.f+mod)%mod; ret.g=inv2*(((m*n%mod*n1%mod-tmp.h+mod)%mod-tmp.f+mod)%mod)%mod; ret.h=(((n*m%mod*(m+1)%mod-2*tmp.g%mod+mod)%mod-2*tmp.f%mod+mod)%mod-ret.f+mod)%mod; return ret;&#125;signed main()&#123; int T=read(); while(T--)&#123; int n=read(),a=read(),b=read(),c=read(); node ans=calc(a,b,c,n); printf("%lld %lld %lld\n",ans.f,ans.h,ans.g); &#125; return 0;&#125;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 65]]></title>
    <url>%2F2019%2F09%2F05%2FEducational-Codeforces-Round-65%2F</url>
    <content type="text"><![CDATA[比赛链接 Educational Codeforces Round 65 A. Telephone Number 题目大意 定义电话号码为以\(8\)开头，长度为\(11\)的号码，给定一个长度为\(n\)的串，问能否删去一些数字让其变成电话号码。 解题思路 很显然我们只需要找到第一个\(8\)然后判断它后面还有没有\(10\)个数字以上就行了。 参考代码 12345678910111213141516171819202122232425262728293031323334/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e2+10;char s[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int T=read(); while(T--)&#123; int n=read();scanf("%s",s+1);bool flag=0; for(int i=1;i&lt;=n;i++) if(s[i]=='8'&amp;&amp;n-i+1&gt;=11)&#123;flag=1;break;&#125; puts(flag?"YES":"NO"); &#125; return 0;&#125; B. Lost Numbers 题目大意 交互题。 有一个长度为\(6\)的由\(\{4,8,15,16,23,42\}\)排列组成的序列，你每次可以询问任意一对下标\((i,j)\)的数的积，问能否在\(4\)次询问以内得到这个序列。 解题思路 考虑到它们两两的积不同，于是我们可以先预处理出来两两的积，然后询问四次，每次询问\((1,2)\)和另外的四个数，然后暴力查询对应的是哪两个位置的积，统计位置出现的次数，那么出现次数最多的数就是位置\(1\)的数字了。然后其他四个数字一一还原，最后剩下的数字就是剩下没有询问过的位置上的数了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;int a[7]=&#123;0,4,8,15,16,23,42&#125;;int ans[10],f[10][10],cnt[10],x[10],y[10],F[10];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void query(int x)&#123;printf("? %lld %lld\n",1ll,x);fflush(stdout);&#125;signed main()&#123; for(int i=1;i&lt;=6;i++)for(int j=1;j&lt;=6;j++)f[i][j]=a[i]*a[j]; int tot=0; for(int i=2;i&lt;=5;i++)&#123; query(i);int now=read(); for(int j=1;j&lt;=6;j++)&#123; bool flag=0; for(int k=1;k&lt;=6;k++) if(now==f[j][k])&#123;x[++tot]=j;y[tot]=k;flag=1;&#125; if(flag)break; &#125; &#125;//for(int i=1;i&lt;=tot;i++)printf("%lld %lld\n",x[i],y[i]); for(int i=1;i&lt;=tot;i++)cnt[x[i]]++,cnt[y[i]]++; for(int i=1;i&lt;=6;i++)if(cnt[i]&gt;1)ans[1]=i,F[i]=1; for(int i=1;i&lt;=tot;i++)&#123; if(x[i]!=ans[1])ans[i+1]=x[i],F[x[i]]=1; else ans[i+1]=y[i],F[y[i]]=1; &#125;for(int i=1;i&lt;=6;i++)if(!F[i])ans[6]=i;printf("!"); for(int i=1;i&lt;=6;i++)printf(" %lld",a[ans[i]]);puts(""); return 0;&#125; C. News Distribution 题目大意 有\(n\)个人，\(m\)个组，一个人可以在多个组内，给定组内的成员。已知如果一人知道了一个新消息，那么他会将消息传递给他所在的所有组的其他所有成员，对每个人求解以其作为第一个知道消息的人，他能将消息传递给多少人。 解题思路 并查集裸题。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=5e5+10;int a[maxn],uset[maxn],size[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void init()&#123;for(int i=1;i&lt;maxn;i++)uset[i]=i;&#125;int find(int x)&#123;return x==uset[x]?uset[x]:uset[x]=find(uset[x]);&#125;signed main()&#123; int n=read(),m=read();init(); for(int i=1;i&lt;=m;i++)&#123; int cnt=read(); for(int j=1;j&lt;=cnt;j++)a[j]=read(); for(int j=2;j&lt;=cnt;j++)&#123; int x=a[1],y=a[j]; uset[find(x)]=uset[find(y)]; &#125; &#125;for(int i=1;i&lt;=n;i++)size[find(i)]++; for(int i=1;i&lt;=n;i++)printf("%lld ",size[find(i)]);puts(""); return 0;&#125; D. Bicolored RBS 题目大意 给定一个括号序列，现在要你将这些括号分成两组，保证两组都是合法的括号序列，且让两组中最大的嵌套深度最小。 解题思路 枚举每一位，分别统计当前两组的嵌套深度，如果当前的是左括号，那么就将其分到嵌套深度最小的一组，否则就分到嵌套深度最大的一组。 参考代码 12345678910111213141516171819202122232425262728293031323334353637/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=2e5+10;char s[maxn];int ans[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int n=read(),cnt1=0,cnt2=0;scanf("%s",s+1); for(int i=1;i&lt;=n;i++)&#123; if(s[i]=='(')&#123; if(cnt1&lt;=cnt2)cnt1++,ans[i]=0ll; else cnt2++,ans[i]=1ll; &#125;else &#123; if(cnt1&gt;=cnt2)cnt1--,ans[i]=0ll; else cnt2--,ans[i]=1ll; &#125; &#125;for(int i=1;i&lt;=n;i++)printf("%lld",ans[i]);puts(""); return 0;&#125; E. Range Deleting 题目大意 给定一个长度为\(n\)的序列，其中\(a_i \leqslant x\)。定义\(f(l,r)\)为删除\(a\)中权值在\([l,r]\)的数后剩下的数，统计满足\(1 \leqslant l \leqslant r \leqslant x\)且\(f(l,r)\)是不下降序列的数对\((l,r)\)的个数。 解题思路 很显然\(l\)和\(r\)具有单调性。 我们将序列拆成权值在\([1,l)\)和\((r,x]\)的两段，那么如果要使\((l,r)\)满足条件，那么权值\([1,l)\)的数按照权值从小到大排序之后对应的原数组下标要递增，\((r,x]\)这一段也是这样，同时还满足前一段的最大坐标要小于后一段的最小坐标。 那么我们处理出\(mnpos_i\)和\(mxpos_i\)，分别表示权值为\(i\)的数出现的最小的位置和最大的位置，\(premx_i\)和\(nxtmx_i\)分别表示排序后\(1\)到\(i\)的最大下标和\(i\)到\(x\)的最小下标。 然后根据处理出的这几个数组去处理\(pre_i\)和\(nxt_i\)，分别表示\(1\)到\(i\)这一段是否合法和\(i\)到\(x\)这一段是否合法，然后用\(two~pointer\)去求解答案，\(O(1)\)判断区间是否合法。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int inf=1e9;const int maxn=1e6+10;int a[maxn],mnpos[maxn],mxpos[maxn],premx[maxn],nxtmx[maxn],pre[maxn],nxt[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;bool check(int l,int r)&#123; if(!pre[l-1])return 0; if(!nxt[r+1])return 0; if(nxtmx[r+1]&lt;premx[l-1])return 0; return 1;&#125;signed main()&#123; int n=read(),x=read(); memset(mnpos,63,sizeof(mnpos)); for(int i=1;i&lt;=n;i++)a[i]=read(); for(int i=1;i&lt;=n;i++)&#123; mnpos[a[i]]=min(mnpos[a[i]],i); mxpos[a[i]]=max(mxpos[a[i]],i); &#125;premx[0]=0;nxtmx[x+1]=inf; for(int i=1;i&lt;=x;i++)premx[i]=max(premx[i-1],mxpos[i]); for(int i=x;i&gt;=1;i--)nxtmx[i]=min(nxtmx[i+1],mnpos[i]); pre[0]=nxt[x+1]=1; for(int i=1;i&lt;=x;i++)pre[i]=pre[i-1]&amp;&amp;(premx[i-1]&lt;mnpos[i]); for(int i=x;i&gt;=1;i--)nxt[i]=nxt[i+1]&amp;&amp;(nxtmx[i+1]&gt;mxpos[i]); int l=1,r=1,ans=0; while(l&lt;=x)&#123; if(l&gt;r)r++; while(r&lt;x&amp;&amp;!check(l,r))r++; if(check(l,r))ans+=x-r+1;l++; &#125;write(ans); return 0;&#125; F. Scalar Queries 题目大意 给出一个数组\(a_1,a_2,...,a_n\)，其中所有元素两两不同。 定义函数\(f(l,r)\)： 定义数组\(b_1,b_2,...,b_{r-l+1}\)，其中\(b_i=a_{l-1+i}\) 将\(b\)按从小到大排序 则此时函数的值是\(\sum\limits_{i=1}^{r-l+1}{b_i}\cdot i\) 请计算对于所有满足\(1 \leqslant l \leqslant r \leqslant n\)的\(l\)和\(r\)，\(f(l,r)\)的和。 由于结果可能很大，请输出对\(10^9+7\)取模的值。 解题思路 考虑每个数字对答案的贡献： \(a_i\)的贡献为\((n-i+1) \times j \times a_i\)。 在\(a_i\)左边的比它小的数\(a_j\)的贡献为\((n−i+1) \times j \times a_i\)。 在\(a_i\)右边的比它小的数\(a_j\)的贡献为\(i \times (n−j+1) \times a_i\)。 将所有贡献加起来即为答案，然后按排序后的下标建树状数组，维护原下标前缀和，边更新边加答案。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int mod=1e9+7;const int maxn=5e5+10;int n,a[maxn],b[maxn],cnt[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;struct Binary_Indix_Tree&#123; int tree[maxn]; void clear()&#123;memset(tree,0,sizeof(tree));&#125; void change(int x,int v)&#123;for(;x&lt;=n;x+=(x&amp;(-x)))tree[x]+=v;&#125; int query (int x)&#123;int ret=0;for(;x;x-=(x&amp;(-x)))ret+=tree[x];return ret;&#125;&#125;T;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=b[i]=read(); sort(b+1,b+n+1); for(int i=1;i&lt;=n;i++)a[i]=lower_bound(b+1,b+n+1,a[i])-b; for(int i=1;i&lt;=n;i++)&#123; cnt[i]=(cnt[i]+T.query(a[i])*(n-i+1)%mod)%mod; T.change(a[i],i); &#125;for(int i=1;i&lt;=n;i++)cnt[i]=(cnt[i]+i*(n-i+1)%mod)%mod;T.clear(); for(int i=n;i&gt;=1;i--)&#123; cnt[i]=(cnt[i]+T.query(a[i])*i%mod)%mod; T.change(a[i],n-i+1); &#125;int ans=0; for(int i=1;i&lt;=n;i++)ans=(ans+cnt[i]*b[a[i]]%mod)%mod; write(ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ1003][ZJOI2006]物流运输]]></title>
    <url>%2F2019%2F09%2F03%2FBZOJ1003-ZJOI2006-%E7%89%A9%E6%B5%81%E8%BF%90%E8%BE%93%2F</url>
    <content type="text"><![CDATA[题目链接 BZOJ 洛谷 解题思路 设\(f_i\)表示到第\(i\)天，最小的总成本是多少，那么转移也就很简单了： \[ f_i=f_j+dis \times (i-j+1)+K \] 其中\(dis\)为\(1\)到\(m\)的最短路。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*Program from Luvwgyx*/#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)using namespace std;const int inf=1e9;const int maxn=1e2+10;const int maxm=1e4+10;struct node&#123;int to,nxt,w;&#125;e[maxm&lt;&lt;1];int n,m,K,E,tot,f[maxn],use[maxn],dis[maxn],head[maxn],fas[maxn][maxn];bool vis[maxn];priority_queue&lt;pi &gt;q;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void add(int u,int v,int w)&#123;e[++tot].to=v;e[tot].w=w;e[tot].nxt=head[u];head[u]=tot;&#125;void dijkstra(int S)&#123; memset(vis,0,sizeof(vis)); memset(dis,63,sizeof(dis)); dis[S]=0;q.push(mp(0,S)); while(q.size())&#123; int x=q.top().sec;q.pop(); if(vis[x])continue;vis[x]=1; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(dis[v]&gt;dis[x]+e[i].w&amp;&amp;!use[v])&#123; dis[v]=dis[x]+e[i].w; q.push(mp(-dis[v],v)); &#125; &#125;&#125;int main()&#123; n=read();m=read();K=read();E=read(); for(int i=1;i&lt;=E;i++)&#123; int u=read(),v=read(),w=read(); add(u,v,w);add(v,u,w); &#125;int Q=read(); for(int i=1;i&lt;=Q;i++)&#123; int x=read(),l=read(),r=read(); for(int j=l;j&lt;=r;j++)fas[j][x]=1; &#125;memset(f,63,sizeof(f));f[0]=-K; for(int i=1;i&lt;=n;i++)&#123; memset(use,0,sizeof(use)); for(int j=i;j&gt;=1;j--)&#123; for(int k=1;k&lt;=m;k++)if(fas[j][k])use[k]=1; dijkstra(1);int ret=dis[m]; if(ret&gt;inf)break; f[i]=min(f[i],f[j-1]+(i-j+1)*ret+K); &#125; &#125;write(f[n]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ1084][SCOI2005]最大子矩阵]]></title>
    <url>%2F2019%2F09%2F03%2FBZOJ1084-SCOI2005-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目链接 BZOJ 洛谷 解题思路 考虑\(\rm DP\)，设\(f_{i,j,k}\)表示第一列取了前\(i\)个，第二列取了前\(j\)个，选了\(k\)个子矩阵的最大分值和。 转移就比较显然了： 两边都不取，\(f_{i,j,k}=max(f_{i-1,j,k},f_{i,j-1,k})\) 取第一列，\(f_{i,j,k}=f_{l,j,k-1}+sum_{1,i}-sum_{1,l}(0&lt;l&lt;i)\) 取第二列，\(f_{i,j,k}=f_{i,l,k-1}+sum_{2,j}-sum_{2,l}(0&lt;l&lt;j)\) 取第一列和第二列构成的矩阵，\(f_{i,j,k}=f_{l,l,k-1}+sum_{1,i}-sum_{1,l}+sum_{2,j}-sum_{2,l}(i=j,0&lt;l&lt;i)\) 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e2+10;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;int n,m,K,a[maxn][3],sum[3][maxn],g[maxn][20],f[maxn][maxn][20];int main()&#123; n=read();m=read();K=read(); for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)a[i][j]=read(); for(int i=1;i&lt;=m;i++)for(int j=1;j&lt;=n;j++)sum[i][j]=sum[i][j-1]+a[j][i]; if(m==1)&#123; for(int k=1;k&lt;=K;k++) for(int i=1;i&lt;=n;i++)&#123; g[i][k]=g[i-1][k]; for(int j=0;j&lt;i;j++)g[i][k]=max(g[i][k],g[j][k-1]+sum[1][i]-sum[1][j]); &#125; write(g[n][K]); &#125;else &#123; for(int k=1;k&lt;=K;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; f[i][j][k]=max(f[i-1][j][k],f[i][j-1][k]); for(int l=0;l&lt;i;l++)f[i][j][k]=max(f[i][j][k],f[l][j][k-1]+sum[1][i]-sum[1][l]); for(int l=0;l&lt;j;l++)f[i][j][k]=max(f[i][j][k],f[i][l][k-1]+sum[2][j]-sum[2][l]); if(i==j)for(int l=0;l&lt;i;l++)f[i][j][k]=max(f[i][j][k],f[l][l][k-1]+sum[1][i]-sum[1][l]+sum[2][i]-sum[2][l]); &#125; write(f[n][n][K]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ2326][HNOI2011]数学作业]]></title>
    <url>%2F2019%2F09%2F02%2FBZOJ2326-HNOI2011-%E6%95%B0%E5%AD%A6%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[题目链接 BZOJ 洛谷 解题思路 设第\(i\)个数为\(f_i\)，那么我们可以得到一个转移方程： \[ f_i=f_{i-1} \times 10^{\lfloor \lg i \rfloor} +i \] 这个题的范围很大，显然是要我们用\(\log\)级别复杂度的算法来解决的。我们考虑怎么用矩阵乘法来优化转移： \[ \left[ \begin{matrix} f_{i-1} &amp; i-1 &amp; 1\\ \end{matrix} \right] \left[ \begin{matrix} 10^{\lfloor \lg i \rfloor} &amp; 1 &amp; 1\\ 1 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\\ \end{matrix} \right] \] 注意到\(10 ^ {\lfloor \lg i \rfloor}\)是不断变化的，考虑\(\lg i\)不会很大，所以我们可以直接枚举，然后用矩阵快速幂优化转移。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*Program from Luvwgyx*/#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define sqr(x) ((x)*(x))#define int long longusing namespace std;int n,mod;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;struct Matrix&#123; int a[4][4]; Matrix()&#123;memset(a,0,sizeof(a));&#125; void init()&#123; memset(a,0,sizeof(a)); for(int i=1;i&lt;4;i++)a[i][i]=1; &#125;&#125;now,init;Matrix mul(Matrix a,Matrix b)&#123; Matrix c; for(int i=1;i&lt;4;i++) for(int j=1;j&lt;4;j++) for(int k=1;k&lt;4;k++) c.a[i][j]=(c.a[i][j]+1ll*a.a[i][k]*b.a[k][j]%mod)%mod; return c;&#125;Matrix power(Matrix a,int b)&#123; Matrix ret;ret.init(); for(;b;b&gt;&gt;=1,a=mul(a,a)) if(b&amp;1)ret=mul(ret,a); return ret;&#125;int get(int x)&#123;int ret=0;while(x)x/=10,ret++;return ret;&#125;int cal(int x)&#123;int ret=1;for(int i=1;i&lt;=x;i++)ret=ret*10;return ret;&#125;signed main()&#123; n=read();mod=read();int len=get(n); init.a[1][1]=init.a[1][2]=init.a[1][3]=1; now.a[2][1]=now.a[3][1]=now.a[2][2]=now.a[3][2]=now.a[3][3]=1; for(int i=0;i&lt;len-1;i++)&#123; now.a[1][1]=cal(i+1)%mod; int m=cal(i+1)-cal(i)-(i==0); init=mul(init,power(now,m)); &#125;int m=n-cal(len-1)-(len-1==0)+1;now.a[1][1]=cal(len)%mod; init=mul(init,power(now,m));write(init.a[1][1]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ3675][Apio2014]序列分割]]></title>
    <url>%2F2019%2F09%2F02%2FBZOJ3675-Apio2014-%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[题目链接 BZOJ 洛谷 解题思路 首先考虑分割顺序对于答案的影响。 设当前的序列为\(a~b~c~d\)，我们考虑从前往后分割与从后往前分割，比较最后的答案： \(a(b+c+d)+b(c+d)+cd=ab+ac+ad+bc+bd+cd\) \(d(a+b+c)+c(a+b)+ab=ad+bd+cd+ac+bc+ab\) 比较一下，发现答案是相同的，推广一下可以得知分割的先后顺序对答案是没有影响的。 我们设\(f_{i,j}\)表示前\(i\)个数分割了\(j\)次能获得的最大的得分，那么就有如下转移（其中\(sum_x\)表示第\(x\)个位置的前缀和）： \[ f_{i,j}=\max_{0&lt;k&lt;j}\{f_{k,j-1}+sum_k\times(sum_i-sum_k)\} \] 为什么当前转移的贡献是\(sum_k \times (sum_j-sum_k)\)呢？因为顺序对答案并不造成影响，所以当前这个位置最大的贡献应该是第\(k\)个位置被第一个切割所产生的贡献的最大值。 我们发现转移只与上一维相关，所以我们可以滚动数组优化。我们记\(f_{i,j}\)为\(F_i\)，\(f_{k,j-1}\)为\(G_k\)，那么方程变为： \[ F_i=\max_{0&lt;k&lt;j}\{G_k+sum_k\times(sum_i-sum_k)\} \] 考虑斜率优化，我们任取\(i\)之前的两个位置\(x\)和\(y\)且满足\(x&lt;y\)并且取\(y\)较之取\(x\)答案更优，那么： \[ G_y+sum_y\times(sum_i-sum_y) \geqslant G_x+sum_x \times (sum_i-sum_x) \] 变换一下形式可得； \[ \frac{(g_y-sum_y^2)-(g_x-sum_x^2)}{sum_x-sum_y} \geqslant sum_i \] 因此我们维护一下下凸壳就可以了。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738/*Program from Luvwgyx*/#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define sqr(x) ((x)*(x))#define int long long#define write(x) printf("%lld\n",x)using namespace std;const int inf=1e18;const int maxn=1e5+10;const int maxm=2e2+10;int n,K,a[maxn],f[maxn],g[maxn],sum[maxn],q[maxn],pre[maxn][maxm];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;double calc(int x,int y)&#123; if(sum[x]==sum[y])return -inf; return 1.0*((g[x]-sqr(sum[x]))-(g[y]-sqr(sum[y])))/(sum[y]-sum[x]);&#125;signed main()&#123; n=read();K=read(); for(int i=1;i&lt;=n;i++)a[i]=read(),sum[i]=sum[i-1]+a[i]; for(int j=1;j&lt;=K;j++)&#123; int l=1,r=0;q[++r]=0; for(int i=1;i&lt;=n;i++)&#123; while(l&lt;r&amp;&amp;calc(q[l],q[l+1])&lt;=sum[i])l++; f[i]=g[q[l]]+sum[q[l]]*(sum[i]-sum[q[l]]);pre[i][j]=q[l]; while(l&lt;r&amp;&amp;calc(q[r-1],q[r])&gt;=calc(q[r],i))r--;q[++r]=i; &#125;memcpy(g,f,sizeof(f)); &#125;write(f[n]);int pos=n; for(int i=K;i&gt;=1;i--)pos=pre[pos][i],printf("%lld ",pos);puts(""); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 66]]></title>
    <url>%2F2019%2F09%2F01%2FEducational-Codeforces-Round-66%2F</url>
    <content type="text"><![CDATA[比赛链接 Educational Codeforces Round 66 A. From Hero to Zero 题目大意 给定\(n\)和\(k\)，你可以进行两种操作： 将\(n\)减一。 将\(n\)除以\(k\)。 现在你要将\(n\)变成\(0\)，问最小的操作次数。 解题思路 很显然，如果\(n|k\)，那么将\(n\)除以\(k\)显然比一个一个减更优\(k&gt;1\)，所以如果当前\(n|k\)，那么就除，否则就一个一个减。 参考代码 12345678910111213141516171819202122232425262728/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int T=read(); while(T--)&#123; int n=read(),k=read(),ans=0; if(k==1)&#123;write(n);continue;&#125; while(n&gt;0)&#123; if(n%k)ans+=n%k,n-=n%k; while(!(n%k)&amp;&amp;n&gt;0)n/=k,ans++; &#125;write(ans); &#125; return 0;&#125; B. Catch Overflow! 题目大意 你有一个数\(x\)，\(x\)开始的值为\(0\)，读入\(l\)个操作，总共有三种： \(\rm for~n\) 从\(1\)到\(n\)的循环 \(\rm end\) 结束最近的一个循环（相当于是大括号） \(\rm add\) 给\(x\)加上\(1\) 现在要你给出这些操作后\(x\)的值，保证操作合法，如果在计算过程中\(x\)的值超过了\(2^{32}-1\)，输出OVERFLOW!!!。 解题思路 显然，开一个栈模拟就好了，细节问题自己考虑。 参考代码 12345678910111213141516171819202122232425262728293031/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int maxn=1e5+10;char s[10];int top,sta[maxn],ret[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int n=read(),ans=0,sum=0,flag=0,inf=pow(2,32)-1; for(int i=1;i&lt;=n;i++)&#123; scanf("%s",s); if(s[0]=='f')sta[++top]=read(),ret[top]=0; if(s[0]=='a')&#123;if(top)ret[top]++;else ans++;&#125; if(s[0]=='e')&#123; sum=sta[top]*ret[top]; sta[top--]=0;ret[top]+=sum; &#125;if(ans+ret[top]&gt;inf)&#123;puts("OVERFLOW!!!");flag=1;break;&#125; &#125;if(!flag)&#123;if(ans+ret[0]&gt;inf)puts("OVERFLOW!!!");else write(ans+ret[0]);&#125; return 0;&#125; C. Electrification 题目大意 在数轴上有\(n\)个点\(a_1,a_2,\cdots,a_n\)，\(a\)数组保证从小到大排列，给定\(k\)，现在要你找出一个点\(x\)，使得\(f_k(x)\)最小。 \(f_k(x)\)的定义如下：将给定的\(n\)个点与\(x\)的距离列出来，从小到大排序后第\(k+1\)个数就是\(f_k(x)\)的值。 解题思路 很显然我们只需要在长度为\(k\)的区间中找到最大值和最小值差值最小的那个就行了。 参考代码 12345678910111213141516171819202122232425262728293031/*Program from Luvwgyx*/#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long long#define write(x) printf("%lld\n",x)using namespace std;const int inf=1e18;const int maxn=2e5+10;int a[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;signed main()&#123; int T=read(); while(T--)&#123; int n=read(),k=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); int mn=inf,pos=0; for(int i=k+1;i&lt;=n;i++)&#123; int mid=(a[i-k]+a[i])/2,mx=max(mid-a[i-k],a[i]-mid); if(mx&lt;mn)mn=mx,pos=mid; &#125;write(pos); &#125; return 0;&#125; D. Array Splitting 题目大意 给定一个长度为\(n\)的序列\(a\)，现在要你将其分成\(K\)段，第\(i\)个点的贡献为\(a_i \times f(i)\)，其中\(f(x)\)表示\(x\)在第几段。 解题思路 我们有一个很巧妙的思路，我们先将所有的数都选\(K\)遍，然后不断地删除。 我们将每个位置的前缀和都求出来，然后取从小到大前\(K-1\)个前缀，将他们从答案中减去，最开始的答案自然是所有元素的和\(\times K\)。 参考代码 123456789101112131415161718192021222324/*Program from Luvwgyx*/#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long long#define write(x) printf("%lld\n",x)using namespace std;const int maxn=3e5+10;int a[maxn],sum[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;signed main()&#123; int n=read(),k=read(); for(int i=1;i&lt;=n;i++)a[i]=read(),sum[i]=sum[i-1]+a[i]; int ans=sum[n]*k;sort(sum+1,sum+n); for(int i=1;i&lt;k;i++)ans-=sum[i];write(ans); return 0;&#125; E. Minimal Segment Cover 题目大意 给定\(n\)个线段\([l,r]\)，覆盖着数轴上的点，现在需要回答\(m\)个询问，对于每个询问有一个区间\([x,y]\)，要求最少需要多少个线段能覆盖这个区间内的所有点。 解题思路 我们考虑\(DP\)，设\(f_{i,j}\)表示对于第\(i\)个点，用\(2^j\)条线段最多能覆盖到哪个点，然后对于每个询问都去分割一遍就可以了。 参考代码 12345678910111213141516171819202122232425262728293031323334/*Program from Luvwgyx*/#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long long#define write(x) printf("%lld\n",x)using namespace std;const int maxn=1e6+10;int n,m,f[maxn][23];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;int query(int l,int r)&#123; int ret=0; for(int i=22;i&gt;=0;i--) if(f[l][i]&lt;r)l=f[l][i],ret+=(1&lt;&lt;i); l=f[l][0];ret++; return l&lt;r?-1:ret;&#125;signed main()&#123; n=read();m=read();int mx=0; for(int i=1;i&lt;=n;i++)&#123; int l=read()+1,r=read()+1; f[l][0]=max(f[l][0],r);mx=max(mx,r); &#125;for(int i=1;i&lt;=mx;i++)f[i][0]=max(f[i][0],max(i,f[i-1][0])); for(int j=1;j&lt;23;j++)for(int i=1;i&lt;=mx;i++)f[i][j]=f[f[i][j-1]][j-1]; while(m--)&#123;int l=read()+1,r=read()+1;write(query(l,r));&#125; return 0;&#125; F. The Number of Subpermutations 题目大意 给定一个长度为\(n\)的序列，定义一段连续的子序列\([l,r]\)是好的，当且仅当\(a_l,a_{l+1},...a_r\)中\(1\)到\(r-l+1\)这些数出现且仅出现一次。现在需要知道这个序列中有多少个子序列是好的。 解题思路 我们可以将原题意转化一下，就变成了两个约束条件： 区间\([l,r]\)中的每个数都只出现了一次 区间内的数的最大值为\(r-l+1\) 我们先考虑如何找出满足第一个约束条件的子序列。 我们从后往前扫这个序列，用\(nxt_i\)表示以第\(i\)个点为左端点，往右最多能走到哪个位置，使得这个位置到\(i\)位置中间的数都只出现了一次。再令\(pos_i\)表示数\(i\)最新出现的位置，那么\(nxt_i=\min(nxt_{i+1},pos_{a_i})\)。 我们再考虑如何满足第二个约束条件。 我们枚举区间的左端点\(i\)，然后枚举区间的右端点\(j \in [i,nxt_i-1]\)，每次判断区间\([i,j]\)的最大值是否\(&gt;r\)，如果是则更新\(j\)到\(i+mx\)就行了。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*Program from Luvwgyx*/#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long long#define write(x) printf("%lld\n",x)using namespace std;const int maxn=3e5+10;int n,a[maxn],pos[maxn],nxt[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct Segment_Tree&#123; int tree[maxn&lt;&lt;2]; void update(int k)&#123;tree[k]=max(tree[k&lt;&lt;1],tree[k&lt;&lt;1|1]);&#125; void build(int k,int l,int r)&#123; if(l==r)&#123;tree[k]=a[l];return ;&#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); update(k); &#125; int query(int k,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;r&lt;=y)return tree[k]; int mid=(l+r)&gt;&gt;1,ret=0; if(x&lt;=mid)ret=max(ret,query(k&lt;&lt;1,l,mid,x,y)); if(mid&lt;y)ret=max(ret,query(k&lt;&lt;1|1,mid+1,r,x,y)); return ret; &#125;&#125;T;signed main()&#123; n=read();int ans=0; for(int i=1;i&lt;=n;i++)a[i]=read(),pos[i]=n+1; T.build(1,1,n);nxt[n+1]=n+1; for(int i=n;i&gt;=1;i--)&#123; nxt[i]=min(nxt[i+1],pos[a[i]]);pos[a[i]]=i; for(int j=i;j&lt;nxt[i];j++)&#123; int x=T.query(1,1,n,i,j); if(i+x-1&gt;j)j=i+x-2;else ans++; &#125; &#125;write(ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>CF比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 5 1008]line symmetric]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-5-1008-line-symmetric%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 二维平面上有一个\(n\)个点的简单多边形，问能否改变一个点的坐标使其变成轴对称的简单多边形，点的连接顺序不改变，轴对称指图形对称。 解题思路 由于我计算几何太菜，所以直接用直线的一般式来写的这题... 我们先枚举相邻的点，以它们的垂直平分线作为对称轴，然后用两个指针\(l\)和\(r\)分别向两边枚举对称的点，将它们的直线解析式求出来，然后与对称轴比较，看是否被垂直平分，如果没有则这组不对称。由于我们并不关心改点的坐标到哪里去，所以我们只需要标记使用过修改次数了，如果后面又扫到了不对称的点，那么这个对称轴就不行，需要接着枚举下去。 最基本的做完了之后，我们发现如果最开始枚举来得到对称轴的点对所在的直线如果是平行于\(x\)轴或者\(y\)轴的话，我们是不好通过将点的坐标代入解析式来判断是否该点在这条直线上的，所以我们需要特判这种情况。 接着我们考虑一下这种“生草图”，注意到如果是按照我们之前的做法来判断这个图的话，会判断成能变成轴对称图形，我们发现坐标为\((7,4)\)的点可以移到点\((1,1)\)和\((4,2)\)所构成的直线的下面来与点\((0,0)\)对称。而这种移法是不合法的，因为移动之后图形并不是简单多边形了，我们需要特判这种移动之后不是简单多边形的情况。 我们可以用叉积来做这件事。我们设\((7,4)\)为\(a\)，\((0,0)\)为\(b\)，\((1,1)\)为\(x\)，\((4,2)\)为\(y\)，\(b\)关于对称轴对称的点为\(c\)，通过判断\(\vec {ax} \times \vec{ay}\)与\(\vec{cx} \times \vec{cy}\)的正负性是否相同来判断是否合法，然后我把如果是合法的对称情况满足的性质都判了一遍，这样就过了..... 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;#define sqr(x) ((x)*(x))using namespace std;const int maxn=2e3+10;double eps=1e-12;struct node&#123;double x,y;&#125;a[maxn];struct line&#123;double A,B,C;&#125;;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void Write(line x)&#123;printf("%.4lf %.4lf %.4lf\n",x.A,x.B,x.C);&#125;void Write1(node x)&#123;printf("%.4lf %.4lf\n",x.x,x.y);&#125;line calc(node x,node y)&#123; double A=y.y-x.y; double B=x.x-y.x; double C=y.x*x.y-x.x*y.y; return (line)&#123;A,B,C&#125;;&#125;node get_sym(node x,line y)&#123; int xx=((sqr(y.B)-sqr(y.A))*x.x-2*y.A*y.B*x.y-2*y.A*y.C); int yy=((sqr(y.A)-sqr(y.B))*x.y-2*y.A*y.B*x.x-2*y.B*y.C); return (node)&#123;xx/(sqr(y.A)+sqr(y.B)),yy/(sqr(y.A)+sqr(y.B))&#125;;&#125;bool pd(double x,double y)&#123;return fabs(x-y)&lt;eps;&#125;bool check(line x,line y)&#123;return pd(x.A,y.A)&amp;&amp;pd(x.B,y.B)&amp;&amp;pd(x.C,y.C);&#125;bool pdcz(line x,line y)&#123;return x.A*y.A+x.B*y.B==0;&#125;bool Check(node x,line y)&#123;return y.A*x.x+y.B*x.y+y.C==0;&#125;bool pdpx(line x,line y)&#123;return x.A*y.B-y.A*x.B==0;&#125;int zf(double x)&#123;if(pd(x,0.0))return 0;if(x&lt;0)return -1;else return 1;&#125;double get(node a1,node a2,node b1,node b2)&#123;return (a2.x-a1.x)*(b2.y-b1.y)-(b2.x-b1.x)*(a2.y-a1.y);&#125;bool pdch(line x,line y)&#123;return x.A/y.A==x.B/y.B&amp;&amp;x.A/y.A==x.C/y.C&amp;&amp;x.B/y.B==x.C/y.C;&#125;bool CHeck(node x,node y,line std,node xx,node yy)&#123; node symm=get_sym(xx,std); if(zf(get(x,xx,x,y))!=zf(get(x,symm,x,y)))return 0; if(zf(get(y,xx,y,x))!=zf(get(y,symm,y,x)))return 0; if(zf(get(xx,x,xx,y))!=zf(get(yy,x,yy,y)))return 0; if(zf(get(xx,x,xx,y))!=zf(get(symm,x,symm,y)))return 0; if(zf(get(xx,yy,xx,y))!=zf(get(xx,symm,xx,y)))return 0; if(zf(get(xx,yy,xx,x))!=zf(get(xx,symm,xx,x)))return 0; return 1;&#125;int main()&#123; //freopen("1008.in","r",stdin); //freopen("1008.out","w",stdout); int T=read(); while(T--)&#123; int n=read(); for(int i=1;i&lt;=n;i++)scanf("%lf%lf",&amp;a[i].x,&amp;a[i].y); if(n&lt;=4)&#123;puts("Y");continue;&#125;bool flagg=0; for(int i=1;i&lt;=n;i++)&#123; int xx=i,yy=i==n?1:i+1;line std=calc(a[xx],a[yy]); node mid=(node)&#123;(a[xx].x+a[yy].x)/2,(a[xx].y+a[yy].y)/2&#125;; line vert=(line)&#123;std.B,-std.A,std.A*mid.y-std.B*mid.x&#125;; int l=(xx-1)?(xx-1):n,r=(yy+1==n+1)?1:yy+1; bool opt1=0,opt2=0; if(a[xx].y==a[yy].y)opt1=1; if(a[xx].x==a[yy].x)opt2=1; bool flag=0,Flag=0; while(1)&#123; line Std=calc(a[l],a[r]); node Mid=(node)&#123;(a[l].x+a[r].x)/2,(a[l].y+a[r].y)/2&#125;; if(Check(a[l],vert)&amp;&amp;Check(a[r],vert))&#123;Flag=1;break;&#125; if(opt1||opt2)&#123; if(opt1)&#123; if(a[l].y!=a[r].y)&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125;else &#123; if(a[l].x!=a[r].x)&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125; &#125;else &#123; if(!pdpx(std,Std))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125; int ll=(l-1)?(l-1):n,rr=(r+1==n+1)?1:r+1; if(ll==rr)&#123; if(!Check(a[ll],vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)Flag=1;else flag=1; &#125;break; &#125;else if(ll==r&amp;&amp;rr==l)break; l=ll;r=rr; &#125;if(!Flag)&#123;puts("Y");flagg=1;break;&#125; &#125;if(!flagg)&#123; for(int i=1;i&lt;=n;i++)&#123; int xx=i,yy=(i+2&lt;=n)?i+2:((i+2)%n);line std=calc(a[xx],a[yy]); node mid=(node)&#123;(a[xx].x+a[yy].x)/2,(a[xx].y+a[yy].y)/2&#125;; line vert=(line)&#123;std.B,-std.A,std.A*mid.y-std.B*mid.x&#125;; int l=(xx-1)?(xx-1):n,r=(yy+1==n+1)?1:yy+1; bool opt1=0,opt2=0; if(a[xx].y==a[yy].y)opt1=1; if(a[xx].x==a[yy].x)opt2=1; bool flag=0,Flag=0; while(1)&#123; line Std=calc(a[l],a[r]); node Mid=(node)&#123;(a[l].x+a[r].x)/2,(a[l].y+a[r].y)/2&#125;; if(Check(a[l],vert)&amp;&amp;Check(a[r],vert))&#123;Flag=1;break;&#125; if(opt1||opt2)&#123; if(opt1)&#123; if(a[l].x==mid.x&amp;&amp;a[r].x==mid.x)&#123;Flag=1;break;&#125; if(a[l].y!=a[r].y)&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125;else &#123; if(a[l].y==mid.y&amp;&amp;a[r].y==mid.y)&#123;Flag=1;break;&#125; if(a[l].x!=a[r].x)&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125; &#125;else &#123; if(!pdpx(std,Std))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(pdch(std,vert))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125;int ll=(l-1)?(l-1):n,rr=(r+1==n+1)?1:r+1; if(ll==rr)&#123; int half=(xx+1&lt;=n)?xx+1:1; line STd=calc(a[ll],a[half]); if(pdcz(STd,std))&#123; if(!Check(a[half],vert)&amp;&amp;!Check(a[ll],vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)Flag=1;else flag=1; &#125; &#125;else &#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)Flag=1;else flag=1; &#125;break; &#125;else if(ll==r&amp;&amp;rr==l)&#123; if(!Check(a[xx==n?1:xx+1],vert))&#123; if(flag)Flag=1;else flag=1; &#125;break; &#125;l=ll;r=rr; &#125;if(!Flag)&#123;puts("Y");flagg=1;break;&#125; &#125;if(!flagg)puts("N"); &#125;for(int i=1;i&lt;=n;i++)a[i].x=0.0,a[i].y=0.0; &#125; return 0;&#125;/*150 04 21 16 42 3 */]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>判判判</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 3 1007]Find the answer]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-3-1007-Find-the-answer%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 给定一个长度为\(n\)值域为\([1,m]\)的序列\(W\)，对于所有\(i (1 \leqslant i \leqslant n)\)，可以选择一些元素\(W_k(1 \leqslant k &lt; i)\)将它们变成\(0\)使得\(\sum_{j=1}^iW_j \leqslant m\)，对于所有\(i\)，求选择的元素的最小数目。 解题思路 碰到最小数目，我们可以想到二分，二分出最小数目，然后显然我们最优的选择方案就是选最大的那几个数，所以我们现在需要一个数据结构快速找到区间内最大的\(mid\)个数，很显然我们可以使用权值线段树。我们枚举\(i\)，二分\(mid\)，依次插入\(W_i\)，然后查询前\(mid\)大的数删去就好了。注意值域很大，要离散化。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn=2e5+10;int n,m,tot,lst[maxn],a[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;struct Segment_Tree&#123; struct node&#123;ll w;int cnt;&#125;tree[maxn&lt;&lt;2]; void clear()&#123;memset(tree,0,sizeof(tree));&#125; void update(int k)&#123; tree[k].w=tree[k&lt;&lt;1].w+tree[k&lt;&lt;1|1].w; tree[k].cnt=tree[k&lt;&lt;1].cnt+tree[k&lt;&lt;1|1].cnt; &#125; void change(int k,int l,int r,int x)&#123; if(l==r)&#123;tree[k].w+=lst[l];tree[k].cnt++;return ;&#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)change(k&lt;&lt;1,l,mid,x); else change(k&lt;&lt;1|1,mid+1,r,x); update(k); &#125; ll query(int k,int l,int r,int x)&#123; if(tree[k].cnt==x)return tree[k].w; if(l==r&amp;&amp;tree[k].cnt&gt;x)return 1ll*(tree[k].w/tree[k].cnt)*x; int mid=(l+r)&gt;&gt;1;ll ret=0; if(tree[k&lt;&lt;1|1].cnt&gt;=x)return query(k&lt;&lt;1|1,mid+1,r,x); else &#123; ret+=query(k&lt;&lt;1|1,mid+1,r,tree[k&lt;&lt;1|1].cnt); ret+=query(k&lt;&lt;1,l,mid,x-tree[k&lt;&lt;1|1].cnt); &#125;return ret; &#125; void dfs(int k,int l,int r)&#123; if(l==r)&#123;printf("%d %lld %d\n",l,tree[k].w,tree[k].cnt);return ;&#125; int mid=(l+r)&gt;&gt;1; dfs(k&lt;&lt;1,l,mid);dfs(k&lt;&lt;1|1,mid+1,r); &#125;&#125;T;int main()&#123; int Q=read(); while(Q--)&#123; tot=0;memset(lst,0,sizeof(lst)); n=read();m=read();ll sum=0;T.clear(); for(int i=1;i&lt;=n;i++)a[i]=lst[i]=read(); sort(lst+1,lst+n+1);tot=unique(lst+1,lst+n+1)-lst-1; for(int i=1;i&lt;=n;i++)a[i]=lower_bound(lst+1,lst+tot+1,a[i])-lst; //for(int i=1;i&lt;=n;i++)printf("%d ",a[i]);puts(""); for(int i=1;i&lt;=n;i++)&#123; sum+=lst[a[i]];//cerr&lt;&lt;sum&lt;&lt;endl; int l=0,r=i; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1;ll val=T.query(1,1,n,mid); //cerr&lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt;endl; //printf("%d %d %lld\n",i,mid,val); if(sum-val&lt;=m)r=mid-1; else l=mid+1; &#125;printf("%d ",l);T.change(1,1,n,a[i]); &#125;puts(""); //T.dfs(1,1,n); &#125; return 0;&#125;/*2 7 15 1 2 3 4 5 6 7 5 100 80 40 40 40 60 */]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 2 1009]I Love Palindrome String]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-2-1009-I-Love-Palindrome-String%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 给定一个串\(S\)，要你统计所有长度为\(i \in [1,|S|]\)的子串\(s=s_ls_{l+1}...s_r\)满足\(s\)回文，\(s_ls_{l + 1}...s_{ \lfloor (l + r) / 2 \rfloor }\)也回文的个数。 解题思路 回文自动机裸题。 PS：话说这是我接触回文自动机之后第一次用回文自动机写题欸... 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define write(x) printf("%d\n",x)using namespace std;const int maxn=3e5+10;char s[maxn];struct node&#123;int to,nxt;&#125;e[maxn&lt;&lt;1];int cnt,lst,tot,f[maxn],ans[maxn],ret[maxn],head[maxn],len[maxn],fail[maxn],trie[maxn][26];int read()&#123; int x=0,f=1;char trie=getchar(); while(trie&lt;'0'||trie&gt;'9')&#123;if(trie=='-')f=-1;trie=getchar();&#125; while(trie&gt;='0'&amp;&amp;trie&lt;='9')&#123;x=x*10+trie-'0';trie=getchar();&#125; return x*f;&#125;void add(int u,int v)&#123;e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;&#125;void dfs(int x)&#123; f[len[x]]++;if(f[(len[x]&amp;1)?(len[x]/2+1):(len[x]/2)])ans[len[x]]+=ret[x]; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to)dfs(v);f[len[x]]--;&#125;int main()&#123; while(scanf("%s",s+1)!=EOF)&#123; cnt=1;lst=tot=0; memset(f,0,sizeof(f)); memset(ans,0,sizeof(ans)); memset(ret,0,sizeof(ret)); memset(len,0,sizeof(len)); memset(head,0,sizeof(head)); memset(fail,0,sizeof(fail)); memset(trie,0,sizeof(trie)); s[0]='#';fail[0]=1;len[1]=-1;int n=strlen(s+1); for(int i=1;i&lt;=n;i++)&#123; int p,ch=s[i]-'0'; while(s[i-len[lst]-1]!=s[i])lst=fail[lst]; if(!trie[lst][ch])&#123; len[++cnt]=len[lst]+2;ret[cnt]=1;p=fail[lst];//puts("ok"); while(s[i-len[p]-1]!=s[i])p=fail[p]; fail[cnt]=trie[p][ch]; lst=trie[lst][ch]=cnt; &#125;else ret[lst=trie[lst][ch]]++; &#125;for(int i=cnt;i&gt;=2;i--)ret[fail[i]]+=ret[i]; for(int i=cnt;i&gt;=2;i--)add(fail[i],i);dfs(0); for(int i=1;i&lt;n;i++)printf("%d ",ans[i]);printf("%d\n",ans[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 1 1009]string]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-1-1009-string%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 给定一个串\(S\)，要求从中选出一个长度为\(K\)的子序列串，该串满足第\(i\)个字母出现的次数在区间\([L_i,R_i]\)之间，且是所有满足条件的串中字典序最小的。 解题思路 记一个后缀和\(sum_{i,j}\)表示在位置\(i\)，字母\(j\)在\(i\)之后出现了多少次。记一个辅助数组\(lst_{i,j}\)表示在位置\(i\)之后\(j\)字母第一次出现的位置。 然后很显然的一个贪心想法就是从\(a\)到\(z\)，如果当前除了每个字母要求出现次数的下界之外还有剩余位置可以填，那么就填当前的位置，不过值得注意的是，在这里需要判断一下填了这个字母之后，在当前位置之后第一次出现这个字母的位置之后还能不能满足其他字母的下界，如果不能就不能填这个字母。再判断一下当前余下的需要填的字母数是否刚好是字母要求出现次数的下界和，如果是则不需要贪心了。注意前面这个判断需要在每一个位置填的时候都要判断一下，因此这道题实际上是一道判判判题（这辈子都不想写判判判题了！！！）。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define write(x) printf("%d\n",x)using namespace std;const int maxm=50;const int maxn=3e5+10;char s[maxn],ans[maxn];int sum[maxm][maxn],lst[maxn][maxm],L[maxm],R[maxm],f[maxm];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;int main()&#123; while(scanf("%s",s+1)!=EOF)&#123; memset(f,0,sizeof(f)); memset(lst,0,sizeof(lst)); memset(sum,0,sizeof(sum)); int K=read(),len=strlen(s+1),now=0,cnt=0; for(int i=1;i&lt;=26;i++)L[i]=read(),R[i]=read(); for(int i=1;i&lt;=26;i++)for(int j=len;j;j--)sum[i][j]=sum[i][j]+sum[i][j+1]+((s[j]-'a'+1)==i); for(int i=len;i&gt;=0;i--)for(int j=1;j&lt;=26;j++)&#123;if(s[i+1]=='a'+j-1)lst[i][j]=i+1;else lst[i][j]=lst[i+1][j];&#125; //for(int i=0;i&lt;=len;i++)&#123;for(int j=1;j&lt;=26;j++)printf("%d ",lst[i][j]);puts("");&#125; //for(int i=1;i&lt;=26;i++)&#123;for(int j=1;j&lt;=len;j++)printf("%d ",sum[i][j]);puts("");&#125; int ret=0;for(int i=1;i&lt;=26;i++)ret+=L[i];if(ret&gt;K)&#123;puts("-1");continue;&#125;bool Flag=0;//puts("ok"); for(int i=1;i&lt;=K;i++)&#123; for(int j=1;j&lt;=26;j++)&#123; int pos=lst[now][j],ret=0;bool flag=0;//write(pos); for(int k=1;k&lt;=26;k++)ret+=max(L[k]-f[k],0); //write(ret); if(!pos||f[j]&gt;=R[j])continue;//printf("%d %d\n",ret,K-i+1); if(ret==K-i+1)&#123; if(f[j]&gt;=L[j])continue; for(int k=1;k&lt;=26;k++)if(sum[k][pos]&lt;L[k]-f[k])&#123;flag=1;break;&#125; &#125;else &#123;for(int k=1;k&lt;=26;k++)if(sum[k][pos]&lt;L[k]-f[k])&#123;flag=1;break;&#125;&#125; if(!flag)&#123;ans[i]=((char)j+'a'-1);f[j]++;now=pos;Flag=1;cnt++;break;&#125; &#125;if(!Flag)&#123;puts("-1");break;&#125; &#125;if(cnt&lt;K)puts("-1");else if(Flag)&#123;for(int i=1;i&lt;=K;i++)putchar(ans[i]);puts("");&#125; &#125; return 0; &#125;/*adddaaaabbbcccccccccbcdegfhijklmnopqrstuvwxyzbbbe 161 44 41 81 12 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0*/]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>判判判</tag>
      </tags>
  </entry>
</search>
