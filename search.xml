<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[随笔及摘录]]></title>
    <url>%2F2020%2F02%2F21%2F%E9%9A%8F%E7%AC%94%E5%8F%8A%E6%91%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[满掌阳光姑姑偶尔会在同事和朋友面前提到她的女儿：“小丫好可爱好伶俐，可惜我实在太忙，不得不把她寄养在亲戚家。”兴致盎然的时候，姑姑甚至大张旗鼓地购买一些花衣服，然后偷偷赠送给我们姐妹。其实，姑姑一生没嫁，亦没过继子女。但是全家一直替她保守着这个秘密，直到她仙逝。姑姑是个各方面均成功的女性，惟独没有婚姻，没有儿女，所以比起她的谎言，她个人生活的缺憾让人同情。 我们体味她理解她，在潜意识中替她勾勒并美化女儿的形象。姑姑的岁月里一直存在一个女儿，那就是对女儿的渴望。 台湾女作家三毛的好友经过调查披露，三毛书中的爱情故事多属虚构。 所以，当我从报纸上看到这样一则消息的时候，满心都是眼泪。 也许，三毛的爱情并不……但又有何妨?柔弱，敏感而多情的三毛一直用心血一字一字地描绘她心目中的爱人和爱情。为何一定要揭开一个善良女人的面纱，暴露她身上的瑕疵呢? 我宁可相信三毛的爱情故事。在书中，在想象中，在一切美好的事物中。 小时候，有一次父亲摊开两只宽大的手，让我看上面有什么。 “满掌阳光。”我喜悦地叫。 父亲笑了，他试图解释，但话到唇边，止住了。 手掌的背面，是一大片阴影。一面明，一面暗，这才是摊开手掌的全部内容。但是，我宁可偏信满手都是阳光。我猜这是父亲的美好心愿。 人活着不可能没有阴影，人不就是为了追逐阳光，才一步步远离黑暗吗？ 这是2020.2.21老师选录在早读资料中的文章，第一次读就让我心生感触。 作者的姑姑令人怜惜，作者一家令人感动，这种守护不也是一种善良吗？ 三毛用她的文字描绘她心中期望的爱情，将她心中的温柔与善良灌注到自己的文字当中，这种能使读者感同身受，能将积极的态度传递到人们心中去，这难道不是一位优秀的、应当受人敬重的文学大家吗？ 这位披露三毛真实境况的所谓好友，不管初衷如何，是单纯的好奇，亦或是为名、为利，单论此种做法， 便是暴戾的。 娱乐？娱乐。你眼中的娱乐，也许是他人倾注一切也要护住的，心中的柔弱。 ——2020.2.21早晨 读《满掌阳光》有感 「明明知道你已为我跋涉千里，却又觉得芳草鲜美，落英缤纷，好像你我才初初相遇。」 ——席慕蓉 残月下的站台，她目光追着他远去的背影，数着步子等他回头。渐渐地，车站里生出几株榕树，夕阳在树梢上喘息似的颤动。那条青石路，那间老药铺，一切一切渐渐在金色光晕中朦胧浮现。一步、两步……他终于回身向她挥了挥手，周遭在他转身的刹那清晰起来……那是他们初次交谈时沐浴过的黄昏。 席慕蓉的言语中，流露着自然与时间流逝的美。“芳草鲜美，落英缤纷”多么美好的意象，正将两人经历了种种之后重逢的内心的情感用周遭景象表现出来，美。 由席慕蓉的文字而衍生出的这段文字则充满了画面感，更有一种电影似的时间的动感。榕树、青石路、老药铺、夕阳，这些意象交融在一起，和谐而宁静，别样的美。文字描写细腻，读来有种电影放映的感觉，画面感很强。]]></content>
      <categories>
        <category>文章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2016」换教室]]></title>
    <url>%2F2019%2F11%2F13%2F%E3%80%8CNOIP2016%E3%80%8D%E6%8D%A2%E6%95%99%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[题目链接 LOJ 解题思路 很显然是\(\rm DP\)，设\(f_{i,j,0/1}\)表示前\(i\)时间段，申请了\(j\)次，第\(i\)个时间段有没有申请，转移蛮简单的，只不过要写很多... 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e3+10;const int maxm=3e2+10;double p[maxn],f[maxn][maxn][2];int n,m,V,e,c[maxn],d[maxn],dis[maxm][maxm];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void Min(double &amp;x,double y)&#123;x=min(x,y);&#125;void init()&#123; for(int k=1;k&lt;=V;k++) for(int i=1;i&lt;=V;i++) for(int j=1;j&lt;=V;j++) if(dis[i][j]&gt;dis[i][k]+dis[k][j])dis[i][j]=dis[i][k]+dis[k][j]; for(int i=1;i&lt;=V;i++)dis[0][i]=dis[i][0]=dis[i][i]=0; for(int i=1;i&lt;=n;i++)for(int j=0;j&lt;=m;j++)f[i][j][0]=f[i][j][1]=1e9;&#125;int main()&#123; //freopen("data.in","r",stdin); n=read();m=read();V=read();e=read(); for(int i=1;i&lt;=n;i++)c[i]=read(); for(int i=1;i&lt;=n;i++)d[i]=read(); for(int i=1;i&lt;=n;i++)scanf("%lf",&amp;p[i]); memset(dis,63,sizeof(dis)); for(int i=1;i&lt;=e;i++)&#123; int u=read(),v=read(),w=read(); dis[u][v]=min(dis[u][v],w); dis[v][u]=min(dis[v][u],w); &#125;init(); for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=min(i,m);j++)&#123; if(i-2&gt;=j)Min(f[i][j][0],f[i-1][j][0]+dis[c[i-1]][c[i]]); if(i-1&gt;=j)&#123; Min(f[i][j][0],f[i-1][j][1]+(1-p[i-1])*dis[c[i-1]][c[i]]+p[i-1]*dis[d[i-1]][c[i]]); if(j&gt;0)Min(f[i][j][1],f[i-1][j-1][0]+(1-p[i])*dis[c[i-1]][c[i]]+p[i]*dis[c[i-1]][d[i]]); &#125;if(j&gt;0)Min(f[i][j][1],f[i-1][j-1][1]+(1-p[i])*(1-p[i-1])*dis[c[i-1]][c[i]]+p[i]*(1-p[i-1])*dis[c[i-1]][d[i]]+(1-p[i])*p[i-1]*dis[d[i-1]][c[i]]+p[i]*p[i-1]*dis[d[i-1]][d[i]]); &#125; double ans=1e9; for(int i=0;i&lt;=m;i++)for(int j=0;j&lt;2;j++)Min(ans,f[n][i][j]); printf("%.2lf\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>期望</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIP2017」时间复杂度]]></title>
    <url>%2F2019%2F11%2F13%2F%E3%80%8CNOIP2017%E3%80%8D%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目链接 LOJ 解题思路 突然开始担心NOIP....这个题我第一次写完的时候信心满满觉得自己A了，结果只有\(60pts\)...还花了\(40min\)左右...这还是平常写题，在考场上可能还得花更多时间... 思路很简单，直接用栈去模拟就好了。模拟题的话，还是把需要模拟的东西分成几个部分，一个一个地去写不容易错。 这个题，我就先判断是否编译错误，然后再判断是否是常数复杂度，最后再判断复杂度是否相同。 由于可能存在循环运行次数为\(0\)而使后面的复杂度算错，所以我设了一个\(mul_i\)表示现在在栈里的第\(i\)个循环是否会运行，再设了一个\(now_i\)表示栈里的第\(i\)个循环的层数是多少，每次出栈的时候取个最大值就好了。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int maxn=1e5+10;struct node&#123;char opt[10],bl[10],from[10],to[10];&#125;a[maxn];int n,top,f[maxn],sta[maxn],mul[maxn],now[maxn];char tim[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void init()&#123;for(int i=0;i&lt;maxn;i++)mul[i]=1,now[i]=0;&#125;int get(char *s)&#123; int pos=0,ret=0; while(s[pos+1]&lt;'0'||s[pos+1]&gt;'9')pos++; while(s[pos+1]&gt;='0'&amp;&amp;s[pos+1]&lt;='9')ret=ret*10+s[++pos]-'0'; return ret;&#125;bool check(int x)&#123; if(a[x].from[1]=='n'&amp;&amp;a[x].to[1]=='n')return 1; if(a[x].from[1]!='n'&amp;&amp;a[x].to[1]!='n')return 1; return 0;&#125;signed main()&#123; int T=read(); while(T--)&#123; n=read();scanf("%s",tim+1);int flag=0,ans; if(tim[3]=='n')flag=1,ans=get(tim);else ans=1; int cnt1=0,cnt2=0;bool Flag=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%s",a[i].opt+1); if(a[i].opt[1]=='E')&#123;cnt2++;continue;&#125;cnt1++; scanf("%s%s%s",a[i].bl+1,a[i].from+1,a[i].to+1); &#125;if(n&amp;1||cnt1!=cnt2)&#123;puts("ERR");continue;&#125; memset(f,0,sizeof(f)); for(int i=1;i&lt;=n;i++)&#123; if(a[i].opt[1]=='F')&#123; int c=a[i].bl[1]-'a'; if(f[c])&#123;Flag=1;break;&#125; sta[++top]=c;f[c]=1; &#125;else f[sta[top]]=0,top--; &#125;if(Flag)&#123;puts("ERR");continue;&#125; int opt=0;init();Flag=0;top=0; for(int i=1;i&lt;=n;i++)&#123; if(a[i].opt[1]=='F')&#123; if(check(i))&#123;top++;mul[top]*=mul[top-1];continue;&#125; if(a[i].from[1]=='n')&#123;mul[++top]=0;continue;&#125; if(a[i].to[1]=='n')&#123;top++;mul[top]*=mul[top-1];if(mul[top])&#123;opt=1;break;&#125;&#125; &#125;else mul[top--]=1; &#125;if(flag!=opt)&#123;puts("No");continue;&#125; if(!flag&amp;&amp;!opt)&#123;puts("Yes");continue;&#125; top=0;init();int ret=0; for(int i=1;i&lt;=n;i++)&#123; if(a[i].opt[1]=='F')&#123; if(check(i))&#123; top++; if(a[i].from[1]!='n'&amp;&amp;a[i].to[1]!='n')&#123; int ret1=get(a[i].from),ret2=get(a[i].to); if(ret1&gt;ret2)mul[top]=0; &#125;mul[top]*=mul[top-1];now[top]=mul[top]*now[top-1]; continue; &#125; if(a[i].from[1]=='n')&#123;mul[++top]=0;continue;&#125; if(a[i].to[1]=='n')&#123; top++; mul[top]*=mul[top-1]; now[top]=mul[top]*(now[top-1]+1); &#125; &#125;else mul[top]=1,ret=max(ret,now[top]),now[top]=0,top--; &#125;if(ret!=ans)puts("No");else puts("Yes"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BalticOI 2015」网络]]></title>
    <url>%2F2019%2F11%2F11%2F%E3%80%8CBalticOI-2015%E3%80%8D%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[题目链接 LOJ 解题思路 首先可以确定的是，答案为叶子节点个数除以\(2\)向下取整。 考虑如何构造，题目需要满足的条件可以转化为所有的边都至少被一个环包含，那么构造就很显然了。 参考代码 12345678910111213141516171819202122232425262728293031323334/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e5+10;struct node&#123;int to,nxt;&#125;e[maxn&lt;&lt;1];int n,tot,cnt,head[maxn],q[maxn],deg[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void add(int u,int v)&#123;e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;deg[v]++;&#125;void insert(int u,int v)&#123;add(u,v);add(v,u);&#125;void dfs(int x,int fa)&#123; if(deg[x]==1)q[++cnt]=x; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(v!=fa)dfs(v,x);&#125;int main()&#123; srand(time(0));n=read(); for(int i=2;i&lt;=n;i++)&#123;int u=read(),v=read();insert(u,v);&#125; dfs(1,0);int ans=(cnt+1)/2;write(ans); //for(int i=1;i&lt;=cnt;i++)printf("%d ",q[i]);puts(""); for(int i=1;i&lt;=cnt/2;i++)printf("%d %d\n",q[i],q[i+ans]); if(cnt&amp;1)&#123;int x=rand()%cnt+1;while(x==(cnt+1)/2)x=rand()%cnt+1;printf("%d %d\n",q[ans],q[x]);&#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JOI 2014 Final]]></title>
    <url>%2F2019%2F11%2F03%2FJOI-2014-Final%2F</url>
    <content type="text"><![CDATA[比赛链接 LOJ JOI 徽章 解题思路 枚举每一个位置，枚举修改成三个字符串，与原本的贡献比较。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e3+10;char s[maxn][maxn],chk[5][5];int n,m;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;int check(int x1,int y1,int x2,int y2)&#123; int flag=0; for(int i=x1;i&lt;=x2;i++)&#123; for(int j=y1;j&lt;=y2;j++) if(chk[i-x1+1][j-y1+1]!=s[i][j])&#123;flag=1;break;&#125; if(flag)break; &#125;return flag^1;&#125;signed main()&#123; n=read();m=read();int ans=0,mx=0; for(int i=1;i&lt;=n;i++)scanf("%s",s[i]+1); for(int i=1;i&lt;=2;i++)scanf("%s",chk[i]+1); for(int i=1;i&lt;n;i++)for(int j=1;j&lt;m;j++)ans+=check(i,j,i+1,j+1); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; int ret=0,ret1=0; if(i&gt;1&amp;&amp;j&gt;1)ret+=check(i-1,j-1,i,j); if(i&lt;n&amp;&amp;j&gt;1)ret+=check(i,j-1,i+1,j); if(i&gt;1&amp;&amp;j&lt;m)ret+=check(i-1,j,i,j+1); if(i&lt;n&amp;&amp;j&lt;m)ret+=check(i,j,i+1,j+1); char ch=s[i][j]; if(ch!='J')&#123; s[i][j]='J'; if(i&gt;1&amp;&amp;j&gt;1)ret1+=check(i-1,j-1,i,j); if(i&lt;n&amp;&amp;j&gt;1)ret1+=check(i,j-1,i+1,j); if(i&gt;1&amp;&amp;j&lt;m)ret1+=check(i-1,j,i,j+1); if(i&lt;n&amp;&amp;j&lt;m)ret1+=check(i,j,i+1,j+1); mx=max(mx,ret1-ret);s[i][j]=ch; &#125;ret1=0; if(ch!='O')&#123; s[i][j]='O'; if(i&gt;1&amp;&amp;j&gt;1)ret1+=check(i-1,j-1,i,j); if(i&lt;n&amp;&amp;j&gt;1)ret1+=check(i,j-1,i+1,j); if(i&gt;1&amp;&amp;j&lt;m)ret1+=check(i-1,j,i,j+1); if(i&lt;n&amp;&amp;j&lt;m)ret1+=check(i,j,i+1,j+1); mx=max(mx,ret1-ret);s[i][j]=ch; &#125;ret1=0; if(ch!='I')&#123; s[i][j]='I'; if(i&gt;1&amp;&amp;j&gt;1)ret1+=check(i-1,j-1,i,j); if(i&lt;n&amp;&amp;j&gt;1)ret1+=check(i,j-1,i+1,j); if(i&gt;1&amp;&amp;j&lt;m)ret1+=check(i-1,j,i,j+1); if(i&lt;n&amp;&amp;j&lt;m)ret1+=check(i,j,i+1,j+1); mx=max(mx,ret1-ret);s[i][j]=ch; &#125; &#125; write(ans+mx); return 0;&#125; IOI 馒头 解题思路 首先有一个很显然的贪心，馒头要从贵的卖起，因此我们先将馒头按卖价从大到小排序。 然后接着就是背包了。中间馒头卖出的钱可以通过前缀和处理，然后\(O(1)\)算出。 参考代码 123456789101112131415161718192021222324252627282930313233/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=2e4+10;int n,m,a[maxn],c[maxn],e[maxn],f[maxn],sum[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;bool cmp(int x,int y)&#123;return x&gt;y;&#125;signed main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); sort(a+1,a+n+1,cmp);int ans=0; for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i]; for(int i=1;i&lt;=m;i++)c[i]=read(),e[i]=read(); for(int i=1;i&lt;=m;i++) for(int j=n+c[i];j&gt;=c[i];j--) f[j]=max(f[j],f[j-c[i]]-e[i]+sum[min(n,j)]-sum[j-c[i]]),ans=max(ans,f[j]); write(ans); return 0;&#125; 年轮蛋糕 解题思路 二分。 二分最小块的最大值是多少，然后我们需要\(O(n)\)的\(check\)。 枚举第一刀切的位置，在保证第一块和第二块蛋糕大小都在\(mid\)以下的条件下切下后两刀，最后检查一下最后一块蛋糕的大小是否在\(mid\)以下即可。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=3e5+10;int n,a[maxn],sum[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;bool check(int x)&#123; int pos1=0,pos2=0,pos3=0; for(;pos1&lt;2*n;pos1++)&#123; while(pos2&lt;=3*n&amp;&amp;sum[pos2]-sum[pos1]&lt;x)pos2++; while(pos3&lt;=3*n&amp;&amp;sum[pos3]-sum[pos2]&lt;x)pos3++; if(pos3==3*n+1)return 0; if(sum[pos1+n]-sum[pos3]&gt;=x)return 1; &#125;return 0;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=a[i+n]=a[i+2*n]=read(); for(int i=1;i&lt;=3*n;i++)sum[i]=sum[i-1]+a[i]; int l=0,r=sum[n],ans; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))l=mid+1,ans=mid; else r=mid-1; &#125;write(ans); return 0;&#125; 飞天鼠 解题思路 很显然，我们要尽量减少中间升高和降低位置产生的代价。那么我们有一个贪心，在能飞的情况下就飞，不能飞就用最小的代价变成能飞的情况就好了。在建边之前还要删去一些不合法的边。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*Program from Luvwgyx*/#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)#define int long longusing namespace std;const int inf=1e18;const int maxn=1e5+10;const int maxm=3e5+10;priority_queue&lt;pi &gt;q;struct node&#123;int to,nxt,w;&#125;e[maxm&lt;&lt;1];int n,m,X,tot,a[maxn],h[maxn],head[maxn],dis[maxn],vis[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void add(int u,int v,int w)&#123;e[++tot].to=v;e[tot].w=w;e[tot].nxt=head[u];head[u]=tot;&#125;void dijkstra(int S)&#123; memset(vis,0,sizeof(vis)); memset(dis,63,sizeof(dis)); q.push(mp(0,S));dis[S]=0;h[S]=X; while(!q.empty())&#123; int x=q.top().sec;q.pop(); if(vis[x])continue;vis[x]=1;int H=h[x]; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to)&#123; if(H-e[i].w&gt;a[v])&#123; int val=dis[x]+H-a[v]; if(val&lt;dis[v])&#123; dis[v]=val;h[v]=a[v]; q.push(mp(-dis[v],v)); &#125;continue; &#125; if(H-e[i].w&lt;0)&#123; int val=dis[x]+e[i].w-(H-e[i].w); if(val&lt;dis[v])&#123; dis[v]=val;h[v]=0; q.push(mp(-dis[v],v)); &#125;continue; &#125; if(dis[x]+e[i].w&lt;dis[v])&#123; dis[v]=dis[x]+e[i].w; h[v]=H-e[i].w; q.push(mp(-dis[v],v)); &#125; &#125; &#125;&#125;signed main()&#123; n=read();m=read();X=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); for(int i=1;i&lt;=m;i++)&#123; int u=read(),v=read(),w=read(); if(w&lt;=a[u])add(u,v,w); if(w&lt;=a[v])add(v,u,w); &#125;dijkstra(1);write(dis[n]&gt;inf?-1:dis[n]+a[n]-h[n]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JOI 2013 Final]]></title>
    <url>%2F2019%2F10%2F31%2FJOI-2013-Final%2F</url>
    <content type="text"><![CDATA[比赛链接 LOJ 彩灯 解题思路 把连续的交替段处理出来，枚举每一段和旁边两段合并，取最大值。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142/*Program from Luvwgyx*/#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long long#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)#define sqr(x) ((x)*(x))using namespace std;const int maxn=1e5+10;pi q[maxn];int n,tot,a[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void write(pi x)&#123;printf("%lld %lld\n",x.fir,x.sec);&#125;int get(pi x)&#123;return x.sec-x.fir+1;&#125;signed main()&#123; n=read();int lst=1,ans=0; for(int i=1;i&lt;=n;i++)a[i]=read();a[0]=a[1];a[n+1]=a[n]; for(int i=2;i&lt;=n+1;i++)if(a[i]==a[i-1])q[++tot]=mp(lst,i-1),lst=i; //for(int i=1;i&lt;=tot;i++)write(q[i]); for(int i=1;i&lt;=tot;i++)&#123; int ret=get(q[i]); if(i!=1)ret+=get(q[i-1]); if(i!=tot)ret+=get(q[i+1]); ans=max(ans,ret); &#125;write(ans); return 0;&#125; 搭乘 IOI 火车 解题思路 设\(f_{i,j,0/1}\)表示第一行选了\(i\)个，第\(j\)行选了\(j\)个，现在是\(I\)或者\(O\)的最大值。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*Program from Luvwgyx*/#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long long#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)#define sqr(x) ((x)*(x))using namespace std;const int maxn=2e3+10;char s[maxn],t[maxn];int n,m,ans,f[maxn][maxn][2];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void Max(int &amp;x,int y)&#123;x=max(x,y);&#125;signed main()&#123; n=read();m=read();scanf("%s%s",s+1,t+1); //printf("%s\n%s\n",s+1,t+1); memset(f,-63,sizeof(f)); for(int i=1;i&lt;=n+1;i++) for(int j=1;j&lt;=m+1;j++)&#123; if(s[i-1]=='I'||t[j-1]=='I')f[i][j][0]=1; if(s[i-1]=='I')Max(f[i][j][0],f[i-1][j][1]+1); else Max(f[i][j][1],f[i-1][j][0]+1); if(t[j-1]=='I')Max(f[i][j][0],f[i][j-1][1]+1); else Max(f[i][j][1],f[i][j-1][0]+1); Max(ans,f[i][j][0]); &#125; write(ans); return 0;&#125; 现代豪宅 解题思路 同一行和同一列的开关之间建边，每个开关都拆点，分别对应行方向的和列方向的，然后行方向的向列方向的建一条代价为\(1\)的边。 这样就可以通过\(dijkstra\)求解答案了。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long long#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)#define sqr(x) ((x)*(x))using namespace std;const int inf=1e18;const int len=2e5+5;const int maxn=4e5+20;const int maxm=1e6+10;struct node&#123;int x,y;&#125;a[maxn];vector&lt;int &gt;dx[maxn],dy[maxn];priority_queue&lt;pi &gt;q;bool vis[maxn];struct edge&#123;int to,nxt,w;&#125;e[maxm&lt;&lt;1];int n,m,K,tot,cnt,b[maxn],head[maxn],dis[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void add(int u,int v,int w)&#123;e[++tot].to=v;e[tot].w=w;e[tot].nxt=head[u];head[u]=tot;&#125;void insert(int u,int v,int w)&#123;add(u,v,w);add(v,u,w);&#125;void dijkstra(int S)&#123; memset(vis,0,sizeof(vis)); memset(dis,63,sizeof(dis)); dis[S]=0;q.push(mp(0,S)); while(!q.empty())&#123; int x=q.top().sec;q.pop(); if(vis[x])continue;vis[x]=1; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(dis[x]+e[i].w&lt;dis[v])&#123; dis[v]=dis[x]+e[i].w; q.push(mp(-dis[v],v)); &#125; &#125;&#125;void dfs(int x)&#123; vis[x]=1;write(x); for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(!vis[v])dfs(v);&#125;bool cmp1(int x,int y)&#123;return a[x].y&lt;a[y].y;&#125;bool cmp2(int x,int y)&#123;return a[x].x&lt;a[y].x;&#125;signed main()&#123; n=read();m=read();K=read(); dx[1].push_back(++cnt); dx[n].push_back(200002); dy[m].push_back(200002+len); a[cnt]=(node)&#123;1,1&#125;; a[200002]=(node)&#123;n,m&#125;;a[200002+len]=a[200002]; for(int i=1;i&lt;=K;i++)&#123; int x=read(),y=read(); if(x==n&amp;&amp;y==m)continue; if(x==1&amp;&amp;y==1)dy[1].push_back(len+1),a[len+1]=a[1]; else &#123; dx[x].push_back(++cnt); dy[y].push_back(cnt+len); a[cnt]=(node)&#123;x,y&#125;;a[cnt+len]=a[cnt]; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; int now=(int)dx[i].size(); for(int j=0;j&lt;now;j++)b[j]=dx[i][j]; sort(b,b+now,cmp1);dx[i].clear(); for(int j=0;j&lt;now;j++)dx[i].push_back(b[j]); &#125; for(int i=1;i&lt;=m;i++)&#123; int now=(int)dy[i].size(); for(int j=0;j&lt;now;j++)b[j]=dy[i][j]; sort(b,b+now,cmp2);dy[i].clear(); for(int j=0;j&lt;now;j++)dy[i].push_back(b[j]); &#125; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;(int)dx[i].size();j++)&#123; if(j&gt;0)insert(dx[i][j-1],dx[i][j],a[dx[i][j]].y-a[dx[i][j-1]].y); insert(dx[i][j],dx[i][j]+len,1ll); &#125; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;(int)dy[i].size();j++)&#123; insert(dy[i][j-1],dy[i][j],a[dy[i][j]].x-a[dy[i][j-1]].x); &#125; dijkstra(1); if(dis[200002]&lt;inf||dis[200002+len]&lt;inf)write(min(dis[200002],dis[200002+len])); else puts("-1"); return 0;&#125; JOIOI 塔 解题思路 倒序，贪心，水题。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long long#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)#define sqr(x) ((x)*(x))using namespace std;const int maxn=1e6+10;char s[maxn];int n;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;bool check(int x)&#123; int ans=0,tot=0,cnt=0; for(int i=n;i&gt;=1;i--)&#123; if(s[i]=='J')if(tot)tot--,ans++; if(s[i]=='O')if(cnt)cnt--,tot++; if(s[i]=='I')&#123; if(ans+tot+cnt&lt;x)cnt++; else if(tot)tot--,ans++; &#125;if(ans&gt;=x)return 1; &#125;return 0;&#125;signed main()&#123; n=read();scanf("%s",s+1); int l=0,r=n,ans=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))l=mid+1,ans=mid; else r=mid-1; &#125;write(ans); return 0;&#125; 冒泡排序 解题思路 这题比较巧妙。 考虑将点写到一个二维坐标系上，横坐标是数的位置，纵坐标是数的权值，如下图： 很显然在不交换两个数的情况下，答案就是这些数中的逆序对数。 我们考虑交换两个数之后对答案的影响，如下图： 我们发现它使答案减少了 \((矩形中的点数 \times 2)+1\)。 考虑我们应该交换哪些数来求解答案，很显然对于要交换的\(i,j\)，首先得满足\(a_i&gt;a_j\)。 由于我们要使答案尽量小，因此我们要最大化交换两个数减少的逆序对数。那么很容易想到一种贪心，我们选择的矩形的两个端点，左端点的左上方不能有点，右端点的右下方不能有点，否则一定不优，那么我们可以预处理出来这样的点。 我们发现这两个集合中的点配对满足决策单调性，可以整体二分，然后用主席树计算点数，时间复杂度\(O(n \log^2n)\)。 PS：有看到别人用扫描线写的，时间复杂度少了个\(\log\)，但是我没想到。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int inf=1e9;const int maxn=1e5+10;int n,tot,cnt,mx,a[maxn],lst[maxn],pre[maxn],nxt[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;struct Binary_Index_Tree&#123; int tree[maxn]; void change(int x,int v)&#123;for(;x&lt;=n;x+=(x&amp;(-x)))tree[x]+=v;&#125; int query (int x)&#123;int ret=0;for(;x;x-=(x&amp;(-x)))ret+=tree[x];return ret;&#125;&#125;t;int root[maxn],tree[20*maxn],ls[20*maxn],rs[20*maxn];struct Chairman_Tree&#123; void change(int &amp;k,int pre,int l,int r,int x)&#123; k=++cnt;ls[k]=ls[pre];rs[k]=rs[pre]; tree[k]=tree[pre]+1;if(l==r)return ;int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)change(ls[k],ls[pre],l,mid,x); else change(rs[k],rs[pre],mid+1,r,x); &#125; int query(int k1,int k2,int l,int r,int x,int y)&#123; if(x&gt;y)return 0; if(x&lt;=l&amp;&amp;r&lt;=y)return tree[k1]-tree[k2]; int mid=(l+r)&gt;&gt;1,ret=0; if(x&lt;=mid)ret+=query(ls[k1],ls[k2],l,mid,x,y); if(mid&lt;y)ret+=query(rs[k1],rs[k2],mid+1,r,x,y); return ret; &#125;&#125;T;int get(int l,int r)&#123; int ret=0; if(a[l]&lt;a[r])ret++; else if(a[l]&gt;a[r])ret--; ret+=T.query(root[r-1],root[l],1,n,a[l]+1,n); ret+=T.query(root[r-1],root[l],1,n,1,a[r]-1); ret-=T.query(root[r-1],root[l],1,n,1,a[l]-1); ret-=T.query(root[r-1],root[l],1,n,a[r]+1,n); return -ret;&#125;void calc(int l,int r,int L,int R)&#123; if(l&gt;r)return ; int mid=(l+r)&gt;&gt;1,pos=0,ret=-inf; for(int i=L;i&lt;=R;i++)&#123; if(pre[mid]==nxt[i])continue; int tmp=get(pre[mid],nxt[i]); if(tmp&gt;=ret)ret=tmp,pos=i; &#125;mx=max(mx,ret); calc(l,mid-1,L,pos);calc(mid+1,r,pos,R);&#125;signed main()&#123; n=read();int ans=0; for(int i=1;i&lt;=n;i++)a[i]=read(),lst[++tot]=a[i]; sort(lst+1,lst+tot+1);tot=unique(lst+1,lst+tot+1)-lst-1; for(int i=1;i&lt;=n;i++)a[i]=lower_bound(lst+1,lst+tot+1,a[i])-lst; for(int i=n;i&gt;=1;i--)ans+=t.query(a[i]-1),t.change(a[i],1); pre[++pre[0]]=1;nxt[++nxt[0]]=n; for(int i=1;i&lt;=n;i++)if(a[i]&gt;a[pre[pre[0]]])pre[++pre[0]]=i; for(int i=n;i&gt;=1;i--)if(a[i]&lt;a[nxt[nxt[0]]])nxt[++nxt[0]]=i; for(int i=1;i&lt;=n;i++)T.change(root[i],root[i-1],1,n,a[i]);reverse(nxt+1,nxt+nxt[0]+1); mx=-inf;calc(1,pre[0],1,nxt[0]);ans-=mx;write(ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[LOJ#2783]「BalticOI 2016 Day2」城市]]></title>
    <url>%2F2019%2F10%2F21%2FLOJ-2783-%E3%80%8CBalticOI-2016-Day2%E3%80%8D%E5%9F%8E%E5%B8%82%2F</url>
    <content type="text"><![CDATA[题目链接 LOJ 解题思路 设\(f_{S,i}\)表示以\(i\)为根，\(K\)个关键点的联通状态为\(S\)的最小代价，转移如下： \[ f_{S,i}= \begin{cases} min(f_{T,i}+f_{S \text{^} T,i}) &amp; T \in S\\ min(f_{S,j}+val_{j,i}) &amp; 存在一条边(j,i)的权值为val_{j,i} \end{cases} \] 第一个转移可以枚举子集，第二个可以用\(dijkstra\)转移。 时间复杂度\(O(3^kn+2^km \log m)\)。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*Program from Luvwgyx*/#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll long long//#define int long long#define fir first#define sec second#define pi pair&lt;ll ,int &gt;#define mp(x,y) make_pair(x,y)#define sqr(x) ((x)*(x))using namespace std;const ll inf=1e18;const int maxn=1e5+10;const int maxm=2e5+10;priority_queue&lt;pi &gt;q;bool vis[maxn];struct node&#123;int to,nxt,w;&#125;e[maxm&lt;&lt;1];int n,K,m,tot,head[maxn];ll f[(1&lt;&lt;5)+10][maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void init()&#123;memset(f,63,sizeof(f));&#125;void Min(ll &amp;x,ll y)&#123;x=min(x,y);&#125;void add(int u,int v,int w)&#123;e[++tot].to=v;e[tot].w=w;e[tot].nxt=head[u];head[u]=tot;&#125;void insert(int u,int v,int w)&#123;add(u,v,w);add(v,u,w);&#125;void dijkstra(ll *dis)&#123; memset(vis,0,sizeof(vis)); while(!q.empty())&#123; int x=q.top().sec;q.pop(); if(vis[x])continue;vis[x]=1; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(dis[x]+e[i].w&lt;dis[v])dis[v]=dis[x]+e[i].w,q.push(mp(-dis[v],v)); &#125;&#125;signed main()&#123; n=read();K=read();m=read();init(); for(int i=1;i&lt;=K;i++)f[1&lt;&lt;(i-1)][read()]=0; for(int i=1;i&lt;=m;i++)&#123;int u=read(),v=read(),w=read();insert(u,v,w);&#125; for(int s=1;s&lt;(1&lt;&lt;K);s++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=s&amp;(s-1);j;j=s&amp;(j-1)) Min(f[s][i],f[s^j][i]+f[j][i]); if(f[s][i]&lt;inf)q.push(mp(-f[s][i],i)); &#125;dijkstra(f[s]); &#125;ll ans=inf; for(int i=1;i&lt;=n;i++)Min(ans,f[(1&lt;&lt;K)-1][i]); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>斯坦纳树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #592 (Div. 2)]]></title>
    <url>%2F2019%2F10%2F14%2FCodeforces-Round-592-Div-2%2F</url>
    <content type="text"><![CDATA[比赛链接 Codeforces Round #592 (Div. 2) A. Pens and Pencils 题目大意 要参加\(a\)场讲座，\(b\)堂实践课，讲座要用铅笔，实践课要用钢笔。 一支铅笔可以记录\(c\)场讲座，一支钢笔可以记录\(d\)堂实践课，文具盒能容纳\(k\)支笔，问能否装下需要用到的笔，如果能装下请给出两种笔的数量。 解题思路 暴力。 参考代码 123456789101112131415161718192021222324252627282930/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int T=read(); while(T--)&#123; int a=read(),b=read(),c=read(),d=read(),k=read(); int cnt1=0,cnt2=0; while(cnt1*c&lt;a)cnt1++; while(cnt2*d&lt;b)cnt2++; if(cnt1+cnt2&gt;k)puts("-1"); else printf("%lld %lld\n",cnt1,cnt2); &#125; return 0;&#125; B. Rooms and Staircases 题目大意 两层楼，每层楼都有\(n\)个房间，两层楼之间有些地方有楼梯，你可以随意选择一个地方出发，问在每个房间只能经过一次的前提下最多能经过多少个房间。 解题思路 很显然，有楼梯就能走两倍这个楼梯到两边的房间数的最大值，枚举取最大值就好了。 参考代码 123456789101112131415161718192021222324252627282930313233/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e3+10;char s[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int T=read(); while(T--)&#123; int n=read();scanf("%s",s+1);int ans=n; for(int i=1;i&lt;=n;i++) if(s[i]=='1')&#123; int tmp=max(i,n-i+1); ans=max(ans,tmp&lt;&lt;1); &#125; write(ans); &#125; return 0;&#125; C. The Football Season 题目大意 给定\(n,p,w,d\)，求 \[ x \cdot w + y \cdot d =p\\ x+y\leqslant n \] 保证\(d&lt;w\)。 解题思路 题目保证了\(d&lt;w\)，那么有\(y&lt;d\)，因为如果\(y=d\)，那么相当于\(w \times d\)，然后取了\(d\)个\(w\)，那么不如取\(w\)个\(d\)更优，所以直接暴力即可。 参考代码 1234567891011121314151617181920212223242526272829303132333435/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int n=read(),p=read(),w=read(),d=read(); int gcd=__gcd(w,d); if(p%gcd)&#123;puts("-1");return 0;&#125; p/=gcd;w/=gcd;d/=gcd; //printf("%lld %lld %lld\n",p,w,d); int ans1=0;bool flag=0; while(ans1&lt;=n)&#123; if(w*ans1&gt;p)&#123;flag=1;break;&#125; if(!((p-w*ans1)%d))break; ans1++; &#125;//write(ans1); if(flag)&#123;puts("-1");return 0;&#125; int ans2=(p-w*ans1)/d; if(d&lt;w)&#123;int tmp=ans2/w;ans1+=d*tmp;ans2-=w*tmp;&#125; if(ans1+ans2&gt;n)&#123;puts("-1");return 0;&#125; printf("%lld %lld %lld\n",ans1,ans2,n-ans1-ans2); return 0;&#125; D. Paint the Tree 题目大意 给定一棵树，给树上结点染色，总共有三种颜色，给出一种染色方案，满足树上任意长度为\(3\)的路径上的点颜色都不相同，且染色代价最小。 解题思路 这题考场上没仔细想，直接上\(dp\)，写完了之后，发现不对劲，然后仔细一看，发现只有树的形态是链的时候才有解，结果耽误了时间，不然F和G都有机会A掉... 既然发现只有链有解，那么我们找到度数为\(1\)的点，将链拎出来，然后给前三个点标记好颜色，后面的点可以推出来。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*Program from Luvwgyx*/#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int inf=1e18;const int maxn=1e5+10;struct edge&#123;int to,nxt;&#125;e[maxn&lt;&lt;1];int n,tot,cnt,id[3],ansid[3],head[maxn],deg[maxn],lst[maxn],ans[maxn],c[3][maxn],f[maxn][3][3];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void add(int u,int v)&#123;e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;deg[v]++;&#125;void insert(int u,int v)&#123;add(u,v);add(v,u);&#125;void dfs(int x,int fa)&#123; lst[++cnt]=x; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(v!=fa)dfs(v,x);&#125;signed main()&#123; n=read();int root=0; for(int i=0;i&lt;3;i++)for(int j=1;j&lt;=n;j++)c[i][j]=read(); for(int i=1;i&lt;n;i++)insert(read(),read()); for(int i=1;i&lt;=n;i++)if(deg[i]&gt;2)&#123;puts("-1");return 0;&#125; for(int i=1;i&lt;=n;i++)if(deg[i]==1)&#123;root=i;break;&#125; dfs(root,0);int Ans=inf; for(int i=0;i&lt;3;i++)id[i]=i; do&#123; int ret=0; for(int i=1;i&lt;=n;i++)ret+=c[id[i%3]][lst[i]]; if(ret&lt;Ans)&#123;Ans=ret;for(int i=0;i&lt;3;i++)ansid[i]=id[i];&#125; &#125;while(next_permutation(id,id+3)); write(Ans); for(int i=1;i&lt;=n;i++)ans[lst[i]]=ansid[i%3]; for(int i=1;i&lt;=n;i++)printf("%lld ",ans[i]+1);puts(""); return 0;&#125; E. Minimizing Difference 题目大意 给定一个长度为\(n\)的序列，你能进行\(k\)次操作，每次操作可以将一个数增加或者减少\(1\)，问\(k\)次操作之后最大值和最小值的差最小是多少。 解题思路 很显然的一个贪心。 将序列排好序之后判断是左边相同的数字多还是右边相同的数字多，取小的那个，如果是左边就加\(1\)，右边就减\(1\)。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041/*Program from Luvwgyx*/#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int inf=1e18;const int maxn=1e5+10;int n,K,a[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; n=read();K=read();bool flag=0; for(int i=1;i&lt;=n;i++)a[i]=read(); sort(a+1,a+n+1);int l=1,r=n,lsize=1,rsize=1; while(l&lt;r)&#123; if(lsize&lt;rsize)&#123; int tmp=a[l+1]-a[l]; if(tmp*lsize&lt;=K)&#123;K-=tmp*lsize;l++;lsize++;&#125; else&#123;flag=1;break;&#125; &#125;else&#123; int tmp=a[r]-a[r-1]; if(tmp*rsize&lt;=K)&#123;K-=tmp*rsize;r--;rsize++;&#125; else&#123;flag=1;break;&#125; &#125; &#125;int now=K/lsize; if(!flag)puts("0");else write(a[r]-a[l]-now); return 0;&#125; F. Chips 题目大意 给定一个长度为\(n\)的环，每个点有颜色，要么是黑要么是白。现在会进行\(k\)轮转化颜色的操作，每次将所有与两边点颜色不同的点的颜色反转，问最后每个结点的颜色。 解题思路 我们可以发现，一旦一个点在某一轮不需要反转颜色，那么它在之后也不会需要反转颜色。那么我们只需要\(bfs\)求出每个点在哪一轮不需要反转就好了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=2e5+10;char s[maxn];int vis[maxn];queue&lt;int &gt;q;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void init()&#123;memset(vis,-1,sizeof(vis));&#125;int main()&#123; int n=read(),K=read();scanf("%s",s+1);init(); for(int i=1;i&lt;=n;i++)&#123; int pre=(i==1)?n:i-1,nxt=(i==n)?1:i+1; if(!(s[pre]!=s[i]&amp;&amp;s[i]!=s[nxt]))q.push(i),vis[i]=0; &#125; while(!q.empty())&#123; int x=q.front();q.pop(); int pre=(x==1)?n:x-1,nxt=(x==n)?1:x+1; if(vis[pre]==-1)vis[pre]=vis[x]+1,q.push(pre); if(vis[nxt]==-1)vis[nxt]=vis[x]+1,q.push(nxt); &#125; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]==-1||vis[i]&gt;K)&#123; if(K&amp;1)putchar(s[i]=='B'?'W':'B'); else putchar(s[i]); &#125;else &#123; if(vis[i]&amp;1)putchar(s[i]=='B'?'W':'B'); else putchar(s[i]); &#125; &#125;puts(""); return 0;&#125; G. Running in Pairs 题目大意 给定\(n\)和\(k\)，构造两个排列\(p\)和\(q\)满足\(sum=\sum \limits_{i=1}^nmax(p_i,q_i) \leqslant k\)。 解题思路 很显然，\(sum\)最小的情况就是两个排列每个位置都是相同的数，据此我们就可以判掉无解情况了。 我们假设\(p\)和\(q\)初始都是顺序排列，考虑改变\(q\)中数值的位置改变产生的贡献，很显然一个位置前进多少位就能产生多少贡献，那么我们就可以贪心构造了。 参考代码 123456789101112131415161718192021222324252627282930313233343536/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e6+10;int a[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int n=read(),K=read(),sum=0; sum=n*(n+1)/2;if(sum&gt;K)&#123;puts("-1");return 0;&#125; int ret=K-sum,now=1; for(int i=1;i&lt;=n;i++)a[i]=i; for(int i=n;i&gt;=1&amp;&amp;i&gt;now;i--)&#123; if(i-now&lt;=ret)&#123;ret-=i-now;swap(a[i],a[now]);now++;&#125; else &#123;swap(a[i],a[i-ret]);ret=0;break;&#125; &#125;write(K-ret); for(int i=1;i&lt;=n;i++)printf("%lld ",i);puts(""); for(int i=1;i&lt;=n;i++)printf("%lld ",a[i]);puts(""); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[AT2671]Sports Festival]]></title>
    <url>%2F2019%2F10%2F08%2FAT2671-Sports-Festival%2F</url>
    <content type="text"><![CDATA[题目链接 AtCoder 题意简述 Takahashi举办了一场运动会，这场运动会有\(M\)个项目，有\(N\)个人来参加。 给你一个\(N \times M\)的二维数组\(a\)，其中\(a_{i,j}\)表示第\(i\)个人，她心目中排名第\(j\)的项目是哪个。 这\(M\)个项目不一定全都要进行，可以选其中一些项目进行，剩下的都鸽掉，当然肯定不能鸽掉所有\(M\)个项目。 每个人会在所有开展的项目当中，选择她心目中排名最高的那个项目参加。 因此，如果开展全部项目的话，可能某个项目的人数会爆多无比，所以Takahashi决定，只开展其中的一部分项目，使得参加人数最多的那个项目，参加人数尽量少。 请输出这个值。 解题思路 考虑每次删掉一个活动后，将所有活动往前补全，每次对于第一列统计每个活动出现次数，将出现次数最多的删去，统计答案即可。 删去过程可以用链表实现，时间复杂度\(O(nm)\)。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243/*Program from Luvwgyx*/#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long long#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)using namespace std;const int inf=1e18;const int maxn=3e2+10;int n,m,ans,pos[maxn],cnt[maxn],vis[maxn],a[maxn][maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; n=read();m=read();ans=inf; for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)a[i][j]=read(); for(int i=1;i&lt;=n;i++)pos[i]=1; while(1)&#123; int mx=0,now=0; for(int i=1;i&lt;=n;i++)&#123; cnt[a[i][pos[i]]]++; if(cnt[a[i][pos[i]]]&gt;mx)mx=cnt[a[i][pos[i]]],now=a[i][pos[i]]; &#125;ans=min(ans,mx);vis[now]=1;bool flag=0;//write(mx); for(int i=1;i&lt;=n;i++)while(vis[a[i][pos[i]]])pos[i]++; for(int i=1;i&lt;=n;i++)if(pos[i]&lt;=m)&#123;flag=1;break;&#125; if(!flag)break;memset(cnt,0,sizeof(cnt)); &#125;write(ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #572 (Div. 2)]]></title>
    <url>%2F2019%2F10%2F07%2FCodeforces-Round-572-Div-2%2F</url>
    <content type="text"><![CDATA[比赛链接 Codeforces Round #572 (Div. 2) A. Keanu Reeves 题目大意 对于一个\(01\)字符串，当它中间\(0\)的数量和\(1\)的数量不同时，称它为一个好的序列，否则称它为一个不好的序列。 给出一个长度为\(n\)的\(01\)字符串，将它划分为几个字符串，使划分出的几个字符串都是好的序列。 求最少划分出几个字符串，并任意输出一种方案。 解题思路 很显然，答案要么是\(1\)要么是\(2\)。 考虑为\(2\)的情况，我们只需要找到一个分界点满足前面一段的\(0\)的数量和\(1\)的数量不同且后面一段的\(0\)和\(1\)的数量也不同就行了。 那么我们记\(pre_{0/1,i}\)和\(nxt_{0/1,i}\)分别表示\(i\)这个位置之前和之后的\(01\)数量，预处理出来后直接枚举一边就行了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e2+10;char s[maxn];int pre[2][maxn],nxt[2][maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int n=read(),pos;scanf("%s",s+1); for(int i=1;i&lt;=n;i++)&#123; int opt=(s[i]=='1'); pre[opt][i]++; pre[opt][i]+=pre[opt][i-1]; pre[opt^1][i]+=pre[opt^1][i-1]; &#125; for(int i=n;i&gt;=1;i--)&#123; int opt=(s[i]=='1'); nxt[opt][i]++; nxt[opt][i]+=nxt[opt][i+1]; nxt[opt^1][i]+=nxt[opt^1][i+1]; &#125;if(pre[0][n]!=pre[1][n])&#123;puts("1");printf("%s\n",s+1);return 0;&#125; puts("2"); for(int i=1;i&lt;n;i++) if(pre[0][i]!=pre[1][i]&amp;&amp;nxt[0][i+1]!=nxt[1][i+1])&#123;pos=i;break;&#125; for(int i=1;i&lt;=n;i++)&#123;putchar(s[i]);if(i==pos)putchar(' ');&#125;puts(""); return 0;&#125; B. Number Circle 题目大意 给定\(n\)个数，要将它们填入一个环内，满足每个位置上的值都严格小于它两边的数的和，问能否满足条件，若可以则还需输出方案。 解题思路 很显然，从小到大排序，若最大值不严格小于比他小的两个数之和则无解，否则即有一种可行方案如下： 设\(x、y、z\)分别为最大的三个值，且\(x&gt;y&gt;z\)，则\(a_1=y,a_2=x,a_3=z\)，然后再将剩下的数从大到小依次填入即可。 参考代码 1234567891011121314151617181920212223242526272829/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e5+10;int n,tot,a[maxn],ans[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); sort(a+1,a+n+1); if(a[n]&gt;=a[n-2]+a[n-1])&#123;puts("NO");return 0;&#125; printf("YES\n%lld %lld %lld",a[n-1],a[n],a[n-2]); for(int i=n-3;i;i--)printf(" %lld",a[i]);puts(""); return 0;&#125; C. Candies! 题目大意 不想翻译了。 解题思路 很显然，顺序毫无影响，那么我们只需要预处理前缀和，就可以\(O(1)\)回答询问了。 参考代码 123456789101112131415161718192021222324252627282930/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e5+10;int n,q,a[maxn],sum[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read(),sum[i]=sum[i-1]+a[i]; q=read(); while(q--)&#123; int l=read(),r=read(),ret=sum[r]-sum[l-1]; write(ret/10); &#125; return 0;&#125; D1. Add on a Tree 题目大意 给定一棵树，树上的边权初始为\(0\)，你可以在任意两个叶子之间的简单路径上的边上加上一个权值实数\(x\)。问：能否在有限次数的操作内，得到边权任意组合的树。 解题思路 很显然只有当存在某一个点度数为\(2\)的时候无解，否则一定有解。 参考代码 123456789101112131415161718192021222324252627/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e5+10;int n,deg[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; n=read();bool flag=0; for(int i=2;i&lt;=n;i++)deg[read()]++,deg[read()]++; for(int i=1;i&lt;=n;i++)if(deg[i]==2)&#123;puts("NO");flag=1;break;&#125; if(!flag)puts("YES"); return 0;&#125; D2. Add on a Tree: Revolution 题目大意 给定一棵树，树上的每条边都有边权，保证边权全为偶数。现在你每次可以选择两个叶子结点，将它们的路径上的点都加上一个权值，权值可正可负，问能否在\(10^5\)操作内将树变为与给定树一致。 解题思路 我们将每条边拎出来单独考虑，设当前边为\((u,v,w)\)，发现只有以下几种情况： \(u\)和\(v\)同为叶子结点，那么直接加上\(w\)就好了。 \(u\)为叶子结点，\(v\)不是，那么我们在以\(v\)为根的树内，以除\(u\)以外的儿子结点为根的子树内找到两个叶子结点\(x\)和\(y\)，那么给路径\(u \to x\)加上\(\frac{w}{2}\)，\(u \to y\)加上\(\frac{w}{2}\)，\(x \to y\)加上\(- \frac{w}{2}\)。 \(u\)和\(v\)都不为叶子结点，那么我们分别在以\(v\)为根的树内，以除\(u\)以外的儿子结点为根的子树内找到两个叶子结点\(x_1\)和\(y_1\)，以\(u\)为根的树内，以除\(v\)以外的儿子结点为根的子树内找到两个叶子结点\(x_2\)和\(y_2\)。那么给\(x_1 \to x_2\)加上\(\frac{w}{2}\)，\(y_1 \to y_2\)加上\(\frac{w}{2}\)，\(x_1 \to y_1\)加上\(-\frac{w}{2}\)，\(x_2 \to y_2\)加上\(-\frac{w}{2}\)。 有一点点小细节自己考虑吧。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e3+10;struct node&#123;int u,v,w;&#125;a[maxn];struct edge&#123;int to,nxt;&#125;e[maxn&lt;&lt;1];int n,tot,cnt,top,head[maxn],deg[maxn],f[maxn],sta[maxn],ans[maxn][maxn];bool flag=0;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void add(int u,int v)&#123;e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;deg[v]++;&#125;void insert(int u,int v)&#123;add(u,v);add(v,u);&#125;int dfs(int id,int x,int fa,int ed)&#123; sta[++top]=x; if(deg[x]==1&amp;&amp;!f[x]&amp;&amp;!flag&amp;&amp;(fa==id||!f[fa]))&#123; int now=top; while(now)f[sta[now--]]=1; f[x]=1;flag=1;return x; &#125; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(v!=fa&amp;&amp;v!=ed&amp;&amp;!f[v])return dfs(id,v,x,ed); top--;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;n;i++)a[i]=(node)&#123;read(),read(),read()&#125;; for(int i=1;i&lt;n;i++)insert(a[i].u,a[i].v); for(int i=1;i&lt;=n;i++)if(deg[i]==2)&#123;puts("NO");return 0;&#125; for(int i=1;i&lt;n;i++)&#123; int u=a[i].u,v=a[i].v,w=a[i].w; int flag1=(deg[u]==1),flag2=(deg[v]==1); if(flag1&amp;&amp;flag2)ans[u][v]+=w,ans[v][u]+=w; if(flag1&amp;&amp;!flag2)&#123; int x=dfs(v,v,0,u);flag=0;top=0; int y=dfs(v,v,0,u);flag=0;top=0; ans[u][x]+=w/2; ans[u][y]+=w/2; ans[x][y]+=-w/2; ans[x][u]+=w/2; ans[y][u]+=w/2; ans[y][x]+=-w/2; memset(f,0,sizeof(f)); &#125; if(!flag1&amp;&amp;flag2)&#123; int x=dfs(u,u,0,v);flag=0;top=0; int y=dfs(u,u,0,v);flag=0;top=0; ans[v][x]+=w/2; ans[v][y]+=w/2; ans[x][y]+=-w/2; ans[x][v]+=w/2; ans[y][v]+=w/2; ans[y][x]+=-w/2; memset(f,0,sizeof(f)); &#125; if(!flag1&amp;&amp;!flag2)&#123; int x1=dfs(u,u,0,v);flag=0;top=0; int y1=dfs(u,u,0,v);flag=0;top=0; int x2=dfs(v,v,0,u);flag=0;top=0; int y2=dfs(v,v,0,u);flag=0;top=0; ans[x1][x2]+=w/2; ans[y1][y2]+=w/2; ans[x1][y1]+=-w/2; ans[x2][y2]+=-w/2; ans[x2][x1]+=w/2; ans[y2][y1]+=w/2; ans[y1][x1]+=-w/2; ans[y2][x2]+=-w/2; memset(f,0,sizeof(f)); &#125; &#125;puts("YES"); for(int i=1;i&lt;=n;i++)for(int j=i+1;j&lt;=n;j++)if(ans[i][j])cnt++; write(cnt); for(int i=1;i&lt;=n;i++)for(int j=i+1;j&lt;=n;j++)if(ans[i][j])printf("%lld %lld %lld\n",i,j,ans[i][j]); return 0;&#125; E. Count Pairs 题目大意 给定一个质数\(p\)，一个长度为\(n\)的序列\(a_1,a_2, \cdots , a_n\)和一个整数\(k\)。 求所有数对\((i,j)(1 \leqslant i,j \leqslant n)\)中满足\((a_i+a_j)(a_i^2+a_j^2) \equiv k\mod p\)的个数。 解题思路 我们先将式子化一下： \[ (a_i^2-a_j^2)(a_i^2+a_j^2) \equiv k(a_i-a_j)\mod p\\ a_i^4-a_j^4 \equiv ka_i - ka_j \mod p\\ a_i^4-ka_i \equiv a_j^4-ka_j \mod p \] 由于\(k\)确定，所以我们将\(a_i^4-ka_i\)取模后丢进\(map\)里，然后就可以统计有多少个数和它相同了。 参考代码 1234567891011121314151617181920212223242526/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long long #define write(x) printf("%lld\n",x)using namespace std;const int maxn=3e5+10;map&lt;int ,int &gt;mp;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;signed main()&#123; int n=read(),p=read(),k=read(),ans=0; for(int i=1;i&lt;=n;i++)&#123; int x=read(); int ret=((((((x*x)%p*x)%p*x)%p-k*x)%p)%p+p)%p; if(mp.count(ret))ans+=mp[ret];++mp[ret]; &#125;write(ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #585 (Div. 2)]]></title>
    <url>%2F2019%2F10%2F05%2FCodeforces-Round-585-Div-2%2F</url>
    <content type="text"><![CDATA[比赛链接 Codeforces Round #585 (Div. 2) A. Yellow Cards 题目大意 足球比赛中，裁判一共出示了\(n\)张黄牌，比赛球队中分别有\(a_1\)和\(a_2\)个球员。第一队的每一个球员在收到\(k_1\)张黄牌之后下场，第二队则是\(k_2\)张。即使某一队的球员全被罚下场了比赛仍能继续。 问这\(n\)张牌能罚下场的人数的最大值和最小值。 解题思路 比较大小判判判。 参考代码 123456789101112131415161718192021222324252627/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int a1=read(),a2=read(),k1=read(),k2=read(),n=read(),ans1=0,ans2=0; if(k1&gt;k2)swap(k1,k2),swap(a1,a2); int cnt=a1*(k1-1)+a2*(k2-1);ans1=max(0ll,n-cnt); printf("%lld ",ans1); ans2+=min(a1,n/k1);n-=k1*min(a1,n/k1); ans2+=min(a2,n/k2);write(ans2); return 0;&#125; B. The Number of Products 题目大意 给定长度为\(n\)的整数序列，问满足区间内所有数相乘为正数的区间个数和为负数的区间个数。 解题思路 统计正数个数和负数个数计算一下。 参考代码 12345678910111213141516171819202122232425262728293031/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=2e5+10;int n,a[maxn],f[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=(read()&gt;0?1:-1); a[0]=1;for(int i=1;i&lt;=n;i++)a[i]*=a[i-1]; int cnt1=0,cnt2=0;f[1]=1; for(int i=1;i&lt;=n;i++)&#123; int opt=(a[i]&gt;0);f[opt]++; cnt1+=f[opt^1];cnt2+=f[opt]; &#125;printf("%lld %lld\n",cnt1,cnt2-n); return 0;&#125; C. Swap Letters 题目大意 给定两个串\(S\)和\(T\)，都是只由\(a\)和\(b\)构成的字符串。 现在每次可以选择两个位置\(pos_1\)和\(pos_2\)，然后将\(S_{pos_1}\)和\(T_{pos_2}\)交换，问最少需要几次操作可以将\(S\)和\(T\)变为完全相同的串。 解题思路 显然一次操作最优的情况肯定是\(\frac{...a...a...}{...b...b...}\)或者\(\frac{...b...b...}{...a...a...}\)，那么我们只需要一次交换就可以将两组变为相同的串。 我们考虑无解的情况，很显然若\(a\)或者\(b\)的数量为奇数，那么就无解。 那么我们统计所有上下不相同的位置，将\(\frac{a}{b}\)这种形式的位置扔进\(v_1\)，\(\frac{b}{a}\)扔进\(v_2\)，那么只需要在相同的组内两两配对即可。 考虑单出来的情况，在判掉无解的基础上，如果两个组内有单个出来，那么一定是两组都单了一个。 那么这种情况我们需要两次操作，我们在序列上随机一个位置\(pos\)出来，然后看它是\(a\)还是\(b\)，分别对应和其中一组交换，然后就转化成了同组问题。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*Program from Luvwgyx*/#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long long#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)using namespace std;const int maxn=2e5+10;char s1[maxn],s2[maxn];int n,cnt,tot1,tot2,v1[maxn],v2[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);putchar('\n');&#125;signed main()&#123; n=read();scanf("%s%s",s1+1,s2+1); for(int i=1;i&lt;=n;i++)cnt+=(s1[i]=='a'),cnt+=(s2[i]=='a'); if(cnt&amp;1)&#123;puts("-1");return 0;&#125; for(int i=1;i&lt;=n;i++) if(s1[i]!=s2[i])&#123; if(s1[i]=='a')v1[++tot1]=i; else v2[++tot2]=i; &#125; if((tot1&amp;1)&amp;&amp;(tot2&amp;1)&amp;&amp;n&lt;=2)&#123;printf("2\n%lld %lld\n%lld %lld\n",v1[tot1],v1[tot1],v1[tot1],v2[tot2]);return 0;&#125; int ans=tot1/2+tot2/2,now=0;if((tot1&amp;1)&amp;&amp;(tot2&amp;1))ans+=2;write(ans); for(int i=1;i+1&lt;=tot1;i+=2)printf("%lld %lld\n",v1[i],v1[i+1]),swap(s1[v1[i]],s2[v1[i]]),now++; for(int i=1;i+1&lt;=tot2;i+=2)printf("%lld %lld\n",v2[i],v2[i+1]),swap(s1[v2[i]],s2[v2[i]]),now++; if(now==ans)return 0;int pos=rand()%n+1; while(pos==v1[tot1]||pos==v2[tot2])pos=rand()%n+1; if(s1[pos]=='a')printf("%lld %lld\n%lld %lld\n",pos,v1[tot1],pos,v2[tot2]); else printf("%lld %lld\n%lld %lld\n",pos,v2[tot2],pos,v1[tot1]); return 0;&#125; D. Ticket Game 题目大意 懒得翻译了。 解题思路 很显然，我们只需要考虑左右两边的放法即可，而不用关心具体放在哪一个位置。 那么我们统计左右两边的原有的数的和，以及问号。 很显然，问号会左右抵消，且剩下的问号两边最优策略情况下单边的数和只会增加\(9\)，所以只需要判断单边抵消后剩下的问号数的一半\(\times 9\)是否等于左右原有的数的和的差即可。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940/*Program from Luvwgyx*/#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long long#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)using namespace std;const int maxn=2e5+10;char s[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);putchar('\n');&#125;signed main()&#123; int n=read(),cnt1=0,cnt2=0,sum1=0,sum2=0;scanf("%s",s+1); for(int i=1;i&lt;=n/2;i++)&#123;if(s[i]=='?')cnt1++;else sum1+=s[i]-'0';&#125; for(int i=n/2+1;i&lt;=n;i++)&#123;if(s[i]=='?')cnt2++;else sum2+=s[i]-'0';&#125; if(sum1==sum2)puts(cnt1==cnt2?"Bicarp":"Monocarp"); if(sum1&gt;sum2)&#123; int ret=sum1-sum2,now=(cnt2-cnt1)/2; puts(9*now==ret?"Bicarp":"Monocarp"); &#125; if(sum1&lt;sum2)&#123; int ret=sum2-sum1,now=(cnt1-cnt2)/2; puts(9*now==ret?"Bicarp":"Monocarp"); &#125; return 0;&#125; E. Marbles 题目大意 给定\(n\)个珠子，每个珠子有一个颜色，每次可以将相邻的珠子交换位置，问最少要多少次操作才能使颜色相同的珠子都在连续的位置上。 解题思路 我们很容易能联想到冒泡排序，但是注意到冒泡排序是将编号从小到大，那么我们将颜色的优先级重定义一下，便将原问题转化为在所有的颜色优先级方案中逆序对数最小的方案的逆序对数是多少。 那么我们设\(f_S\)表示当前已经标记了优先级的颜色状态为\(S\)的最小逆序对数，这个问题就解决了。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*Program from Luvwgyx*/#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long long#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)using namespace std;const int maxm=30;const int maxn=4e5+10;int n,a[maxn],cnt[maxm],f[(1&lt;&lt;20)+10],b[maxm][maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);putchar('\n');&#125;void Min(int &amp;a,int b)&#123;a=min(a,b);&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; a[i]=read(); for(int j=1;j&lt;=20;j++)b[j][a[i]]+=cnt[j]; cnt[a[i]]++; &#125;memset(f,63,sizeof(f));f[0]=0; for(int s=0;s&lt;(1&lt;&lt;20);s++) for(int i=1;i&lt;=20;i++)&#123; if((s&gt;&gt;(i-1))&amp;1)continue; int ret=0; for(int j=1;j&lt;=20;j++)if((s&gt;&gt;(j-1))&amp;1)ret+=b[j][i]; Min(f[s|(1&lt;&lt;(i-1))],f[s]+ret); &#125; write(f[(1&lt;&lt;20)-1]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[LOJ2063]「HAOI2016」字符合并]]></title>
    <url>%2F2019%2F10%2F05%2FLOJ2063-%E3%80%8CHAOI2016%E3%80%8D%E5%AD%97%E7%AC%A6%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[题目链接 LOJ 解题思路 设\(f_{i,j,S}\)表示区间\([i,j]\)之间的字符合并后状态为\(S\)的最大分数，其中\(S\)是一个长度为\((j-i) \mod (k-1)+1\)的\(01\)串，很显然，由于每次合并后都会减少\(k-1\)个字符，所以\(S\)的长度始终在\(2^8\)以内。 我们枚举分界点\(mid\)，表示\(S\)的最后一个字符是由原串中区间\((mid,r]\)内的\(01\)串压缩而成，然后就可以转移了。 令\(mg(S,x)\)表示\(S&lt;&lt;1|x\)，其中\(x \in \{0,1\}\)。 \[ f_{i,j,mg(S,x)}=\max \{f_{i,mid,S}+f_{mid+1,j,x}\} \] 特别地，若\(|S|=(r-l)\mod (k-1)+1=k-1\)，则枚举分界点合并后还可再次合并，因此 \[ f_{i,j,c_{mg(S,x)}}=\max\{f_{i,mid,S}+f_{mid+1,r,x}+w_{mg(S,x)}\} \] 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=3e2+10;const int maxm=(1&lt;&lt;8)+10;char s[maxn];int n,K,a[maxn],c[maxm],w[maxm],f[maxn][maxn][maxm];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);putchar('\n');&#125;void Max(int &amp;a,int b)&#123;a=max(a,b);&#125;signed main()&#123; n=read();K=read();scanf("%s",s+1); for(int i=1;i&lt;=n;i++)a[i]=s[i]-'0'; for(int i=0;i&lt;(1&lt;&lt;K);i++)c[i]=read(),w[i]=read(); memset(f,-1,sizeof(f)); for(int i=1;i&lt;=n;i++)f[i][i][a[i]]=0; for(int i=n;i&gt;=1;i--) for(int j=i+1;j&lt;=n;j++)&#123; int now=(j-i)%(K-1)+1; if(now&gt;1)&#123; for(int k=i+now-2;k&lt;j;k+=K-1) for(int s=0;s&lt;(1&lt;&lt;now-1);s++)&#123; if(f[i][k][s]==-1)continue; if(f[k+1][j][0]!=-1)Max(f[i][j][s&lt;&lt;1],f[i][k][s]+f[k+1][j][0]); if(f[k+1][j][1]!=-1)Max(f[i][j][s&lt;&lt;1|1],f[i][k][s]+f[k+1][j][1]); &#125; &#125;else &#123; for(int s=0;s&lt;(1&lt;&lt;K);s++) for(int k=i+K-2;k&lt;j;k+=K-1)&#123; if(f[i][k][s]==-1)continue; if(f[k+1][j][0]!=-1)Max(f[i][j][c[s&lt;&lt;1]],f[i][k][s]+f[k+1][j][0]+w[s&lt;&lt;1]); if(f[k+1][j][1]!=-1)Max(f[i][j][c[s&lt;&lt;1|1]],f[i][k][s]+f[k+1][j][1]+w[s&lt;&lt;1|1]); &#125; &#125; &#125; int ans=0; for(int i=0;i&lt;(1&lt;&lt;K);i++)Max(ans,f[1][n][i]); write(ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ4897][THUSC 2016]成绩单]]></title>
    <url>%2F2019%2F10%2F04%2FBZOJ4897-THUSC-2016-%E6%88%90%E7%BB%A9%E5%8D%95%2F</url>
    <content type="text"><![CDATA[题目链接 LOJ 解题思路 设\(f_{x,y,l,r}\)表示在区间\([x,y]\)内选了一些数后剩下的数的值域为\([l,r]\)的最小代价，转移比较显然。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long long#define sqr(x) ((x)*(x))using namespace std;const int maxn=60;const int inf=1e9;bool vis[maxn][maxn][maxn][maxn];int n,A,B,tot,a[maxn],lst[maxn],f[maxn][maxn][maxn][maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);putchar('\n');&#125;void Min(int &amp;x,int y)&#123;x=min(x,y);&#125;int dfs(int x,int y,int l,int r)&#123; if(vis[x][y][l][r])return f[x][y][l][r]; vis[x][y][l][r]=1;f[x][y][l][r]=inf; if(!l&amp;&amp;!r)&#123; int mn=inf,mx=-inf; for(int i=x;i&lt;=y;i++)&#123; mn=min(mn,lst[a[i]]); mx=max(mx,lst[a[i]]); &#125;f[x][y][0][0]=A+B*sqr(mx-mn); for(int i=1;i&lt;=tot;i++) for(int j=i;j&lt;=tot;j++) Min(f[x][y][0][0],dfs(x,y,i,j)+(A+B*sqr(lst[j]-lst[i]))); return f[x][y][0][0]; &#125; if(x==y)&#123; if(l&lt;=a[x]&amp;&amp;a[x]&lt;=r)f[x][y][l][r]=0; return f[x][y][l][r]; &#125; for(int k=x;k&lt;y;k++)&#123; Min(f[x][y][l][r],dfs(x,k,l,r)+dfs(k+1,y,l,r)); Min(f[x][y][l][r],dfs(x,k,l,r)+dfs(k+1,y,0,0)); Min(f[x][y][l][r],dfs(x,k,0,0)+dfs(k+1,y,l,r)); &#125;return f[x][y][l][r];&#125;signed main()&#123; n=read();A=read();B=read(); for(int i=1;i&lt;=n;i++)a[i]=lst[i]=read(); sort(lst+1,lst+n+1);tot=unique(lst+1,lst+n+1)-lst-1; for(int i=1;i&lt;=n;i++)a[i]=lower_bound(lst+1,lst+tot+1,a[i])-lst; write(dfs(1,n,0,0)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AT2148]木と整数/Integers on a Tree]]></title>
    <url>%2F2019%2F09%2F29%2FAT2148-%E6%9C%A8%E3%81%A8%E6%95%B4%E6%95%B0-Integers-on-a-Tree%2F</url>
    <content type="text"><![CDATA[题目链接 AtCoder 题意简述 给定一棵\(n\)个点的树，编号从\(1\)到\(n\)，有\(K\)个点已经赋上了权值，现在让你给其它的点赋上权值，使这棵树满足任意一条边所连接的两个顶点的权值差为\(1\)。 \(1 \leqslant n \leqslant 10^5,1\leqslant K \leqslant n\)。 解题思路 考虑一种暴力解法。我们每次在图中选取值最小的点\(x\)，以它扩展周围的点，给它们都赋上\(val_x+1\)，这样所有权值都是递增的，那么如果中途出现某些点权值出现了冲突，那么就无解。很显然，所有的无解情况都包含在这里面。找值最小的点可以用堆来实现，时间复杂度\(O(n \log n)\)。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*Program from Luvwgyx*/#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)#define int long longusing namespace std;const int inf=1e9;const int maxn=1e5+10;priority_queue&lt;pi &gt;q;int n,K,tot,a[maxn],head[maxn];struct node&#123;int to,nxt;&#125;e[maxn&lt;&lt;1];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);putchar('\n');&#125;void add(int u,int v)&#123;e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;&#125;void insert(int u,int v)&#123;add(u,v);add(v,u);&#125;void init()&#123;for(int i=0;i&lt;maxn;i++)a[i]=inf;&#125;signed main()&#123; n=read();init(); for(int i=2;i&lt;=n;i++)insert(read(),read()); K=read(); for(int i=1;i&lt;=K;i++)&#123; int x=read(),y=read(); a[x]=y;q.push(mp(-y,x)); &#125; while(q.size())&#123; int y=-q.top().fir,x=q.top().sec;q.pop(); for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to)&#123; if(a[v]==inf)a[v]=y+1,q.push(mp(-a[v],v)); if(abs(a[x]-a[v])!=1)&#123;puts("No");return 0;&#125; &#125; &#125;puts("Yes");for(int i=1;i&lt;=n;i++)write(a[i]); return 0;&#125;/*41 22 33 421 24 4 */]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AT2363]Tautonym Puzzle]]></title>
    <url>%2F2019%2F09%2F29%2FAT2363-Tautonym-Puzzle%2F</url>
    <content type="text"><![CDATA[题目链接 AtCoder 题意简述 我们称一个串是好的，当且仅当他可以被分成完全相同的两部分。 现在需要构造一个串，满足如下条件： \(|S| \leqslant 200\)。 字符集大小为\([1,100]\)。 在\(S\)的所有子序列串中恰好有\(N\)个串是好的。 解题思路 假设空串也是好串。 设\(S=XY\)，其中\(X\)和\(Y\)都是字符串，且\(X\)和\(Y\)的子序列串中都只有空串是好的，\(S\)有\(N_0\)个串是好的。 设\(S\)中没有字符\(c\)， 令\(X&#39;=cX,Y&#39;=Yc\)，那么\(S&#39;=cXYc\)，且\(N&#39;=N_0+1\) 令\(X&#39;=cX,Y&#39;=cY\)，那么\(S&#39;=cXcY\)，且\(N&#39;=2N_0\) 很显然上面两种操作，\(X&#39;\)和\(Y&#39;\)的子序列串中都仍然只有空串是好的。 那么我们就可以用类似于快速幂的操作将\(N\)凑出来了，用双端队列维护一下加字符的操作就好了。 参考代码 12345678910111213141516171819202122232425262728293031323334/*Program from Luvwgyx*/#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;deque&lt;int &gt;s1,s2;int n;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);putchar('\n');&#125;void Write(int x)&#123;print(x);putchar(' ');&#125;signed main()&#123; int n=read()+1,digit=0,now=0; for(int i=1;i&lt;=n;i&lt;&lt;=1)digit++; for(int i=digit-2;i&gt;=0;i--)&#123; s1.push_back(++now);s2.push_back(now); if((n&gt;&gt;i)&amp;1)s1.push_front(++now),s2.push_back(now); &#125;write((int)s1.size()+(int)s2.size()); deque&lt;int &gt; :: iterator it; for(it=s1.begin();it!=s1.end();it++)Write(*it); for(it=s2.begin();it!=s2.end();it++)Write(*it); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AT2364]Colorful Balls]]></title>
    <url>%2F2019%2F09%2F29%2FAT2364-Colorful-Balls%2F</url>
    <content type="text"><![CDATA[题目链接 AtCoder 题意简述 Snuke 将\(n\)个彩球排成一行。从左向右第\(i\)个球的颜色为\(c_i\)，重量为\(w_i\)。 他可以利用以下两种操作重排这些彩球，操作可以按照任意顺序进行 任意次： 选取颜色相同的两个彩球，如果选取的两个彩球重量之和不超过\(X\)， 那么交换这两个彩球的位置。 选取颜色不同的两个彩球，如果选取的两个彩球重量之和不超过\(Y\)， 那么交换这两个彩球的位置。 求通过上述操作，可以得到多少种不同的颜色序列，答案对\(10^9+7\)取 模。 数据范围\(1 \leqslant N \leqslant 2 \times 10^5\)。 解题思路 很常见的一个转化思想，先将能够交换位置的彩球之间连边，那么我们就只要考虑每个联通块内的彩球颜色序列个数，然后利用乘法原理求出答案即可。 但是我们这样暴力连边是\(n^2\)的，考虑如何降低复杂度。 我们发现，我们只关心彩球之间是否联通，而并不关心是怎么联通的，因此我们只需要在每个联通块内找到一个中介点，让所有的点都与它相连。而显然这样的中介点当然是每种颜色的彩球重量最小的那个，因此我们处理出来每个颜色的彩球重量最小的是多少，再由此求出所有颜色的彩球的重量的最小值和次小值。 我们\(O(n)\)枚举每个彩球，如果颜色与重量最小的彩球的颜色不同，那么判断是否可以连边，然后统计联通块大小，否则则判断是否可以和重量次小的彩球连边。 很显然，对于一个联通块，它的答案为： \[ \frac{(\sum _{i=1} ^{k} cnt_i)!}{\prod cnt_i !} \] 其中\(k\)是该联通块中有几种颜色的彩球，\(cnt_i\)表示该联通块中颜色为\(i\)的彩球的个数。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*Program from Luvwgyx*/#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int mod=1e9+7;const int maxn=2e5+10;int n,X,Y,c[maxn],w[maxn],mn[maxn],cnt[maxn],fac[maxn],inv[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;int power(int a,int b)&#123; int ret=1; for(;b;b&gt;&gt;=1,a=a*a%mod) if(b&amp;1)ret=ret*a%mod; return ret;&#125;void init()&#123; memset(mn,63,sizeof(mn)); fac[0]=1;for(int i=1;i&lt;=n;i++)fac[i]=fac[i-1]*i%mod; inv[n]=power(fac[n],mod-2);inv[0]=1; for(int i=n-1;i&gt;=1;i--)inv[i]=inv[i+1]*(i+1)%mod;&#125;signed main()&#123; n=read();X=read();Y=read();init(); for(int i=1;i&lt;=n;i++)&#123; c[i]=read();w[i]=read(); mn[c[i]]=min(mn[c[i]],w[i]); &#125;int Min=0,Minn=0; for(int i=1;i&lt;=n;i++)&#123; if(mn[i]&lt;mn[Min])&#123;Minn=Min;Min=i;&#125; else if(mn[i]&lt;mn[Minn])Minn=i; &#125;int sum=0,ans=1; for(int i=1;i&lt;=n;i++)&#123; if(w[i]+mn[c[i]]&lt;=X)w[i]=mn[c[i]]; if(c[i]!=Min&amp;&amp;mn[Min ]+w[i]&lt;=Y)cnt[c[i]]++; if(c[i]==Min&amp;&amp;mn[Minn]+w[i]&lt;=Y)cnt[c[i]]++; &#125;for(int i=1;i&lt;=n;i++)if(cnt[i])sum+=cnt[i],ans=ans*inv[cnt[i]]%mod; write(ans*fac[sum]%mod); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AT2377]Blue and Red Tree]]></title>
    <url>%2F2019%2F09%2F28%2FAT2377-Blue-and-Red-Tree%2F</url>
    <content type="text"><![CDATA[题目链接 AtCoder 题意简述 给定一棵边的颜色全为蓝色的树和一棵边的颜色全为红色的树，一次操作如下：选择蓝树上的一条路径\((u,v)\)，任意选择路径上的一条边删去，然后在\(u\)和\(v\)之间连一条红色的边，问能否在\(n-1\)次操作内将蓝树变为与红树形态和颜色都一致。 解题思路 手玩一下就可以发现，原题中的操作可以转化为这样：在红树上找一条边，对应到蓝树上的一条路径，在这个路径上删去一条边，要求每次这个红色边的两个端点联通。 所以我们每次只需要找到恰好被红树上的边所对应的蓝树上的路径覆盖一次的边，将其删去就好了，然后链上\(-1\)，用树剖维护，时间复杂度\(O(n \log^2n)\)。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/*Program from Luvwgyx*/#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e5+10;struct edge&#123;int to,nxt;&#125;e[maxn&lt;&lt;1];int n,tot,idx=-1,pos,head[maxn],dfn[maxn],del[maxn],a[maxn],b[maxn],c[maxn],d[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void add(int u,int v)&#123;e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;&#125;struct Segment_Tree&#123; struct node&#123;int w,f;vector&lt;int &gt;id;&#125;tree[maxn&lt;&lt;2]; void update(int k)&#123;tree[k].w=min(tree[k&lt;&lt;1].w,tree[k&lt;&lt;1|1].w);&#125; void down(int k)&#123; if(tree[k].f)&#123; tree[k&lt;&lt;1].w+=tree[k].f;tree[k&lt;&lt;1|1].w+=tree[k].f; tree[k&lt;&lt;1].f+=tree[k].f;tree[k&lt;&lt;1|1].f+=tree[k].f; tree[k].f=0; &#125; &#125; void insert(int k,int l,int r,int x,int y,int v)&#123; if(x&lt;=l&amp;&amp;r&lt;=y)&#123;tree[k].id.push_back(v);tree[k].w++;tree[k].f++;return ;&#125; down(k);int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)insert(k&lt;&lt;1,l,mid,x,y,v); if(mid&lt;y)insert(k&lt;&lt;1|1,mid+1,r,x,y,v); update(k); &#125; void change(int k,int l,int r,int x,int y,int v)&#123; if(x&lt;=l&amp;&amp;r&lt;=y)&#123;tree[k].w+=v;tree[k].f+=v;return ;&#125; down(k);int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)change(k&lt;&lt;1,l,mid,x,y,v); if(mid&lt;y)change(k&lt;&lt;1|1,mid+1,r,x,y,v); update(k); &#125; int query(int k,int l,int r)&#123; if(tree[k].w&gt;1)return -1;int ret=0; while(!tree[k].id.empty()&amp;&amp;del[tree[k].id.back()])tree[k].id.pop_back(); if(!tree[k].id.empty())ret=tree[k].id.back(); if(l==r)&#123;pos=l;return ret;&#125;int mid=(l+r)&gt;&gt;1,now;down(k); now=query(k&lt;&lt;1,l,mid);if(now!=-1)&#123;if(now)return now;if(ret)return ret;&#125; now=query(k&lt;&lt;1|1,mid+1,r);if(now!=-1)&#123;if(now)return now;if(ret)return ret;&#125; return ret; &#125;&#125;T;struct Heavy_Light_Decomposition&#123; int dep[maxn],size[maxn],fa[maxn],top[maxn],son[maxn]; void build(int x,int deep)&#123; dep[x]=deep;size[x]=1;int mx=0; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(v!=fa[x])&#123; fa[v]=x;build(v,deep+1);size[x]+=size[v]; if(size[v]&gt;mx)mx=size[v],son[x]=v; &#125; &#125; void dfs(int x)&#123; if(!x)return ;dfn[x]=++idx; top[x]=son[fa[x]]==x?top[fa[x]]:x;dfs(son[x]); for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(v!=fa[x]&amp;&amp;v!=son[x])dfs(v); &#125; void insert(int x,int y,int id)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); T.insert(1,1,n-1,dfn[top[x]],dfn[x],id); x=fa[top[x]]; &#125;if(dfn[x]&gt;dfn[y])swap(x,y); if(x!=y)T.insert(1,1,n-1,dfn[x]+1,dfn[y],id); &#125; void change(int x,int y,int v)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])swap(x,y); T.change(1,1,n-1,dfn[top[x]],dfn[x],v); x=fa[top[x]]; &#125;if(dfn[x]&gt;dfn[y])swap(x,y); if(x!=y)T.change(1,1,n-1,dfn[x]+1,dfn[y],v); &#125;&#125;HLD;signed main()&#123; n=read(); for(int i=1;i&lt;n;i++)&#123; a[i]=read();b[i]=read(); add(a[i],b[i]);add(b[i],a[i]); &#125;HLD.build(1,1);HLD.dfs(1); for(int i=1;i&lt;n;i++)&#123; c[i]=read();d[i]=read(); HLD.insert(c[i],d[i],i); &#125; for(int i=1;i&lt;n;i++)&#123; if(T.tree[1].w!=1)&#123;puts("NO");return 0;&#125; int now=T.query(1,1,n-1);del[now]=1; T.change(1,1,n-1,pos,pos,maxn); HLD.change(c[now],d[now],-1); &#125;puts("YES"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AT2164]Rabbit Exercise]]></title>
    <url>%2F2019%2F09%2F27%2FAT2164-Rabbit-Exercise%2F</url>
    <content type="text"><![CDATA[题目链接 AtCoder 题意简述 有\(n\)只兔子在数轴上，数轴编号从\(1\)到\(n\)，第\(i\)只兔子的初始位置是\(X_i\)。 他们会以如下方式进行锻炼： 一轮包含\(m\)个跳跃，第\(j\)个进行跳跃的是兔子\(a_j(1 &lt; a_j &lt; n)\)，对于每一个跳跃，兔子\(a_j\)都会等概率地从\(a_j-1\)和\(a_j+1\)中选择一个（假设选择的是\(x\)），那么兔子\(a_j\)会跳到他当前坐标关于\(x\)的对称坐标。 兔子们会进行连续\(k\)轮这样的跳跃，对于每个兔子求出最后他的期望坐标。 \(3 \leqslant n \leqslant 10^5,X_i \in {\rm Z},|a_i| \leqslant 10^9,1 \leqslant m \leqslant 10^5,2 \leqslant a_i \leqslant n-1,1\leqslant k \leqslant 10^{18}\)。 解题思路 首先翻转操作相当于\(A_i=2x-a_i\)，由期望的线性性可知\(E(A_i)=E(2x)-E(a_i)\)。 那么问题就转化为每次做操作\(a_i&#39;=\frac{2a_{i+1}-a_i+2a_{i-1}-a_i}{2}=a_{i-1}+a_{i+1}-a_i\)，移项后变为\(a_i&#39;-a_{i-1}=a_{i+1}-a_i\)和\(a_{i+1}-a_i&#39;=a_i-a_{i-1}\)，那么我们将原序列差分出来，就将原题意的翻转操作转化为交换两个差分了。 那么我们只需要倍增一下求出坐标\(i\)在\(k\)轮变换后变成了什么，然后前缀和还原\(X\)数组就好了。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e5+10;int n,m,K,a[maxn],X[maxn],nxt[maxn],ans[maxn],tmp[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts(".0");&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)tmp[i]=read(),X[i]=tmp[i]-tmp[i-1]; m=read();K=read(); for(int i=1;i&lt;=m;i++)a[i]=read(); for(int i=1;i&lt;=n;i++)nxt[i]=i; for(int i=1;i&lt;=m;i++)swap(nxt[a[i]],nxt[a[i]+1]); for(int i=1;i&lt;=n;i++)ans[i]=i; while(K)&#123; if(K&amp;1)&#123; for(int i=1;i&lt;=n;i++)tmp[i]=ans[nxt[i]]; for(int i=1;i&lt;=n;i++)ans[i]=tmp[i]; &#125; for(int i=1;i&lt;=n;i++)tmp[i]=nxt[nxt[i]]; for(int i=1;i&lt;=n;i++)nxt[i]=tmp[i];K&gt;&gt;=1; &#125; for(int i=1;i&lt;=n;i++)tmp[i]=X[ans[i]]; for(int i=1;i&lt;=n;i++)X[i]=tmp[i];int now=0; for(int i=1;i&lt;=n;i++)now+=X[i],write(now); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JOI 2018 Final]]></title>
    <url>%2F2019%2F09%2F25%2FJOI-2018-Final%2F</url>
    <content type="text"><![CDATA[比赛链接 LOJ 寒冬暖炉 解题思路 将客人来的时间汇总，那么要开启暖炉的时间就变成一个个时间段了，考虑最优的方案肯定是将时间段之间的间隔拎出来从大到小排序，取最大的前\(K-1\)个，因为最开始开启暖炉也是要用火柴的。 参考代码 12345678910111213141516171819202122232425262728293031/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e5+10;int n,K,tot,a[maxn],b[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; n=read();K=read()-1; for(int i=1;i&lt;=n;i++)a[i]=read(); sort(a+1,a+n+1);int ans=a[n]-a[1]+1; for(int i=2;i&lt;=n;i++)&#123; int ret=a[i]-a[i-1]-1; if(ret)b[++tot]=ret; &#125;sort(b+1,b+tot+1); for(int i=tot;i&gt;=max(1,tot-K+1);i--)ans-=b[i]; write(ans); return 0;&#125; 美术展览 解题思路 考虑若将所有的展品都按尺寸排序，那么选择的展品必然是连续的一段，那么我们只需要前缀和一下然后贪心就好了。 参考代码 1234567891011121314151617181920212223242526272829303132333435/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long long#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)using namespace std;const int inf=1e18;const int maxn=5e5+10;int n,mn,sum[maxn],mx[maxn];pi a[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i].fir=read(),a[i].sec=read();//a[i]=mp(read(),read()); sort(a+1,a+n+1);int ans=0;mx[0]=-inf;mn=inf; for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i].sec; for(int i=1;i&lt;=n;i++)mx[i]=max(mx[i-1],a[i].fir-sum[i-1]); for(int i=n;i&gt;=1;i--)mn=min(mn,a[i].fir-sum[i]),ans=max(ans,mx[i]-mn); write(ans); return 0;&#125; 团子制作 解题思路 考虑串一串团子，能影响到的能串团子的位置只有是以G团子作对角线，对角线穿过的G团子所能串的团子（语文不好别吐槽），那么我们在对角线上\(\rm DP\)就好了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=3e3+10;char mp[maxn][maxn];int n,m,cnt,ans,f[maxn*maxn][3];bool ok[maxn*maxn][2];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void calc()&#123; for(int i=1;i&lt;=cnt+1;i++)&#123; f[i][2]=max(f[i-1][0],max(f[i-1][1],f[i-1][2])); f[i][0]=ok[i][0]?(max(f[i-1][0],f[i-1][2])+1):0; f[i][1]=ok[i][1]?(max(f[i-1][1],f[i-1][2])+1):0; &#125;ans+=f[cnt+1][2];&#125;signed main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++)scanf("%s",mp[i]+1); for(int k=2;k&lt;=n+m;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; int j=k-i; if(j&lt;1||j&gt;m)continue; if(mp[i][j]!='G')&#123;if(cnt)calc(),cnt=0;&#125; else &#123; cnt++; ok[cnt][0]=(mp[i-1][j]=='R'&amp;&amp;mp[i+1][j]=='W'); ok[cnt][1]=(mp[i][j-1]=='R'&amp;&amp;mp[i][j+1]=='W'); &#125; &#125;if(cnt)calc(),cnt=0; &#125; write(ans); return 0;&#125; 月票购买 解题思路 因为要买月票，所以先将\(S\)到\(T\)之间的最短路径图整出来，很显然是一个有向无环图。 再考虑\(U\)到\(V\)之间的路径，与最短路径图有交的部分一定是连续的一段，所以我们直接在\(DAG\)上\(\rm DP\)就好了。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*Program from Luvwgyx*/#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fir first#define sec second#define int long long#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)using namespace std;const int maxn=1e5+10;const int maxm=2e5+10;struct node&#123;int from,to,nxt,w;&#125;e[maxm&lt;&lt;1],ee[maxm&lt;&lt;1];int n,m,S,T,U,V,tot,ttot,head[maxn],hhead[maxn],dis[4][maxn];priority_queue&lt;pi &gt;q;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void add(int u,int v,int w)&#123;e[++tot].from=u;e[tot].to=v;e[tot].w=w;e[tot].nxt=head[u];head[u]=tot;&#125;void addd(int u,int v,int w)&#123;ee[++ttot].from=u;ee[ttot].to=v;ee[ttot].w=w;ee[ttot].nxt=hhead[u];hhead[u]=ttot;&#125;void insert(int u,int v,int w)&#123;add(u,v,w);add(v,u,w);&#125;bool vis[maxn];void dijkstra(int S,int opt)&#123; memset(vis,0,sizeof(vis)); memset(dis[opt],63,sizeof(dis[opt])); dis[opt][S]=0;q.push(mp(0,S)); while(q.size())&#123; int x=q.top().sec;q.pop(); if(vis[x])continue;vis[x]=1; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(dis[opt][v]&gt;dis[opt][x]+e[i].w)&#123; dis[opt][v]=dis[opt][x]+e[i].w; q.push(make_pair(-dis[opt][v],v)); &#125; &#125;&#125;int cnt,now[maxn],f[maxn],g[maxn];void dfs(int x)&#123; vis[x]=1; for(int i=hhead[x],v=ee[i].to;i;i=ee[i].nxt,v=ee[i].to) if(!vis[v])dfs(v); now[++cnt]=x;&#125;signed main()&#123; n=read();m=read();S=read();T=read();U=read();V=read(); for(int i=1;i&lt;=m;i++)insert(read(),read(),read()); dijkstra(S,0);dijkstra(T,1);dijkstra(U,2);dijkstra(V,3); for(int i=1;i&lt;=tot;i++)&#123; int u=e[i].from,v=e[i].to,w=e[i].w; if(dis[0][u]+w+dis[1][v]==dis[0][T])addd(u,v,w); &#125;memset(vis,0,sizeof(vis));dfs(S);int ans=dis[2][V]; for(int i=1;i&lt;=cnt;i++)&#123; int x=now[i];f[x]=dis[2][x];g[x]=dis[3][x]; for(int i=hhead[x],v=ee[i].to;i;i=ee[i].nxt,v=ee[i].to)&#123; f[x]=min(f[x],f[v]); g[x]=min(g[x],g[v]); &#125;ans=min(ans,min(f[x]+dis[3][x],g[x]+dis[2][x])); &#125;write(ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ1972][Sdoi2010]猪国杀]]></title>
    <url>%2F2019%2F09%2F19%2FBZOJ1972-Sdoi2010-%E7%8C%AA%E5%9B%BD%E6%9D%80%2F</url>
    <content type="text"><![CDATA[题目链接 BZOJ LOJ 解题思路 大模拟... 对于每只猪记录身份，牌数，牌的种类，死了没，用没用过杀，跳了身份没，是不是类反猪，然后直接模拟就行。 注意： 无懈可击是从自己开始判断。 可能会把自己决斗死 结束了不要再摸牌 在万箭齐发和南蛮入侵的时候注意要判是不是结束 无懈可击也是锦囊牌，也就是说别人可以用无懈可击来让你的无懈可击失效，然后你们可以循环下去 牌不要担心会用完 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=20;const int maxm=2e4+10;struct node&#123; char card[maxm]; int cnt,hp,kind,fst,f[maxm]; bool arms,like,jump,dead,killed;&#125;a[maxn];int n,m,pos,now;char P[maxm];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void print_cards(int x)&#123; for(int i=a[x].fst;i&lt;=a[x].cnt;i++) if(!a[x].f[i])putchar(a[x].card[i]),putchar(' '); putchar('\n');&#125;void usecard(int x,int y)&#123; a[x].f[y]=1; if(y==a[x].fst)while(a[x].f[a[x].fst])a[x].fst++;&#125;void debug()&#123; printf("%lld: \n",now); for(int i=1;i&lt;=n;i++) if(!a[i].dead)&#123; printf("%lld : %lld %lld : ",i,a[i].hp,a[i].jump); print_cards(i); &#125;&#125;int get(char s)&#123; if(s=='P')return 1; if(s=='K')return 2; if(s=='D')return 3; if(s=='F')return 4; if(s=='N')return 5; if(s=='W')return 6; if(s=='J')return 7; if(s=='Z')return 8; return 0;&#125;bool check_end()&#123; bool flag1=0,flag2=0; for(int i=1;i&lt;=n;i++)if(a[i].kind==1&amp;&amp;!a[i].dead)flag1=1; for(int i=1;i&lt;=n;i++)if(a[i].kind==3&amp;&amp;!a[i].dead)flag2=1; return flag1^flag2;&#125;int have_K(int x)&#123; if(a[x].dead)return 0; for(int i=a[x].fst;i&lt;=a[x].cnt;i++)if(a[x].card[i]=='K'&amp;&amp;!a[x].f[i])return i; return 0;&#125;int have_D(int x)&#123; if(a[x].dead)return 0; for(int i=a[x].fst;i&lt;=a[x].cnt;i++)if(a[x].card[i]=='D'&amp;&amp;!a[x].f[i])return i; return 0;&#125;int have_J(int x)&#123; if(a[x].dead)return 0; for(int i=a[x].fst;i&lt;=a[x].cnt;i++)if(a[x].card[i]=='J'&amp;&amp;!a[x].f[i])return i; return 0;&#125;int have_P(int x)&#123; if(a[x].dead)return 0; for(int i=a[x].fst;i&lt;=a[x].cnt;i++)if(a[x].card[i]=='P'&amp;&amp;!a[x].f[i])return i; return 0;&#125;bool dead(int x)&#123; if(a[x].hp)return 0; int Pos=have_P(x); if(Pos)&#123;a[x].hp++;usecard(x,Pos);return 0;&#125; return 1;&#125;void damage(int x,int y)&#123; if(a[y].hp)return ; if(!dead(y))return ; a[y].dead=1;if(check_end())return ; if(a[y].kind==3)&#123; int tot=3,Tot=0; while(++Tot&lt;=tot)a[x].card[++a[x].cnt]=P[min(++pos,m)]; //printf("Cards::\n");debug(); return ; &#125; if(a[y].kind==2&amp;&amp;a[x].kind==1)&#123; for(int i=a[x].fst;i&lt;=a[x].cnt;i++)a[x].f[i]=1; a[x].arms=0; &#125;&#125;bool wxkj(int x,int y)&#123; //printf("\n%lld %lld\n",x,y); int Now=x;bool flag=0; for(int i=1;i&lt;=n;i++)&#123; if(a[Now].dead)&#123;Now=Now%n+1;continue;&#125; int Pos=have_J(Now);if(!Pos)&#123;Now=Now%n+1;continue;&#125; if(a[Now].kind==a[y].kind&amp;&amp;a[y].jump)flag=1; if((a[Now].kind==2&amp;&amp;a[y].kind==1)||(a[Now].kind==1&amp;&amp;a[y].kind==2&amp;&amp;a[y].jump))flag=1; if(flag)&#123;a[Now].jump=1;usecard(Now,Pos);break;&#125; Now=Now%n+1; &#125;if(!flag)return 1;y=x;x=Now;int opt=0; //printf("%lld %lld\n",x,y); while(1)&#123; flag=0; for(int i=1;i&lt;=n;i++)&#123; if(a[Now].dead)&#123;Now=Now%n+1;continue;&#125; //printf("%lld ",Now); int Pos=have_J(Now);if(!Pos)&#123;Now=Now%n+1;continue;&#125; if(a[Now].kind==1&amp;&amp;(a[x].kind==3||(!a[x].jump&amp;&amp;a[x].like)))flag=1; if(a[Now].kind==2&amp;&amp;a[x].kind==3&amp;&amp;a[x].jump)flag=1; if(a[Now].kind==3&amp;&amp;(a[x].kind==1||(a[x].kind==2&amp;&amp;a[x].jump)))flag=1; if(flag)&#123;a[Now].jump=1;usecard(Now,Pos);opt^=1;x=Now;break;&#125; Now=Now%n+1; &#125;if(!flag)break;//puts(""); //printf("%lld %lld %lld\n",a[x].kind,x,opt); &#125;//puts(""); return opt;&#125;void fight(int x,int y)&#123; if(a[x].kind==1&amp;&amp;a[y].kind==2)&#123;a[y].hp--;damage(x,y);return ;&#125; while(1)&#123; int Pos=have_K(y); if(!Pos)&#123;a[y].hp--;damage(x,y);break;&#125; usecard(y,Pos);swap(x,y); &#125;&#125;void nmrq(int x)&#123; int Now=x%n+1; while(Now!=x)&#123; if(a[Now].dead)&#123;Now=Now%n+1;continue;&#125; if(!wxkj(x,Now))&#123;Now=Now%n+1;continue;&#125; int Pos=have_K(Now); if(!Pos)&#123; a[Now].hp--;damage(x,Now); if(a[Now].kind==1)&#123; if(a[x].kind==2&amp;&amp;!a[x].jump)a[x].like=1; if(a[x].kind==3)a[x].jump=1,a[x].like=1; &#125; &#125;else usecard(Now,Pos); if(check_end())return ; Now=Now%n+1; &#125;&#125;void wjqf(int x)&#123; int Now=x%n+1;//printf("WJQF:\n"); while(Now!=x)&#123; if(a[Now].dead)&#123;Now=Now%n+1;continue;&#125; if(!wxkj(x,Now))&#123;Now=Now%n+1;continue;&#125; int Pos=have_D(Now); if(!Pos)&#123; a[Now].hp--;damage(x,Now); if(a[Now].kind==1)&#123; if(a[x].kind==2&amp;&amp;!a[x].jump)a[x].like=1; if(a[x].kind==3)a[x].jump=1,a[x].like=1; &#125; &#125;else usecard(Now,Pos); if(check_end())return ; Now=Now%n+1; &#125;&#125;signed main()&#123; //freopen("a.in","r",stdin); //freopen("19.ans","w",stdout); n=read();m=read();char opt[10]; for(int i=1;i&lt;=n;i++)&#123; scanf("%s",opt); if(opt[0]=='M')a[i].kind=1,a[i].jump=1; else if(opt[0]=='Z')a[i].kind=2; else a[i].kind=3;a[i].hp=4;a[i].fst=1; for(int j=1;j&lt;=4;j++)&#123; scanf("%s",opt); a[i].card[++a[i].cnt]=opt[0]; &#125; &#125;pos=0;now=0; for(int i=1;i&lt;=m;i++)&#123; char ch=getchar(); while(ch&lt;'A'||ch&gt;'Z')ch=getchar(); P[i]=ch; &#125; while(!check_end())&#123; now=now%n+1;while(a[now].dead)now=now%n+1;a[now].killed=0; int tot=2,Tot=0; while(++Tot&lt;=tot)a[now].card[++a[now].cnt]=P[min(++pos,m)]; //debug(); while(1)&#123; bool FLAG=0;//if(now==3)debug(); for(int i=a[now].fst;i&lt;=a[now].cnt;i++)&#123; if(a[now].f[i])continue;int kind=get(a[now].card[i]); //puts("ok"); if(kind==1)&#123; if(a[now].hp&lt;4)a[now].hp++,usecard(now,i),FLAG=1; //printf("%lld used the peach\n",now); &#125;else if(kind==2)&#123; if(!a[now].arms)if(a[now].killed)continue; int Now=now%n+1;bool flag=0; while(a[Now].dead&amp;&amp;Now!=now)Now=Now%n+1; if(Now==now)continue; if(a[now].kind==1||a[now].kind==2)&#123; if(a[Now].kind==3&amp;&amp;a[Now].jump)&#123;flag=1;&#125; else &#123;if(a[now].kind==1&amp;&amp;a[Now].like)flag=1;&#125; &#125;else &#123; if(a[Now].kind==1)&#123;flag=1;&#125; else &#123;if(a[Now].kind==2&amp;&amp;a[Now].jump)flag=1;&#125; &#125;if(flag)&#123; a[now].killed=1;usecard(now,i); int Pos=have_D(Now);a[now].jump=1; if(!Pos)&#123;a[Now].hp--;damage(now,Now);&#125; else &#123;usecard(Now,Pos);&#125; FLAG=1; &#125; &#125;else if(kind==3)continue; else if(kind==4)&#123; if(a[now].kind==1)&#123; int Now=now%n+1; while((a[Now].dead||(!((a[Now].kind==3&amp;&amp;a[Now].jump)||a[Now].like)))&amp;&amp;Now!=now)Now=Now%n+1; if(Now==now)continue;usecard(now,i);FLAG=1; if(!wxkj(now,Now))break;fight(now,Now); &#125;else if(a[now].kind==2)&#123; int Now=now%n+1; while((a[Now].dead||(!(a[Now].kind==3&amp;&amp;a[Now].jump)))&amp;&amp;Now!=now)Now=Now%n+1; if(Now==now)continue;usecard(now,i);a[now].jump=1;FLAG=1; if(!wxkj(now,Now))break;fight(now,Now); &#125;else &#123; int Now=now%n+1; while(a[Now].kind!=1&amp;&amp;Now!=now)Now=Now%n+1; if(Now==now)continue;usecard(now,i);a[now].jump=1;FLAG=1; if(!wxkj(now,Now))break;fight(now,Now); &#125; &#125;else if(kind==5)&#123;usecard(now,i);nmrq(now);FLAG=1;&#125; else if(kind==6)&#123;usecard(now,i);wjqf(now);FLAG=1;&#125; else if(kind==7)continue; else if(kind==8)&#123;usecard(now,i);a[now].arms=1;FLAG=1;&#125; if(FLAG)break; &#125;if(!FLAG)break;if(check_end())break; if(a[now].dead)break; &#125;//debug(); &#125;bool flag=0; for(int i=1;i&lt;=n;i++)if(a[i].kind==1&amp;&amp;!a[i].dead)&#123;flag=1;break;&#125; puts(flag?"MP":"FP"); for(int i=1;i&lt;=n;i++)&#123; if(a[i].dead)&#123;puts("DEAD");continue;&#125; print_cards(i); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数论学习(Part 2)]]></title>
    <url>%2F2019%2F09%2F12%2F%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0-Part-2%2F</url>
    <content type="text"><![CDATA[乘法逆元 如果一个线性同余方程\(ax \equiv 1 ({\rm mod}~p)\)，则称\(x\)为\(p\)在\({\rm mod} ~ p\)意义下的逆元，记作\(a^{-1}\)。 扩展欧几里得法 与求解线性同余方程同理。 快速幂法 由费马小定理有： 若\(a\)为正整数，\(p\)为质数，且\(a\)与\(p\)互质，则\(a^{p-1} \equiv 1 ({\rm mod}~p)\)。 那么当我们要求解的是模一个质数意义下的逆元时，我们可以得到\(ax \equiv a^{p-1} ( {\rm mod}~p) \Leftrightarrow x \equiv a^{p-2} ({\rm mod}~p)\)，这样我们就可以用快速幂求解了。 线性求\(1\)到\(n\)的逆元 求\(1,2, \cdots , n\)这些数的逆元，单个求的复杂度为\(O(n \log n)\)，我们考虑如何\(O(n)\)求解。 设\(t=\frac{p}{i},k=p~{\rm mod}~i\)，那么 \[ ti+k \equiv 0 ({\rm mod }~p)\\ -ti \equiv k ({\rm mod } ~ p)\\ -t\times inv_k \equiv inv_i ({\rm mod } ~ p)\\ inv_i=-(p/i)~inv_{p~{\rm mod}~i}\\ \] 这样我们就可以线性递推求出\(1\)到\(n\)的逆元了： 1234void init()&#123; inv[1]=1; for(int i=2;i&lt;=n;i++)inv[i]=(-mod/i)*inv[mod%i]%mod;&#125; 但是我们发现这样子做会出现负数，我们处理一下： 1234void get()&#123; inv[1]=1; for(int i=2;i&lt;=n;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;&#125; 线性求任意\(n\)个数的逆元 求给定的\(n\)个数\(1 \leqslant a_i \leqslant p\)的逆元： 首先计算前\(i\)个数的前缀积\(mul_i\)，然后用快速幂或者扩展欧几里得求出\(mul_n\)的逆元\(invv_n\)。 由于\(invv_n\)是\(n\)个数的积的逆元，所以我们将其乘以\(a_i\)时会抵消掉\(a_i\)的逆元，这样我们可以倒序递推求出前\(i\)个数的积的逆元。 然后我们就可以用\(mul_{i-1} \times invv_i\)来得出\(a_i\)的逆元。 参考代码： 123456void init()&#123; mul[0]=1;for(int i=1;i&lt;=n;i++)mul[i]=mul[i-1]*a[i]%mod; invv[n]=power(mul[n],mod-2); for(int i=n;i&gt;=1;i--)invv[i-1]=invv[i]*a[i]%mod; for(int i=1;i&lt;=n;i++)inv[i]=invv[i]*mul[i-1]%mod; &#125; 整除分块 快速求解 \(\sum_{i=1}^{n} \lfloor \frac{n}{i} \rfloor\)。 我们发现： \[ \forall n \in N,|\{\lfloor \frac{n}{d} \rfloor |d \in N\}| \leqslant \lfloor 2 \sqrt{n} \rfloor \] 其中\(|V|\)表示\(V\)这个集合的元素个数。 证明： 对于$d \(，\) \(有\)n\(种取值，对于\)d &gt; n \(，\) n$，因此 $ \(也只有\)n\(种取值，因此最多有\)2 n $种取值。 我们还能发现： 设\(\lfloor \frac{n}{i} \rfloor = \lfloor \frac{n}{i&#39;} \rfloor\)，则\(i&#39;\)的最大值为\(\lfloor \frac{n}{\lfloor \frac{n}{i} \rfloor}\rfloor\)。 证明：]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论学习(Part 1)]]></title>
    <url>%2F2019%2F09%2F10%2F%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0-Part-1%2F</url>
    <content type="text"><![CDATA[扩展欧几里得 形如\(ax+by=\gcd(a,b)\)，可以用扩展欧几里得求得整数解。 设\(ax_1+by_1=\gcd(a,b)\)，且我们已求得\(bx_2+(a\%b)y_2=\gcd(a,b)\)的解\(x_2,y_2\)，考虑如何推出\(x_1,y_1\)。 \[ \because a\%b=a- b\lfloor \frac{a}{b} \rfloor\\ \therefore ax_1+by_1=bx_2+(a- b\lfloor \frac{a}{b} \rfloor)y_2\\ \begin{align*} ax_1+by_1 &amp;= bx_2+ay_2-b\lfloor \frac{a}{b} \rfloor y_2\\ &amp;=ay_2+b(x_2-\lfloor \frac{a}{b} \rfloor y_2)\\ \end{align*} \\ \therefore x_1=y_2,y_1=x_2-\lfloor \frac{a}{b} \rfloor y_2 \] 费马小定理 若\(p\)为素数，\(\gcd(a,p)=1\)，则\(a^{p-1}\equiv 1({\rm{mod}}~p)\)。 欧拉函数 欧拉函数\(\varphi(n)\)表示小于等于\(n\)且和\(n\)互质的数的个数。 \(\varphi(1)=1\)，\(n\)为质数时\(\varphi(n)=n-1\)。 根据唯一分解定理，我们可以把一个整数唯一地分解为质数幂次的乘积，设\(n=p_1^{k_1}p_2^{k_2}...p_s^{k_s}\)，其中\(p_i\)是质数，那么\(\varphi(n)=n\times\prod_{i=1}^s\frac{p_i-1}{p_i}\)。 性质 积性函数。即若\(\gcd(a,b)=1\)，则\(\varphi(a\times b)=\varphi(a)\times \varphi(b)\)。 \(n=\sum_{d|n}\varphi(d)\)，可以利用莫比乌斯反演的相关知识得出。 也可以这样理解：若\(\gcd(n,k)=d\)，那么\(\gcd(\frac{n}{d},\frac{k}{d})=1\)，其中\(k&lt;n\)。 设\(f(x)\)表示\(\gcd(n,k)=x\)的数的个数，那么\(n=\sum_{i=1}^nf(i)\)，由于\(f(x)=\varphi(\frac{n}{x})\)，则\(n=\sum_{d|n}\varphi(\frac{n}{d})\)，由于\(d\)和\(\varphi(\frac{n}{d})\)具有对称性，所以\(n=\sum_{d|n}\varphi(d)\)。 若\(n=p^k\)，其中\(p\)为质数，那么\(\varphi(n)=p^k-p^{k-1}\)。 欧拉定理 若\(\gcd(a,m)=1\)，则\(a^{\varphi(m)} \equiv 1({\rm{mod}}~m)\)。 证明： 简化剩余系：所有\(\gcd(n,m)=1,1\leqslant n \leqslant m\)的\(n\)构成了\(m\)的简化剩余系，简称缩系。 设\(r_1,r_2,...,r_{\varphi(m)}\)为模\(m\)意义下的缩系，那么\(ar_1,ar_2,...,ar_{\varphi(m)}\)同为模\(m\)意义下 的缩系。 \[ r_1r_2\cdots r_{\varphi(m)}=ar_1\cdot ar_2 \cdots ar_{\varphi(m)}=a^{\varphi(m)}r_1r_2\cdots r_{\varphi(m)}\\ \therefore a^{\varphi(m)} \equiv 1({\rm{mod}}~m) \] 当\(m\)为素数时，由于\(\varphi(m)=m-1\)，代入欧拉定理即可得费马小定理。 类欧几里得 引入 设 \[ f(a,b,c,n)=\sum_{i=0}^n\lfloor \frac{ai+b}{c} \rfloor \] 其中\(a,b,c,n\)均为常数，考虑如何在\(O(\log n)\)时间内求解答案。 向下取整很容易想到数论分块，然后用在这里似乎不好做，但是我们也可以做一些优化：如果\(a \geqslant c,b\geqslant c\)，我们考虑对式子进行取模处理： \[ \begin{align*} f(a,b,c,n) &amp;= \sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor\\ &amp;=\sum_{i=0}^n\lfloor \frac{(\lfloor \frac{a}{c} \rfloor c +a~{\rm mod}~ c)i+(\lfloor \frac{b}{c} \rfloor c+ b~{\rm mod}~c)}{c} \rfloor\\ &amp;=\lfloor\frac{a}{c} \rfloor\frac{n(n+1)}{2}+\lfloor \frac{b}{c} \rfloor(n+1)+\sum_{i=0}^n\lfloor \frac{(a~{\rm mod}~c)i+b~{\rm mod}~c}{c} \rfloor\\ &amp;=\lfloor\frac{a}{c} \rfloor\frac{n(n+1)}{2}+\lfloor \frac{b}{c} \rfloor(n+1)+f(a~{\rm mod}~c,b~{\rm mod}~c,c,n)\\ \end{align*} \] 那么现在问题就转化为如何求解\(a &lt; c,b&lt;c\)情况下的\(f\)函数值了。 由于只有\(i\)一个变量，所以只能考虑对\(i\)进行一些操作。在推求和式子中有一个常见的技巧，就是条件与贡献的放缩与转化。具体地说，在原式中，\(0 \leqslant i \leqslant n\)是条件，而\(\lfloor\frac{ai+b}{c}\rfloor\)是对总和的贡献。我们要加速和式的计算都是将贡献合并计算，但是这个式子的贡献并不好合并计算，因此我们考虑将贡献和条件互相转化变成新形式的和式来计算贡献，我们直接把贡献变成条件： \[ \begin{align*} f(a,b,c,n) &amp;= \sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor\\ &amp;=\sum_{i=0}^n\sum_{j=0}^{\lfloor\frac{ai+b}{c}\rfloor-1}1\\ \end{align*} \] 现在我们多了一个变量\(j\)，由于并不好计算\(i\)的贡献，我们考虑计算\(j\)的贡献。由于\(j\)的贡献是受\(i\)的限制的，而我们现在要单独计算\(j\)的贡献，因此我们将\(i\)和\(j\)的求和式子交换，把\(j\)放到贡献式子里，强制用\(n\)限制\(j\)的范围： \[ \begin{align*} f(a,b,c,n) &amp;=\sum_{i=0}^n\sum_{j=0}^{\lfloor\frac{ai+b}{c}\rfloor-1}1\\ &amp;=\sum_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}\sum_{i=0}^n[j &lt; \lfloor\frac{ai+b}{c}\rfloor] \end{align*} \] 这样\(j\)就不受\(i\)的限制，而是与\(i\)一样受\(n\)的限制，我们再将贡献式变形变成与\(i\)相关的式子： \[ j &lt; \lfloor\frac{ai+b}{c}\rfloor \Leftrightarrow j+1 \leqslant \lfloor\frac{ai+b}{c}\rfloor \Leftrightarrow j+1 \leqslant \frac{ai+b}{c}\\ jc+c-b \leqslant ai \Leftrightarrow jc+c-b-1 &lt;ai \Leftrightarrow i &gt; \lfloor \frac{jc+c-b-1}{a} \rfloor\\ \] 设\(m= \lfloor\frac{an+b}{c}\rfloor\)，那么式子就变为： \[ \begin{align*} f(a,b,c,n) &amp;= \sum_{j=0}^{m-1} \sum_{i=0}^n [i &gt; \lfloor \frac{jc+c-b-1}{a} \rfloor]\\ &amp;=\sum_{j=0}^{m-1} n - \lfloor \frac{jc+c-b-1}{a} \rfloor\\ &amp;=nm-f(c,c-b-1,a,m-1) \end{align*} \] 因此 \[ f(a,b,c,n)= \begin{cases} \lfloor\frac{a}{c} \rfloor\frac{n(n+1)}{2}+\lfloor \frac{b}{c} \rfloor(n+1)+f(a~{\rm mod}~c,b~{\rm mod}~c,c,n) &amp; {a \geqslant c,b \geqslant c}\\ n\lfloor\frac{an+b}{c}\rfloor -f(c,c-b-1,a,m-1) &amp; {a &lt; c,b &lt; c}\\ \end{cases} \] 很显然这是一个递归式，并且在\(a&lt;c,b&lt;c\)的时候分子分母换了位置，又可以重复上述过程。先取模，再递归。这就是一个辗转相除的过程，这也是类欧几里德算法的得名。 时间复杂度为\(O(\log n)\)。 扩展 现在我们得出了最基本的类欧几里得算法，我们考虑求解下面两个变式： \[ g(a,b,c,n)=\sum_{i=0}^n i\lfloor \frac{ai+b}{c} \rfloor\\ h(a,b,c,n)=\sum_{i=0}^n\lfloor \frac{ai+b}{c} \rfloor^2 \] \(g\)函数的推导 同理，对于\(a \geqslant c,b \geqslant c\)的情况，取模： \[ \begin{align*} g(a,b,c,n) &amp;= \sum_{i=0}^n i \lfloor \frac{ai+b}{c} \rfloor\\ &amp;= \sum_{i=0}^n i \lfloor \frac{(\lfloor \frac{a}{c} \rfloor c + a~{\rm mod}~i)i+(\lfloor \frac{b}{c} \rfloor c + b~{\rm mod}~i)}{c} \rfloor\\ &amp;= \sum_{i=0}^n (i \frac{(a~{\rm mod}~i)i+b~{\rm mod}~i}{c}+i(i\lfloor \frac{a}{c} \rfloor + \lfloor \frac{b}{c} \rfloor )\\ &amp;= g(a~{\rm mod}~c,b~{\rm mod}~c,c,n)+\sum_{i=0}^n (i^2 \lfloor \frac{a}{c} \rfloor + i \lfloor \frac{b}{c} \rfloor)\\ &amp;= g(a~{\rm mod}~c,b~{\rm mod}~c,c,n)+\frac{n(2n+1)(n+1)}{6} \lfloor \frac{a}{c} \rfloor +\frac{n(n+1)}{2} \lfloor \frac{b}{c} \rfloor\\ \end{align*} \] 对于\(a&lt;c,b&lt;c\)的情况，令\(m=\lfloor\frac{an+b}{c}\rfloor\)，同理可得： \[ \begin{align*} g(a,b,c,n)&amp;=\sum_{i=0}^n i \lfloor \frac{ai+b}{c} \rfloor\\ &amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n i [j &lt; \lfloor \frac{ai+b}{c} \rfloor]\\ &amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n i [i &gt; \lfloor \frac{cj-c-b-1}{a} \rfloor ]\\ \end{align*} \] 令\(t=\lfloor \frac{cj-c-b-1}{a} \rfloor\)，那么： \[ \begin{align*} g(a,b,c,n) &amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n i [i &gt; \lfloor \frac{cj-c-b-1}{a} \rfloor ]\\ &amp;=\sum_{j=0}^{m-1}\sum_{i=0}^n i [i &gt; t]\\ &amp;=\sum_{j=0}^{m-1}\frac{(t+1+n)(n-t)}{2}\\ &amp;=\frac{1}{2}\sum_{j=0}^{m-1}(nt-t^2+n^2-nt+n-t)\\ &amp;=\frac{1}{2}[mn(n+1) - \sum_{j=0}^{m-1}t^2-\sum_{j=0}^{m-1}t]\\ &amp;=\frac{1}{2}[mn(n+1) - h(c,c-b-1,a,m-1) - f(c,c-b-1,a,m-1)]\\ \end{align*} \] \(h\)函数的推导 同样的，对于\(a \geqslant c , b \geqslant c\)的情况，取模： \[ \begin{align*} h(a,b,c,n) =&amp; \sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor ^2\\ =&amp;\sum_{i=0}^n\lfloor \frac{(\lfloor \frac{a}{c} \rfloor c +a~{\rm mod}~ c)i+(\lfloor \frac{b}{c} \rfloor c+ b~{\rm mod}~c)}{c} \rfloor^2\\ =&amp;\sum_{i=0}^n\lfloor \lfloor\frac{a}{c}\rfloor i +\lfloor\frac{b}{c}\rfloor + \frac{(a~{\rm mod}~c)i+b~{\rm mod}~c}{2} \rfloor^2\\ =&amp;\sum_{i=0}^n(\lfloor \frac{a}{c} \rfloor i + \lfloor \frac{b}{c} \rfloor ) ^2 +2(\lfloor \frac{a}{c} \rfloor i + \lfloor \frac{b}{c} \rfloor )(\frac{(a~{\rm mod}~c)i+b~{\rm mod}~c}{2})\\ &amp;+(\frac{(a~{\rm mod}~c)i+b~{\rm mod}~c}{2})^2\\ =&amp;\sum_{i=0}^n[(i\lfloor \frac{a}{c} \rfloor)^2+2i\lfloor \frac{a}{c} \rfloor \lfloor \frac{b}{c} \rfloor + \lfloor \frac{b}{c} \rfloor ^2] + 2\lfloor \frac{a}{c} \rfloor g(a~{\rm mod}~c,b~{\rm mod}~c,c,n)\\ &amp;+2 \lfloor \frac{b}{c} \rfloor f(a~{\rm mod}~c,b~{\rm mod}~c,c,n)+h(a~{\rm mod}~c,b~{\rm mod}~c,c,n)\\ =&amp;\frac{n(2n+1)(n+1)}{6}\lfloor \frac{a}{c} \rfloor ^2 + n(n+1)\lfloor \frac{a}{c} \rfloor \lfloor \frac{b}{c} \rfloor +(n+1) \lfloor \frac{b}{c} \rfloor^2\\ &amp;+2\lfloor \frac{a}{c} \rfloor g(a~{\rm mod}~c,b~{\rm mod}~c,c,n)+2 \lfloor \frac{b}{c} \rfloor f(a~{\rm mod}~c,b~{\rm mod}~c,c,n)\\ &amp;+h(a~{\rm mod}~c,b~{\rm mod}~c,c,n)\\ \end{align*} \] 对于\(a &lt; c , b &lt; c\)的情况，由于平方不好处理，我们考虑将其变换形式： \[ n^2 \Leftrightarrow n^2+n-n \Leftrightarrow 2\frac{n(n+1)}{2}-n \Leftrightarrow (2\sum_{i=1}^ni)-n \] 那么 \[ \begin{align*} h(a,b,c,n)=&amp;\sum_{i=0}^n \lfloor \frac{ai+b}{c} \rfloor ^2\\ =&amp;\sum_{i=0}^n[(2\sum_{j=1}^{\lfloor \frac{ai+b}{c} \rfloor}j)-\lfloor \frac{ai+b}{c} \rfloor]\\ =&amp;(2\sum_{i=0}^n\sum_{j=1}^{\lfloor \frac{ai+b}{c} \rfloor}j)-f(a,b,c,n)\\ \end{align*} \] 令\(m= \lfloor \frac{an+b}{c} \rfloor\)，\(t=\lfloor \frac{cj+c-b-1}{a} \rfloor\)，则 \[ \begin{align*} \sum_{i=0}^n\sum_{j=1}^{\lfloor \frac{ai+b}{c} \rfloor}j =&amp; \sum_{i=0}^n \sum_{j=0}^{\lfloor \frac{ai+b}{c} \rfloor-1}(j+1)\\ =&amp;\sum_{j=0}^{m-1}(j+1)\sum_{i=0}^n (j&lt; \lfloor \frac{ai+b}{c} \rfloor)\\ =&amp;\sum_{j=0}^{m-1}(j+1)\sum_{i=0}^n(i&gt;t)\\ =&amp;\sum_{j=0}^{m-1}(j+1)(n-t)\\ =&amp;\frac{1}{2}nm(m+1) - \sum_{j=0}^{m-1}j\lfloor \frac{cj+c-b-1}{a} \rfloor-\sum_{j=0}^{m-1}\lfloor \frac{cj+c-b-1}{a} \rfloor\\ =&amp;\frac{1}{2}nm(m+1)-g(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1) \end{align*} \] 所以 \[ h(a,b,c,n)=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n) \] 综上所述， \[ \begin{align*} f(a,b,c,n)&amp;= \begin{cases} \lfloor\frac{a}{c} \rfloor\frac{n(n+1)}{2}+\lfloor \frac{b}{c} \rfloor(n+1)+f(a~{\rm mod}~c,b~{\rm mod}~c,c,n) &amp; {a \geqslant c,b \geqslant c}\\ n\lfloor\frac{an+b}{c}\rfloor -f(c,c-b-1,a,m-1) &amp; {a &lt; c,b &lt; c}\\ \end{cases}\\ g(a,b,c,n)&amp;= \begin{cases} g(a~{\rm mod}~c,b~{\rm mod}~c,c,n)+\frac{n(2n+1)(n+1)}{6} \lfloor \frac{a}{c} \rfloor +\frac{n(n+1)}{2} \lfloor \frac{b}{c} \rfloor &amp; {a \geqslant c,b \geqslant c}\\ \frac{1}{2}[mn(n+1) - h(c,c-b-1,a,m-1) - f(c,c-b-1,a,m-1)] &amp; {a&lt;c,b&lt;c}\\ \end{cases}\\ h(a,b,c,n)&amp;= \begin{cases} {\frac{n(2n+1)(n+1)}{6}\lfloor \frac{a}{c} \rfloor ^2 + n(n+1)\lfloor \frac{a}{c} \rfloor \lfloor \frac{b}{c} \rfloor +(n+1) \lfloor \frac{b}{c} \rfloor^2\\+2\lfloor \frac{a}{c} \rfloor g(a~{\rm mod}~c,b~{\rm mod}~c,c,n)+2 \lfloor \frac{b}{c} \rfloor f(a~{\rm mod}~c,b~{\rm mod}~c,c,n)\\+h(a~{\rm mod}~c,b~{\rm mod}~c,c,n)} &amp; {a \geqslant c , b\geqslant c}\\ {nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)\\-f(a,b,c,n)} &amp; {a&lt;c,b&lt;c} \end{cases} \end{align*} \] 在计算的时侯，因为\(3\)个函数各有交错递归，因此可以考虑三个一起整体递归，同步计算，否则有很多项会被多次计算。这样实现的复杂度是\(O(\log n)\)。 部分公式推导 \(\sum_{i=1}^{n} i^2 = \frac{n(n+1)(2n+1)}{6}\)的推导： 我们知道\(\sum_{i=1}^n i =\frac{n(n+1)}{2}\)，但是我们没法直接从一次硬推到二次，我们考虑先求取其它包含\(i^2\)的二次多项式，然后用其它项表示\(i^2\)。 我们找一个比较优美的式子，\((n+1)^3-n^3=n^3+3n^2+3n+1-n^3=3n^2+3n+1\)，我们考虑对它求和\(\sum_{i=1}^{n}(n+1)^3-n^3\)。 我们将项列出来： \[ \begin{align*} \sum_{i=1}^n (n+1)^3-n^3 &amp;=2^3-1^3+3^3-2^3+4^3-3^3+ \cdots +(n+1)^3-n^3\\ &amp;=(n+1)^3-1^3 \end{align*} \] 又由\((n+1)^3=3n^2+3n+1\)可得： \[ \sum_{i=1}^n(n+1)^3 = 3 \sum_{i=1}^n i^2 + 3 \frac{n(n+1)}{2} + n \] 综合两式可得： \[ (n+1)^3-1=3\sum_{i=1}^n i^2 + \frac{3n(n+1)}{2}+n \] 考虑\(\sum_{i=1}^ni^2\)是我们所要求的，所以将它设成\(x\)： \[ 2n^3+6n^2+6n=6x+3n^2+3n+2n\\ \begin{align*} x&amp;=\frac{2n^3+3n^2+n}{2}\\ &amp;=\frac{n(n+1)(2n+1)}{6}\\ \end{align*} \] PS：推完之后才知道必修教材里是有的，然而我没上课... 例题 [洛谷5170]类欧几里得算法 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int mod=998244353;const int inv2=499122177;const int inv6=166374059;struct node&#123; int f,g,h; node()&#123;f=g=h=0;&#125;&#125;;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;node calc(int a,int b,int c,int n)&#123; node ret; int ac=a/c,bc=b/c,n1=n+1,n21=n*2+1,m=(a*n+b)/c; if(!a)&#123; ret.f=bc*n1%mod; ret.g=n*n1%mod*inv2%mod*bc%mod; ret.h=n1*bc%mod*bc%mod; return ret; &#125; if(a&gt;=c||b&gt;=c)&#123; ret.f=(ac*n%mod*n1%mod*inv2%mod+bc*n1%mod)%mod; ret.g=(n*n21%mod*n1%mod*inv6%mod*ac%mod+n*n1%mod*inv2%mod*bc%mod)%mod; ret.h=((n*n21%mod*n1%mod*inv6%mod*ac%mod*ac%mod+n*n1%mod*ac%mod*bc%mod)%mod+n1*bc%mod*bc%mod)%mod; node tmp=calc(a%c,b%c,c,n); ret.f=(ret.f+tmp.f)%mod; ret.g=(ret.g+tmp.g)%mod; ret.h=(ret.h+((2*ac%mod*tmp.g%mod+2*bc%mod*tmp.f%mod)%mod+tmp.h)%mod)%mod; return ret; &#125;node tmp=calc(c,c-b-1,a,m-1); ret.f=(n*m%mod-tmp.f+mod)%mod; ret.g=inv2*(((m*n%mod*n1%mod-tmp.h+mod)%mod-tmp.f+mod)%mod)%mod; ret.h=(((n*m%mod*(m+1)%mod-2*tmp.g%mod+mod)%mod-2*tmp.f%mod+mod)%mod-ret.f+mod)%mod; return ret;&#125;signed main()&#123; int T=read(); while(T--)&#123; int n=read(),a=read(),b=read(),c=read(); node ans=calc(a,b,c,n); printf("%lld %lld %lld\n",ans.f,ans.h,ans.g); &#125; return 0;&#125;]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 65]]></title>
    <url>%2F2019%2F09%2F05%2FEducational-Codeforces-Round-65%2F</url>
    <content type="text"><![CDATA[比赛链接 Educational Codeforces Round 65 A. Telephone Number 题目大意 定义电话号码为以\(8\)开头，长度为\(11\)的号码，给定一个长度为\(n\)的串，问能否删去一些数字让其变成电话号码。 解题思路 很显然我们只需要找到第一个\(8\)然后判断它后面还有没有\(10\)个数字以上就行了。 参考代码 12345678910111213141516171819202122232425262728293031323334/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=1e2+10;char s[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int T=read(); while(T--)&#123; int n=read();scanf("%s",s+1);bool flag=0; for(int i=1;i&lt;=n;i++) if(s[i]=='8'&amp;&amp;n-i+1&gt;=11)&#123;flag=1;break;&#125; puts(flag?"YES":"NO"); &#125; return 0;&#125; B. Lost Numbers 题目大意 交互题。 有一个长度为\(6\)的由\(\{4,8,15,16,23,42\}\)排列组成的序列，你每次可以询问任意一对下标\((i,j)\)的数的积，问能否在\(4\)次询问以内得到这个序列。 解题思路 考虑到它们两两的积不同，于是我们可以先预处理出来两两的积，然后询问四次，每次询问\((1,2)\)和另外的四个数，然后暴力查询对应的是哪两个位置的积，统计位置出现的次数，那么出现次数最多的数就是位置\(1\)的数字了。然后其他四个数字一一还原，最后剩下的数字就是剩下没有询问过的位置上的数了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;int a[7]=&#123;0,4,8,15,16,23,42&#125;;int ans[10],f[10][10],cnt[10],x[10],y[10],F[10];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void query(int x)&#123;printf("? %lld %lld\n",1ll,x);fflush(stdout);&#125;signed main()&#123; for(int i=1;i&lt;=6;i++)for(int j=1;j&lt;=6;j++)f[i][j]=a[i]*a[j]; int tot=0; for(int i=2;i&lt;=5;i++)&#123; query(i);int now=read(); for(int j=1;j&lt;=6;j++)&#123; bool flag=0; for(int k=1;k&lt;=6;k++) if(now==f[j][k])&#123;x[++tot]=j;y[tot]=k;flag=1;&#125; if(flag)break; &#125; &#125;//for(int i=1;i&lt;=tot;i++)printf("%lld %lld\n",x[i],y[i]); for(int i=1;i&lt;=tot;i++)cnt[x[i]]++,cnt[y[i]]++; for(int i=1;i&lt;=6;i++)if(cnt[i]&gt;1)ans[1]=i,F[i]=1; for(int i=1;i&lt;=tot;i++)&#123; if(x[i]!=ans[1])ans[i+1]=x[i],F[x[i]]=1; else ans[i+1]=y[i],F[y[i]]=1; &#125;for(int i=1;i&lt;=6;i++)if(!F[i])ans[6]=i;printf("!"); for(int i=1;i&lt;=6;i++)printf(" %lld",a[ans[i]]);puts(""); return 0;&#125; C. News Distribution 题目大意 有\(n\)个人，\(m\)个组，一个人可以在多个组内，给定组内的成员。已知如果一人知道了一个新消息，那么他会将消息传递给他所在的所有组的其他所有成员，对每个人求解以其作为第一个知道消息的人，他能将消息传递给多少人。 解题思路 并查集裸题。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=5e5+10;int a[maxn],uset[maxn],size[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void init()&#123;for(int i=1;i&lt;maxn;i++)uset[i]=i;&#125;int find(int x)&#123;return x==uset[x]?uset[x]:uset[x]=find(uset[x]);&#125;signed main()&#123; int n=read(),m=read();init(); for(int i=1;i&lt;=m;i++)&#123; int cnt=read(); for(int j=1;j&lt;=cnt;j++)a[j]=read(); for(int j=2;j&lt;=cnt;j++)&#123; int x=a[1],y=a[j]; uset[find(x)]=uset[find(y)]; &#125; &#125;for(int i=1;i&lt;=n;i++)size[find(i)]++; for(int i=1;i&lt;=n;i++)printf("%lld ",size[find(i)]);puts(""); return 0;&#125; D. Bicolored RBS 题目大意 给定一个括号序列，现在要你将这些括号分成两组，保证两组都是合法的括号序列，且让两组中最大的嵌套深度最小。 解题思路 枚举每一位，分别统计当前两组的嵌套深度，如果当前的是左括号，那么就将其分到嵌套深度最小的一组，否则就分到嵌套深度最大的一组。 参考代码 12345678910111213141516171819202122232425262728293031323334353637/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int maxn=2e5+10;char s[maxn];int ans[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int n=read(),cnt1=0,cnt2=0;scanf("%s",s+1); for(int i=1;i&lt;=n;i++)&#123; if(s[i]=='(')&#123; if(cnt1&lt;=cnt2)cnt1++,ans[i]=0ll; else cnt2++,ans[i]=1ll; &#125;else &#123; if(cnt1&gt;=cnt2)cnt1--,ans[i]=0ll; else cnt2--,ans[i]=1ll; &#125; &#125;for(int i=1;i&lt;=n;i++)printf("%lld",ans[i]);puts(""); return 0;&#125; E. Range Deleting 题目大意 给定一个长度为\(n\)的序列，其中\(a_i \leqslant x\)。定义\(f(l,r)\)为删除\(a\)中权值在\([l,r]\)的数后剩下的数，统计满足\(1 \leqslant l \leqslant r \leqslant x\)且\(f(l,r)\)是不下降序列的数对\((l,r)\)的个数。 解题思路 很显然\(l\)和\(r\)具有单调性。 我们将序列拆成权值在\([1,l)\)和\((r,x]\)的两段，那么如果要使\((l,r)\)满足条件，那么权值\([1,l)\)的数按照权值从小到大排序之后对应的原数组下标要递增，\((r,x]\)这一段也是这样，同时还满足前一段的最大坐标要小于后一段的最小坐标。 那么我们处理出\(mnpos_i\)和\(mxpos_i\)，分别表示权值为\(i\)的数出现的最小的位置和最大的位置，\(premx_i\)和\(nxtmx_i\)分别表示排序后\(1\)到\(i\)的最大下标和\(i\)到\(x\)的最小下标。 然后根据处理出的这几个数组去处理\(pre_i\)和\(nxt_i\)，分别表示\(1\)到\(i\)这一段是否合法和\(i\)到\(x\)这一段是否合法，然后用\(two~pointer\)去求解答案，\(O(1)\)判断区间是否合法。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int inf=1e9;const int maxn=1e6+10;int a[maxn],mnpos[maxn],mxpos[maxn],premx[maxn],nxtmx[maxn],pre[maxn],nxt[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;bool check(int l,int r)&#123; if(!pre[l-1])return 0; if(!nxt[r+1])return 0; if(nxtmx[r+1]&lt;premx[l-1])return 0; return 1;&#125;signed main()&#123; int n=read(),x=read(); memset(mnpos,63,sizeof(mnpos)); for(int i=1;i&lt;=n;i++)a[i]=read(); for(int i=1;i&lt;=n;i++)&#123; mnpos[a[i]]=min(mnpos[a[i]],i); mxpos[a[i]]=max(mxpos[a[i]],i); &#125;premx[0]=0;nxtmx[x+1]=inf; for(int i=1;i&lt;=x;i++)premx[i]=max(premx[i-1],mxpos[i]); for(int i=x;i&gt;=1;i--)nxtmx[i]=min(nxtmx[i+1],mnpos[i]); pre[0]=nxt[x+1]=1; for(int i=1;i&lt;=x;i++)pre[i]=pre[i-1]&amp;&amp;(premx[i-1]&lt;mnpos[i]); for(int i=x;i&gt;=1;i--)nxt[i]=nxt[i+1]&amp;&amp;(nxtmx[i+1]&gt;mxpos[i]); int l=1,r=1,ans=0; while(l&lt;=x)&#123; if(l&gt;r)r++; while(r&lt;x&amp;&amp;!check(l,r))r++; if(check(l,r))ans+=x-r+1;l++; &#125;write(ans); return 0;&#125; F. Scalar Queries 题目大意 给出一个数组\(a_1,a_2,...,a_n\)，其中所有元素两两不同。 定义函数\(f(l,r)\)： 定义数组\(b_1,b_2,...,b_{r-l+1}\)，其中\(b_i=a_{l-1+i}\) 将\(b\)按从小到大排序 则此时函数的值是\(\sum\limits_{i=1}^{r-l+1}{b_i}\cdot i\) 请计算对于所有满足\(1 \leqslant l \leqslant r \leqslant n\)的\(l\)和\(r\)，\(f(l,r)\)的和。 由于结果可能很大，请输出对\(10^9+7\)取模的值。 解题思路 考虑每个数字对答案的贡献： \(a_i\)的贡献为\((n-i+1) \times j \times a_i\)。 在\(a_i\)左边的比它小的数\(a_j\)的贡献为\((n−i+1) \times j \times a_i\)。 在\(a_i\)右边的比它小的数\(a_j\)的贡献为\(i \times (n−j+1) \times a_i\)。 将所有贡献加起来即为答案，然后按排序后的下标建树状数组，维护原下标前缀和，边更新边加答案。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748*Program from Luvwgyx*/#include&lt;map&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long longusing namespace std;const int mod=1e9+7;const int maxn=5e5+10;int n,a[maxn],b[maxn],cnt[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;struct Binary_Indix_Tree&#123; int tree[maxn]; void clear()&#123;memset(tree,0,sizeof(tree));&#125; void change(int x,int v)&#123;for(;x&lt;=n;x+=(x&amp;(-x)))tree[x]+=v;&#125; int query (int x)&#123;int ret=0;for(;x;x-=(x&amp;(-x)))ret+=tree[x];return ret;&#125;&#125;T;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=b[i]=read(); sort(b+1,b+n+1); for(int i=1;i&lt;=n;i++)a[i]=lower_bound(b+1,b+n+1,a[i])-b; for(int i=1;i&lt;=n;i++)&#123; cnt[i]=(cnt[i]+T.query(a[i])*(n-i+1)%mod)%mod; T.change(a[i],i); &#125;for(int i=1;i&lt;=n;i++)cnt[i]=(cnt[i]+i*(n-i+1)%mod)%mod;T.clear(); for(int i=n;i&gt;=1;i--)&#123; cnt[i]=(cnt[i]+T.query(a[i])*i%mod)%mod; T.change(a[i],n-i+1); &#125;int ans=0; for(int i=1;i&lt;=n;i++)ans=(ans+cnt[i]*b[a[i]]%mod)%mod; write(ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ1003][ZJOI2006]物流运输]]></title>
    <url>%2F2019%2F09%2F03%2FBZOJ1003-ZJOI2006-%E7%89%A9%E6%B5%81%E8%BF%90%E8%BE%93%2F</url>
    <content type="text"><![CDATA[题目链接 BZOJ 洛谷 解题思路 设\(f_i\)表示到第\(i\)天，最小的总成本是多少，那么转移也就很简单了： \[ f_i=f_j+dis \times (i-j+1)+K \] 其中\(dis\)为\(1\)到\(m\)的最短路。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*Program from Luvwgyx*/#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define fir first#define sec second#define pi pair&lt;int ,int &gt;#define mp(x,y) make_pair(x,y)using namespace std;const int inf=1e9;const int maxn=1e2+10;const int maxm=1e4+10;struct node&#123;int to,nxt,w;&#125;e[maxm&lt;&lt;1];int n,m,K,E,tot,f[maxn],use[maxn],dis[maxn],head[maxn],fas[maxn][maxn];bool vis[maxn];priority_queue&lt;pi &gt;q;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void add(int u,int v,int w)&#123;e[++tot].to=v;e[tot].w=w;e[tot].nxt=head[u];head[u]=tot;&#125;void dijkstra(int S)&#123; memset(vis,0,sizeof(vis)); memset(dis,63,sizeof(dis)); dis[S]=0;q.push(mp(0,S)); while(q.size())&#123; int x=q.top().sec;q.pop(); if(vis[x])continue;vis[x]=1; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(dis[v]&gt;dis[x]+e[i].w&amp;&amp;!use[v])&#123; dis[v]=dis[x]+e[i].w; q.push(mp(-dis[v],v)); &#125; &#125;&#125;int main()&#123; n=read();m=read();K=read();E=read(); for(int i=1;i&lt;=E;i++)&#123; int u=read(),v=read(),w=read(); add(u,v,w);add(v,u,w); &#125;int Q=read(); for(int i=1;i&lt;=Q;i++)&#123; int x=read(),l=read(),r=read(); for(int j=l;j&lt;=r;j++)fas[j][x]=1; &#125;memset(f,63,sizeof(f));f[0]=-K; for(int i=1;i&lt;=n;i++)&#123; memset(use,0,sizeof(use)); for(int j=i;j&gt;=1;j--)&#123; for(int k=1;k&lt;=m;k++)if(fas[j][k])use[k]=1; dijkstra(1);int ret=dis[m]; if(ret&gt;inf)break; f[i]=min(f[i],f[j-1]+(i-j+1)*ret+K); &#125; &#125;write(f[n]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ1084][SCOI2005]最大子矩阵]]></title>
    <url>%2F2019%2F09%2F03%2FBZOJ1084-SCOI2005-%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目链接 BZOJ 洛谷 解题思路 考虑\(\rm DP\)，设\(f_{i,j,k}\)表示第一列取了前\(i\)个，第二列取了前\(j\)个，选了\(k\)个子矩阵的最大分值和。 转移就比较显然了： 两边都不取，\(f_{i,j,k}=max(f_{i-1,j,k},f_{i,j-1,k})\) 取第一列，\(f_{i,j,k}=f_{l,j,k-1}+sum_{1,i}-sum_{1,l}(0&lt;l&lt;i)\) 取第二列，\(f_{i,j,k}=f_{i,l,k-1}+sum_{2,j}-sum_{2,l}(0&lt;l&lt;j)\) 取第一列和第二列构成的矩阵，\(f_{i,j,k}=f_{l,l,k-1}+sum_{1,i}-sum_{1,l}+sum_{2,j}-sum_{2,l}(i=j,0&lt;l&lt;i)\) 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e2+10;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;int n,m,K,a[maxn][3],sum[3][maxn],g[maxn][20],f[maxn][maxn][20];int main()&#123; n=read();m=read();K=read(); for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)a[i][j]=read(); for(int i=1;i&lt;=m;i++)for(int j=1;j&lt;=n;j++)sum[i][j]=sum[i][j-1]+a[j][i]; if(m==1)&#123; for(int k=1;k&lt;=K;k++) for(int i=1;i&lt;=n;i++)&#123; g[i][k]=g[i-1][k]; for(int j=0;j&lt;i;j++)g[i][k]=max(g[i][k],g[j][k-1]+sum[1][i]-sum[1][j]); &#125; write(g[n][K]); &#125;else &#123; for(int k=1;k&lt;=K;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; f[i][j][k]=max(f[i-1][j][k],f[i][j-1][k]); for(int l=0;l&lt;i;l++)f[i][j][k]=max(f[i][j][k],f[l][j][k-1]+sum[1][i]-sum[1][l]); for(int l=0;l&lt;j;l++)f[i][j][k]=max(f[i][j][k],f[i][l][k-1]+sum[2][j]-sum[2][l]); if(i==j)for(int l=0;l&lt;i;l++)f[i][j][k]=max(f[i][j][k],f[l][l][k-1]+sum[1][i]-sum[1][l]+sum[2][i]-sum[2][l]); &#125; write(f[n][n][K]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ2326][HNOI2011]数学作业]]></title>
    <url>%2F2019%2F09%2F02%2FBZOJ2326-HNOI2011-%E6%95%B0%E5%AD%A6%E4%BD%9C%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[题目链接 BZOJ 洛谷 解题思路 设第\(i\)个数为\(f_i\)，那么我们可以得到一个转移方程： \[ f_i=f_{i-1} \times 10^{\lfloor \lg i \rfloor} +i \] 这个题的范围很大，显然是要我们用\(\log\)级别复杂度的算法来解决的。我们考虑怎么用矩阵乘法来优化转移： \[ \left[ \begin{matrix} f_{i-1} &amp; i-1 &amp; 1\\ \end{matrix} \right] \left[ \begin{matrix} 10^{\lfloor \lg i \rfloor} &amp; 1 &amp; 1\\ 1 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 0\\ \end{matrix} \right] \] 注意到\(10 ^ {\lfloor \lg i \rfloor}\)是不断变化的，考虑\(\lg i\)不会很大，所以我们可以直接枚举，然后用矩阵快速幂优化转移。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*Program from Luvwgyx*/#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define sqr(x) ((x)*(x))#define int long longusing namespace std;int n,mod;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;struct Matrix&#123; int a[4][4]; Matrix()&#123;memset(a,0,sizeof(a));&#125; void init()&#123; memset(a,0,sizeof(a)); for(int i=1;i&lt;4;i++)a[i][i]=1; &#125;&#125;now,init;Matrix mul(Matrix a,Matrix b)&#123; Matrix c; for(int i=1;i&lt;4;i++) for(int j=1;j&lt;4;j++) for(int k=1;k&lt;4;k++) c.a[i][j]=(c.a[i][j]+1ll*a.a[i][k]*b.a[k][j]%mod)%mod; return c;&#125;Matrix power(Matrix a,int b)&#123; Matrix ret;ret.init(); for(;b;b&gt;&gt;=1,a=mul(a,a)) if(b&amp;1)ret=mul(ret,a); return ret;&#125;int get(int x)&#123;int ret=0;while(x)x/=10,ret++;return ret;&#125;int cal(int x)&#123;int ret=1;for(int i=1;i&lt;=x;i++)ret=ret*10;return ret;&#125;signed main()&#123; n=read();mod=read();int len=get(n); init.a[1][1]=init.a[1][2]=init.a[1][3]=1; now.a[2][1]=now.a[3][1]=now.a[2][2]=now.a[3][2]=now.a[3][3]=1; for(int i=0;i&lt;len-1;i++)&#123; now.a[1][1]=cal(i+1)%mod; int m=cal(i+1)-cal(i)-(i==0); init=mul(init,power(now,m)); &#125;int m=n-cal(len-1)-(len-1==0)+1;now.a[1][1]=cal(len)%mod; init=mul(init,power(now,m));write(init.a[1][1]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BZOJ3675][Apio2014]序列分割]]></title>
    <url>%2F2019%2F09%2F02%2FBZOJ3675-Apio2014-%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[题目链接 BZOJ 洛谷 解题思路 首先考虑分割顺序对于答案的影响。 设当前的序列为\(a~b~c~d\)，我们考虑从前往后分割与从后往前分割，比较最后的答案： \(a(b+c+d)+b(c+d)+cd=ab+ac+ad+bc+bd+cd\) \(d(a+b+c)+c(a+b)+ab=ad+bd+cd+ac+bc+ab\) 比较一下，发现答案是相同的，推广一下可以得知分割的先后顺序对答案是没有影响的。 我们设\(f_{i,j}\)表示前\(i\)个数分割了\(j\)次能获得的最大的得分，那么就有如下转移（其中\(sum_x\)表示第\(x\)个位置的前缀和）： \[ f_{i,j}=\max_{0&lt;k&lt;i}\{f_{k,j-1}+sum_k\times(sum_i-sum_k)\} \] 为什么当前转移的贡献是\(sum_k \times (sum_j-sum_k)\)呢？因为顺序对答案并不造成影响，所以当前这个位置最大的贡献应该是第\(k\)个位置被第一个切割所产生的贡献的最大值。 我们发现转移只与上一维相关，所以我们可以滚动数组优化。我们记\(f_{i,j}\)为\(F_i\)，\(f_{k,j-1}\)为\(G_k\)，那么方程变为： \[ F_i=\max_{0&lt;k&lt;j}\{G_k+sum_k\times(sum_i-sum_k)\} \] 考虑斜率优化，我们任取\(i\)之前的两个位置\(x\)和\(y\)且满足\(x&lt;y\)并且取\(y\)较之取\(x\)答案更优，那么： \[ G_y+sum_y\times(sum_i-sum_y) \geqslant G_x+sum_x \times (sum_i-sum_x) \] 变换一下形式可得； \[ \frac{(g_y-sum_y^2)-(g_x-sum_x^2)}{sum_x-sum_y} \geqslant sum_i \] 因此我们维护一下下凸壳就可以了。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738/*Program from Luvwgyx*/#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define sqr(x) ((x)*(x))#define int long long#define write(x) printf("%lld\n",x)using namespace std;const int inf=1e18;const int maxn=1e5+10;const int maxm=2e2+10;int n,K,a[maxn],f[maxn],g[maxn],sum[maxn],q[maxn],pre[maxn][maxm];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;double calc(int x,int y)&#123; if(sum[x]==sum[y])return -inf; return 1.0*((g[x]-sqr(sum[x]))-(g[y]-sqr(sum[y])))/(sum[y]-sum[x]);&#125;signed main()&#123; n=read();K=read(); for(int i=1;i&lt;=n;i++)a[i]=read(),sum[i]=sum[i-1]+a[i]; for(int j=1;j&lt;=K;j++)&#123; int l=1,r=0;q[++r]=0; for(int i=1;i&lt;=n;i++)&#123; while(l&lt;r&amp;&amp;calc(q[l],q[l+1])&lt;=sum[i])l++; f[i]=g[q[l]]+sum[q[l]]*(sum[i]-sum[q[l]]);pre[i][j]=q[l]; while(l&lt;r&amp;&amp;calc(q[r-1],q[r])&gt;=calc(q[r],i))r--;q[++r]=i; &#125;memcpy(g,f,sizeof(f)); &#125;write(f[n]);int pos=n; for(int i=K;i&gt;=1;i--)pos=pre[pos][i],printf("%lld ",pos);puts(""); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 66]]></title>
    <url>%2F2019%2F09%2F01%2FEducational-Codeforces-Round-66%2F</url>
    <content type="text"><![CDATA[比赛链接 Educational Codeforces Round 66 A. From Hero to Zero 题目大意 给定\(n\)和\(k\)，你可以进行两种操作： 将\(n\)减一。 将\(n\)除以\(k\)。 现在你要将\(n\)变成\(0\)，问最小的操作次数。 解题思路 很显然，如果\(n|k\)，那么将\(n\)除以\(k\)显然比一个一个减更优\(k&gt;1\)，所以如果当前\(n|k\)，那么就除，否则就一个一个减。 参考代码 12345678910111213141516171819202122232425262728/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int T=read(); while(T--)&#123; int n=read(),k=read(),ans=0; if(k==1)&#123;write(n);continue;&#125; while(n&gt;0)&#123; if(n%k)ans+=n%k,n-=n%k; while(!(n%k)&amp;&amp;n&gt;0)n/=k,ans++; &#125;write(ans); &#125; return 0;&#125; B. Catch Overflow! 题目大意 你有一个数\(x\)，\(x\)开始的值为\(0\)，读入\(l\)个操作，总共有三种： \(\rm for~n\) 从\(1\)到\(n\)的循环 \(\rm end\) 结束最近的一个循环（相当于是大括号） \(\rm add\) 给\(x\)加上\(1\) 现在要你给出这些操作后\(x\)的值，保证操作合法，如果在计算过程中\(x\)的值超过了\(2^{32}-1\)，输出OVERFLOW!!!。 解题思路 显然，开一个栈模拟就好了，细节问题自己考虑。 参考代码 12345678910111213141516171819202122232425262728293031/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int maxn=1e5+10;char s[10];int top,sta[maxn],ret[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;signed main()&#123; int n=read(),ans=0,sum=0,flag=0,inf=pow(2,32)-1; for(int i=1;i&lt;=n;i++)&#123; scanf("%s",s); if(s[0]=='f')sta[++top]=read(),ret[top]=0; if(s[0]=='a')&#123;if(top)ret[top]++;else ans++;&#125; if(s[0]=='e')&#123; sum=sta[top]*ret[top]; sta[top--]=0;ret[top]+=sum; &#125;if(ans+ret[top]&gt;inf)&#123;puts("OVERFLOW!!!");flag=1;break;&#125; &#125;if(!flag)&#123;if(ans+ret[0]&gt;inf)puts("OVERFLOW!!!");else write(ans+ret[0]);&#125; return 0;&#125; C. Electrification 题目大意 在数轴上有\(n\)个点\(a_1,a_2,\cdots,a_n\)，\(a\)数组保证从小到大排列，给定\(k\)，现在要你找出一个点\(x\)，使得\(f_k(x)\)最小。 \(f_k(x)\)的定义如下：将给定的\(n\)个点与\(x\)的距离列出来，从小到大排序后第\(k+1\)个数就是\(f_k(x)\)的值。 解题思路 很显然我们只需要在长度为\(k\)的区间中找到最大值和最小值差值最小的那个就行了。 参考代码 12345678910111213141516171819202122232425262728293031/*Program from Luvwgyx*/#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long long#define write(x) printf("%lld\n",x)using namespace std;const int inf=1e18;const int maxn=2e5+10;int a[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;signed main()&#123; int T=read(); while(T--)&#123; int n=read(),k=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); int mn=inf,pos=0; for(int i=k+1;i&lt;=n;i++)&#123; int mid=(a[i-k]+a[i])/2,mx=max(mid-a[i-k],a[i]-mid); if(mx&lt;mn)mn=mx,pos=mid; &#125;write(pos); &#125; return 0;&#125; D. Array Splitting 题目大意 给定一个长度为\(n\)的序列\(a\)，现在要你将其分成\(K\)段，第\(i\)个点的贡献为\(a_i \times f(i)\)，其中\(f(x)\)表示\(x\)在第几段。 解题思路 我们有一个很巧妙的思路，我们先将所有的数都选\(K\)遍，然后不断地删除。 我们将每个位置的前缀和都求出来，然后取从小到大前\(K-1\)个前缀，将他们从答案中减去，最开始的答案自然是所有元素的和\(\times K\)。 参考代码 123456789101112131415161718192021222324/*Program from Luvwgyx*/#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long long#define write(x) printf("%lld\n",x)using namespace std;const int maxn=3e5+10;int a[maxn],sum[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;signed main()&#123; int n=read(),k=read(); for(int i=1;i&lt;=n;i++)a[i]=read(),sum[i]=sum[i-1]+a[i]; int ans=sum[n]*k;sort(sum+1,sum+n); for(int i=1;i&lt;k;i++)ans-=sum[i];write(ans); return 0;&#125; E. Minimal Segment Cover 题目大意 给定\(n\)个线段\([l,r]\)，覆盖着数轴上的点，现在需要回答\(m\)个询问，对于每个询问有一个区间\([x,y]\)，要求最少需要多少个线段能覆盖这个区间内的所有点。 解题思路 我们考虑\(DP\)，设\(f_{i,j}\)表示对于第\(i\)个点，用\(2^j\)条线段最多能覆盖到哪个点，然后对于每个询问都去分割一遍就可以了。 参考代码 12345678910111213141516171819202122232425262728293031323334/*Program from Luvwgyx*/#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long long#define write(x) printf("%lld\n",x)using namespace std;const int maxn=1e6+10;int n,m,f[maxn][23];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;int query(int l,int r)&#123; int ret=0; for(int i=22;i&gt;=0;i--) if(f[l][i]&lt;r)l=f[l][i],ret+=(1&lt;&lt;i); l=f[l][0];ret++; return l&lt;r?-1:ret;&#125;signed main()&#123; n=read();m=read();int mx=0; for(int i=1;i&lt;=n;i++)&#123; int l=read()+1,r=read()+1; f[l][0]=max(f[l][0],r);mx=max(mx,r); &#125;for(int i=1;i&lt;=mx;i++)f[i][0]=max(f[i][0],max(i,f[i-1][0])); for(int j=1;j&lt;23;j++)for(int i=1;i&lt;=mx;i++)f[i][j]=f[f[i][j-1]][j-1]; while(m--)&#123;int l=read()+1,r=read()+1;write(query(l,r));&#125; return 0;&#125; F. The Number of Subpermutations 题目大意 给定一个长度为\(n\)的序列，定义一段连续的子序列\([l,r]\)是好的，当且仅当\(a_l,a_{l+1},...a_r\)中\(1\)到\(r-l+1\)这些数出现且仅出现一次。现在需要知道这个序列中有多少个子序列是好的。 解题思路 我们可以将原题意转化一下，就变成了两个约束条件： 区间\([l,r]\)中的每个数都只出现了一次 区间内的数的最大值为\(r-l+1\) 我们先考虑如何找出满足第一个约束条件的子序列。 我们从后往前扫这个序列，用\(nxt_i\)表示以第\(i\)个点为左端点，往右最多能走到哪个位置，使得这个位置到\(i\)位置中间的数都只出现了一次。再令\(pos_i\)表示数\(i\)最新出现的位置，那么\(nxt_i=\min(nxt_{i+1},pos_{a_i})\)。 我们再考虑如何满足第二个约束条件。 我们枚举区间的左端点\(i\)，然后枚举区间的右端点\(j \in [i,nxt_i-1]\)，每次判断区间\([i,j]\)的最大值是否\(&gt;r\)，如果是则更新\(j\)到\(i+mx\)就行了。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*Program from Luvwgyx*/#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define int long long#define write(x) printf("%lld\n",x)using namespace std;const int maxn=3e5+10;int n,a[maxn],pos[maxn],nxt[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct Segment_Tree&#123; int tree[maxn&lt;&lt;2]; void update(int k)&#123;tree[k]=max(tree[k&lt;&lt;1],tree[k&lt;&lt;1|1]);&#125; void build(int k,int l,int r)&#123; if(l==r)&#123;tree[k]=a[l];return ;&#125; int mid=(l+r)&gt;&gt;1; build(k&lt;&lt;1,l,mid); build(k&lt;&lt;1|1,mid+1,r); update(k); &#125; int query(int k,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;r&lt;=y)return tree[k]; int mid=(l+r)&gt;&gt;1,ret=0; if(x&lt;=mid)ret=max(ret,query(k&lt;&lt;1,l,mid,x,y)); if(mid&lt;y)ret=max(ret,query(k&lt;&lt;1|1,mid+1,r,x,y)); return ret; &#125;&#125;T;signed main()&#123; n=read();int ans=0; for(int i=1;i&lt;=n;i++)a[i]=read(),pos[i]=n+1; T.build(1,1,n);nxt[n+1]=n+1; for(int i=n;i&gt;=1;i--)&#123; nxt[i]=min(nxt[i+1],pos[a[i]]);pos[a[i]]=i; for(int j=i;j&lt;nxt[i];j++)&#123; int x=T.query(1,1,n,i,j); if(i+x-1&gt;j)j=i+x-2;else ans++; &#125; &#125;write(ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 5 1008]line symmetric]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-5-1008-line-symmetric%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 二维平面上有一个\(n\)个点的简单多边形，问能否改变一个点的坐标使其变成轴对称的简单多边形，点的连接顺序不改变，轴对称指图形对称。 解题思路 由于我计算几何太菜，所以直接用直线的一般式来写的这题... 我们先枚举相邻的点，以它们的垂直平分线作为对称轴，然后用两个指针\(l\)和\(r\)分别向两边枚举对称的点，将它们的直线解析式求出来，然后与对称轴比较，看是否被垂直平分，如果没有则这组不对称。由于我们并不关心改点的坐标到哪里去，所以我们只需要标记使用过修改次数了，如果后面又扫到了不对称的点，那么这个对称轴就不行，需要接着枚举下去。 最基本的做完了之后，我们发现如果最开始枚举来得到对称轴的点对所在的直线如果是平行于\(x\)轴或者\(y\)轴的话，我们是不好通过将点的坐标代入解析式来判断是否该点在这条直线上的，所以我们需要特判这种情况。 接着我们考虑一下这种“生草图”，注意到如果是按照我们之前的做法来判断这个图的话，会判断成能变成轴对称图形，我们发现坐标为\((7,4)\)的点可以移到点\((1,1)\)和\((4,2)\)所构成的直线的下面来与点\((0,0)\)对称。而这种移法是不合法的，因为移动之后图形并不是简单多边形了，我们需要特判这种移动之后不是简单多边形的情况。 我们可以用叉积来做这件事。我们设\((7,4)\)为\(a\)，\((0,0)\)为\(b\)，\((1,1)\)为\(x\)，\((4,2)\)为\(y\)，\(b\)关于对称轴对称的点为\(c\)，通过判断\(\vec {ax} \times \vec{ay}\)与\(\vec{cx} \times \vec{cy}\)的正负性是否相同来判断是否合法，然后我把如果是合法的对称情况满足的性质都判了一遍，这样就过了..... 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;#define sqr(x) ((x)*(x))using namespace std;const int maxn=2e3+10;double eps=1e-12;struct node&#123;double x,y;&#125;a[maxn];struct line&#123;double A,B,C;&#125;;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void Write(line x)&#123;printf("%.4lf %.4lf %.4lf\n",x.A,x.B,x.C);&#125;void Write1(node x)&#123;printf("%.4lf %.4lf\n",x.x,x.y);&#125;line calc(node x,node y)&#123; double A=y.y-x.y; double B=x.x-y.x; double C=y.x*x.y-x.x*y.y; return (line)&#123;A,B,C&#125;;&#125;node get_sym(node x,line y)&#123; int xx=((sqr(y.B)-sqr(y.A))*x.x-2*y.A*y.B*x.y-2*y.A*y.C); int yy=((sqr(y.A)-sqr(y.B))*x.y-2*y.A*y.B*x.x-2*y.B*y.C); return (node)&#123;xx/(sqr(y.A)+sqr(y.B)),yy/(sqr(y.A)+sqr(y.B))&#125;;&#125;bool pd(double x,double y)&#123;return fabs(x-y)&lt;eps;&#125;bool check(line x,line y)&#123;return pd(x.A,y.A)&amp;&amp;pd(x.B,y.B)&amp;&amp;pd(x.C,y.C);&#125;bool pdcz(line x,line y)&#123;return x.A*y.A+x.B*y.B==0;&#125;bool Check(node x,line y)&#123;return y.A*x.x+y.B*x.y+y.C==0;&#125;bool pdpx(line x,line y)&#123;return x.A*y.B-y.A*x.B==0;&#125;int zf(double x)&#123;if(pd(x,0.0))return 0;if(x&lt;0)return -1;else return 1;&#125;double get(node a1,node a2,node b1,node b2)&#123;return (a2.x-a1.x)*(b2.y-b1.y)-(b2.x-b1.x)*(a2.y-a1.y);&#125;bool pdch(line x,line y)&#123;return x.A/y.A==x.B/y.B&amp;&amp;x.A/y.A==x.C/y.C&amp;&amp;x.B/y.B==x.C/y.C;&#125;bool CHeck(node x,node y,line std,node xx,node yy)&#123; node symm=get_sym(xx,std); if(zf(get(x,xx,x,y))!=zf(get(x,symm,x,y)))return 0; if(zf(get(y,xx,y,x))!=zf(get(y,symm,y,x)))return 0; if(zf(get(xx,x,xx,y))!=zf(get(yy,x,yy,y)))return 0; if(zf(get(xx,x,xx,y))!=zf(get(symm,x,symm,y)))return 0; if(zf(get(xx,yy,xx,y))!=zf(get(xx,symm,xx,y)))return 0; if(zf(get(xx,yy,xx,x))!=zf(get(xx,symm,xx,x)))return 0; return 1;&#125;int main()&#123; //freopen("1008.in","r",stdin); //freopen("1008.out","w",stdout); int T=read(); while(T--)&#123; int n=read(); for(int i=1;i&lt;=n;i++)scanf("%lf%lf",&amp;a[i].x,&amp;a[i].y); if(n&lt;=4)&#123;puts("Y");continue;&#125;bool flagg=0; for(int i=1;i&lt;=n;i++)&#123; int xx=i,yy=i==n?1:i+1;line std=calc(a[xx],a[yy]); node mid=(node)&#123;(a[xx].x+a[yy].x)/2,(a[xx].y+a[yy].y)/2&#125;; line vert=(line)&#123;std.B,-std.A,std.A*mid.y-std.B*mid.x&#125;; int l=(xx-1)?(xx-1):n,r=(yy+1==n+1)?1:yy+1; bool opt1=0,opt2=0; if(a[xx].y==a[yy].y)opt1=1; if(a[xx].x==a[yy].x)opt2=1; bool flag=0,Flag=0; while(1)&#123; line Std=calc(a[l],a[r]); node Mid=(node)&#123;(a[l].x+a[r].x)/2,(a[l].y+a[r].y)/2&#125;; if(Check(a[l],vert)&amp;&amp;Check(a[r],vert))&#123;Flag=1;break;&#125; if(opt1||opt2)&#123; if(opt1)&#123; if(a[l].y!=a[r].y)&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125;else &#123; if(a[l].x!=a[r].x)&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125; &#125;else &#123; if(!pdpx(std,Std))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125; int ll=(l-1)?(l-1):n,rr=(r+1==n+1)?1:r+1; if(ll==rr)&#123; if(!Check(a[ll],vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)Flag=1;else flag=1; &#125;break; &#125;else if(ll==r&amp;&amp;rr==l)break; l=ll;r=rr; &#125;if(!Flag)&#123;puts("Y");flagg=1;break;&#125; &#125;if(!flagg)&#123; for(int i=1;i&lt;=n;i++)&#123; int xx=i,yy=(i+2&lt;=n)?i+2:((i+2)%n);line std=calc(a[xx],a[yy]); node mid=(node)&#123;(a[xx].x+a[yy].x)/2,(a[xx].y+a[yy].y)/2&#125;; line vert=(line)&#123;std.B,-std.A,std.A*mid.y-std.B*mid.x&#125;; int l=(xx-1)?(xx-1):n,r=(yy+1==n+1)?1:yy+1; bool opt1=0,opt2=0; if(a[xx].y==a[yy].y)opt1=1; if(a[xx].x==a[yy].x)opt2=1; bool flag=0,Flag=0; while(1)&#123; line Std=calc(a[l],a[r]); node Mid=(node)&#123;(a[l].x+a[r].x)/2,(a[l].y+a[r].y)/2&#125;; if(Check(a[l],vert)&amp;&amp;Check(a[r],vert))&#123;Flag=1;break;&#125; if(opt1||opt2)&#123; if(opt1)&#123; if(a[l].x==mid.x&amp;&amp;a[r].x==mid.x)&#123;Flag=1;break;&#125; if(a[l].y!=a[r].y)&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125;else &#123; if(a[l].y==mid.y&amp;&amp;a[r].y==mid.y)&#123;Flag=1;break;&#125; if(a[l].x!=a[r].x)&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125; &#125;else &#123; if(!pdpx(std,Std))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(pdch(std,vert))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125;int ll=(l-1)?(l-1):n,rr=(r+1==n+1)?1:r+1; if(ll==rr)&#123; int half=(xx+1&lt;=n)?xx+1:1; line STd=calc(a[ll],a[half]); if(pdcz(STd,std))&#123; if(!Check(a[half],vert)&amp;&amp;!Check(a[ll],vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)Flag=1;else flag=1; &#125; &#125;else &#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)Flag=1;else flag=1; &#125;break; &#125;else if(ll==r&amp;&amp;rr==l)&#123; if(!Check(a[xx==n?1:xx+1],vert))&#123; if(flag)Flag=1;else flag=1; &#125;break; &#125;l=ll;r=rr; &#125;if(!Flag)&#123;puts("Y");flagg=1;break;&#125; &#125;if(!flagg)puts("N"); &#125;for(int i=1;i&lt;=n;i++)a[i].x=0.0,a[i].y=0.0; &#125; return 0;&#125;/*150 04 21 16 42 3 */]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>判判判</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 3 1007]Find the answer]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-3-1007-Find-the-answer%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 给定一个长度为\(n\)值域为\([1,m]\)的序列\(W\)，对于所有\(i (1 \leqslant i \leqslant n)\)，可以选择一些元素\(W_k(1 \leqslant k &lt; i)\)将它们变成\(0\)使得\(\sum_{j=1}^iW_j \leqslant m\)，对于所有\(i\)，求选择的元素的最小数目。 解题思路 碰到最小数目，我们可以想到二分，二分出最小数目，然后显然我们最优的选择方案就是选最大的那几个数，所以我们现在需要一个数据结构快速找到区间内最大的\(mid\)个数，很显然我们可以使用权值线段树。我们枚举\(i\)，二分\(mid\)，依次插入\(W_i\)，然后查询前\(mid\)大的数删去就好了。注意值域很大，要离散化。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn=2e5+10;int n,m,tot,lst[maxn],a[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;struct Segment_Tree&#123; struct node&#123;ll w;int cnt;&#125;tree[maxn&lt;&lt;2]; void clear()&#123;memset(tree,0,sizeof(tree));&#125; void update(int k)&#123; tree[k].w=tree[k&lt;&lt;1].w+tree[k&lt;&lt;1|1].w; tree[k].cnt=tree[k&lt;&lt;1].cnt+tree[k&lt;&lt;1|1].cnt; &#125; void change(int k,int l,int r,int x)&#123; if(l==r)&#123;tree[k].w+=lst[l];tree[k].cnt++;return ;&#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)change(k&lt;&lt;1,l,mid,x); else change(k&lt;&lt;1|1,mid+1,r,x); update(k); &#125; ll query(int k,int l,int r,int x)&#123; if(tree[k].cnt==x)return tree[k].w; if(l==r&amp;&amp;tree[k].cnt&gt;x)return 1ll*(tree[k].w/tree[k].cnt)*x; int mid=(l+r)&gt;&gt;1;ll ret=0; if(tree[k&lt;&lt;1|1].cnt&gt;=x)return query(k&lt;&lt;1|1,mid+1,r,x); else &#123; ret+=query(k&lt;&lt;1|1,mid+1,r,tree[k&lt;&lt;1|1].cnt); ret+=query(k&lt;&lt;1,l,mid,x-tree[k&lt;&lt;1|1].cnt); &#125;return ret; &#125; void dfs(int k,int l,int r)&#123; if(l==r)&#123;printf("%d %lld %d\n",l,tree[k].w,tree[k].cnt);return ;&#125; int mid=(l+r)&gt;&gt;1; dfs(k&lt;&lt;1,l,mid);dfs(k&lt;&lt;1|1,mid+1,r); &#125;&#125;T;int main()&#123; int Q=read(); while(Q--)&#123; tot=0;memset(lst,0,sizeof(lst)); n=read();m=read();ll sum=0;T.clear(); for(int i=1;i&lt;=n;i++)a[i]=lst[i]=read(); sort(lst+1,lst+n+1);tot=unique(lst+1,lst+n+1)-lst-1; for(int i=1;i&lt;=n;i++)a[i]=lower_bound(lst+1,lst+tot+1,a[i])-lst; //for(int i=1;i&lt;=n;i++)printf("%d ",a[i]);puts(""); for(int i=1;i&lt;=n;i++)&#123; sum+=lst[a[i]];//cerr&lt;&lt;sum&lt;&lt;endl; int l=0,r=i; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1;ll val=T.query(1,1,n,mid); //cerr&lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt;endl; //printf("%d %d %lld\n",i,mid,val); if(sum-val&lt;=m)r=mid-1; else l=mid+1; &#125;printf("%d ",l);T.change(1,1,n,a[i]); &#125;puts(""); //T.dfs(1,1,n); &#125; return 0;&#125;/*2 7 15 1 2 3 4 5 6 7 5 100 80 40 40 40 60 */]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 2 1009]I Love Palindrome String]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-2-1009-I-Love-Palindrome-String%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 给定一个串\(S\)，要你统计所有长度为\(i \in [1,|S|]\)的子串\(s=s_ls_{l+1}...s_r\)满足\(s\)回文，\(s_ls_{l + 1}...s_{ \lfloor (l + r) / 2 \rfloor }\)也回文的个数。 解题思路 回文自动机裸题。 PS：话说这是我接触回文自动机之后第一次用回文自动机写题欸... 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define write(x) printf("%d\n",x)using namespace std;const int maxn=3e5+10;char s[maxn];struct node&#123;int to,nxt;&#125;e[maxn&lt;&lt;1];int cnt,lst,tot,f[maxn],ans[maxn],ret[maxn],head[maxn],len[maxn],fail[maxn],trie[maxn][26];int read()&#123; int x=0,f=1;char trie=getchar(); while(trie&lt;'0'||trie&gt;'9')&#123;if(trie=='-')f=-1;trie=getchar();&#125; while(trie&gt;='0'&amp;&amp;trie&lt;='9')&#123;x=x*10+trie-'0';trie=getchar();&#125; return x*f;&#125;void add(int u,int v)&#123;e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;&#125;void dfs(int x)&#123; f[len[x]]++;if(f[(len[x]&amp;1)?(len[x]/2+1):(len[x]/2)])ans[len[x]]+=ret[x]; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to)dfs(v);f[len[x]]--;&#125;int main()&#123; while(scanf("%s",s+1)!=EOF)&#123; cnt=1;lst=tot=0; memset(f,0,sizeof(f)); memset(ans,0,sizeof(ans)); memset(ret,0,sizeof(ret)); memset(len,0,sizeof(len)); memset(head,0,sizeof(head)); memset(fail,0,sizeof(fail)); memset(trie,0,sizeof(trie)); s[0]='#';fail[0]=1;len[1]=-1;int n=strlen(s+1); for(int i=1;i&lt;=n;i++)&#123; int p,ch=s[i]-'0'; while(s[i-len[lst]-1]!=s[i])lst=fail[lst]; if(!trie[lst][ch])&#123; len[++cnt]=len[lst]+2;ret[cnt]=1;p=fail[lst];//puts("ok"); while(s[i-len[p]-1]!=s[i])p=fail[p]; fail[cnt]=trie[p][ch]; lst=trie[lst][ch]=cnt; &#125;else ret[lst=trie[lst][ch]]++; &#125;for(int i=cnt;i&gt;=2;i--)ret[fail[i]]+=ret[i]; for(int i=cnt;i&gt;=2;i--)add(fail[i],i);dfs(0); for(int i=1;i&lt;n;i++)printf("%d ",ans[i]);printf("%d\n",ans[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 1 1009]string]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-1-1009-string%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 给定一个串\(S\)，要求从中选出一个长度为\(K\)的子序列串，该串满足第\(i\)个字母出现的次数在区间\([L_i,R_i]\)之间，且是所有满足条件的串中字典序最小的。 解题思路 记一个后缀和\(sum_{i,j}\)表示在位置\(i\)，字母\(j\)在\(i\)之后出现了多少次。记一个辅助数组\(lst_{i,j}\)表示在位置\(i\)之后\(j\)字母第一次出现的位置。 然后很显然的一个贪心想法就是从\(a\)到\(z\)，如果当前除了每个字母要求出现次数的下界之外还有剩余位置可以填，那么就填当前的位置，不过值得注意的是，在这里需要判断一下填了这个字母之后，在当前位置之后第一次出现这个字母的位置之后还能不能满足其他字母的下界，如果不能就不能填这个字母。再判断一下当前余下的需要填的字母数是否刚好是字母要求出现次数的下界和，如果是则不需要贪心了。注意前面这个判断需要在每一个位置填的时候都要判断一下，因此这道题实际上是一道判判判题（这辈子都不想写判判判题了！！！）。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define write(x) printf("%d\n",x)using namespace std;const int maxm=50;const int maxn=3e5+10;char s[maxn],ans[maxn];int sum[maxm][maxn],lst[maxn][maxm],L[maxm],R[maxm],f[maxm];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;int main()&#123; while(scanf("%s",s+1)!=EOF)&#123; memset(f,0,sizeof(f)); memset(lst,0,sizeof(lst)); memset(sum,0,sizeof(sum)); int K=read(),len=strlen(s+1),now=0,cnt=0; for(int i=1;i&lt;=26;i++)L[i]=read(),R[i]=read(); for(int i=1;i&lt;=26;i++)for(int j=len;j;j--)sum[i][j]=sum[i][j]+sum[i][j+1]+((s[j]-'a'+1)==i); for(int i=len;i&gt;=0;i--)for(int j=1;j&lt;=26;j++)&#123;if(s[i+1]=='a'+j-1)lst[i][j]=i+1;else lst[i][j]=lst[i+1][j];&#125; //for(int i=0;i&lt;=len;i++)&#123;for(int j=1;j&lt;=26;j++)printf("%d ",lst[i][j]);puts("");&#125; //for(int i=1;i&lt;=26;i++)&#123;for(int j=1;j&lt;=len;j++)printf("%d ",sum[i][j]);puts("");&#125; int ret=0;for(int i=1;i&lt;=26;i++)ret+=L[i];if(ret&gt;K)&#123;puts("-1");continue;&#125;bool Flag=0;//puts("ok"); for(int i=1;i&lt;=K;i++)&#123; for(int j=1;j&lt;=26;j++)&#123; int pos=lst[now][j],ret=0;bool flag=0;//write(pos); for(int k=1;k&lt;=26;k++)ret+=max(L[k]-f[k],0); //write(ret); if(!pos||f[j]&gt;=R[j])continue;//printf("%d %d\n",ret,K-i+1); if(ret==K-i+1)&#123; if(f[j]&gt;=L[j])continue; for(int k=1;k&lt;=26;k++)if(sum[k][pos]&lt;L[k]-f[k])&#123;flag=1;break;&#125; &#125;else &#123;for(int k=1;k&lt;=26;k++)if(sum[k][pos]&lt;L[k]-f[k])&#123;flag=1;break;&#125;&#125; if(!flag)&#123;ans[i]=((char)j+'a'-1);f[j]++;now=pos;Flag=1;cnt++;break;&#125; &#125;if(!Flag)&#123;puts("-1");break;&#125; &#125;if(cnt&lt;K)puts("-1");else if(Flag)&#123;for(int i=1;i&lt;=K;i++)putchar(ans[i]);puts("");&#125; &#125; return 0; &#125;/*adddaaaabbbcccccccccbcdegfhijklmnopqrstuvwxyzbbbe 161 44 41 81 12 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0*/]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>判判判</tag>
      </tags>
  </entry>
</search>
