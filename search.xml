<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[洛谷1349]广义斐波那契数列]]></title>
    <url>%2F2019%2F09%2F01%2F%E6%B4%9B%E8%B0%B71349-%E5%B9%BF%E4%B9%89%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目链接 洛谷 解题思路 同[洛谷1962]斐波那契数列理，只是转移方程变成了\(f_i=pf_{i-1}+qf_{i-2}\)而已，那么我们只需要将辅助转移矩阵变为下面这样就可以了： \[ \left[ \begin{matrix} p &amp; q\\ 1 &amp; 0 \\ \end{matrix} \right] \] 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define int long long#define write(x) printf("%lld\n",x)using namespace std;int mod;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;struct Matrix&#123; int a[3][3]; Matrix()&#123;memset(a,0,sizeof(a));&#125; void init()&#123; memset(a,0,sizeof(a)); for(int i=1;i&lt;3;i++)a[i][i]=1; &#125;&#125;init;Matrix mul(Matrix a,Matrix b)&#123; Matrix c; for(int i=1;i&lt;3;i++) for(int j=1;j&lt;3;j++) for(int k=1;k&lt;3;k++) c.a[i][j]=(c.a[i][j]+1ll*a.a[i][k]*b.a[k][j]%mod)%mod; return c;&#125;Matrix add(Matrix a,Matrix b)&#123; Matrix c; for(int i=1;i&lt;3;i++) for(int j=1;j&lt;3;j++) c.a[i][j]=(a.a[i][j]+b.a[i][j])%mod; return c;&#125;Matrix power(Matrix a,int b)&#123; Matrix ret;ret.init(); for(;b;b&gt;&gt;=1,a=mul(a,a)) if(b&amp;1)ret=mul(ret,a); return ret;&#125;signed main()&#123; Matrix now;now.a[1][1]=read();now.a[1][2]=read();now.a[2][1]=1; init.a[2][1]=read();init.a[1][1]=read(); int n=read();mod=read(); if(n==1)&#123;write(init.a[1][1]);return 0;&#125; if(n==2)&#123;write(init.a[2][1]);return 0;&#125; write(mul(power(now,n-2),init).a[1][1]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
</search>
