<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 1 1009]string]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-1-1009-string%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 给定一个串\(S\)，要求从中选出一个长度为\(K\)的子序列串，该串满足第\(i\)个字母出现的次数在区间\([L_i,R_i]\)之间，且是所有满足条件的串中字典序最小的。 解题思路 记一个后缀和\(sum_{i,j}\)表示在位置\(i\)，字母\(j\)在\(i\)之后出现了多少次。记一个辅助数组\(lst_{i,j}\)表示在位置\(i\)之后\(j\)字母第一次出现的位置。 然后很显然的一个贪心想法就是从\(a\)到\(z\)，如果当前除了每个字母要求出现次数的下界之外还有剩余位置可以填，那么就填当前的位置，不过值得注意的是，在这里需要判断一下填了这个字母之后，在当前位置之后第一次出现这个字母的位置之后还能不能满足其他字母的下界，如果不能就不能填这个字母。再判断一下当前余下的需要填的字母数是否刚好是字母要求出现次数的下界和，如果是则不需要贪心了。注意前面这个判断需要在每一个位置填的时候都要判断一下，因此这道题实际上是一道判判判题（这辈子都不想写判判判题了！！！）。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define write(x) printf("%d\n",x)using namespace std;const int maxm=50;const int maxn=3e5+10;char s[maxn],ans[maxn];int sum[maxm][maxn],lst[maxn][maxm],L[maxm],R[maxm],f[maxm];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;int main()&#123; while(scanf("%s",s+1)!=EOF)&#123; memset(f,0,sizeof(f)); memset(lst,0,sizeof(lst)); memset(sum,0,sizeof(sum)); int K=read(),len=strlen(s+1),now=0,cnt=0; for(int i=1;i&lt;=26;i++)L[i]=read(),R[i]=read(); for(int i=1;i&lt;=26;i++)for(int j=len;j;j--)sum[i][j]=sum[i][j]+sum[i][j+1]+((s[j]-'a'+1)==i); for(int i=len;i&gt;=0;i--)for(int j=1;j&lt;=26;j++)&#123;if(s[i+1]=='a'+j-1)lst[i][j]=i+1;else lst[i][j]=lst[i+1][j];&#125; //for(int i=0;i&lt;=len;i++)&#123;for(int j=1;j&lt;=26;j++)printf("%d ",lst[i][j]);puts("");&#125; //for(int i=1;i&lt;=26;i++)&#123;for(int j=1;j&lt;=len;j++)printf("%d ",sum[i][j]);puts("");&#125; int ret=0;for(int i=1;i&lt;=26;i++)ret+=L[i];if(ret&gt;K)&#123;puts("-1");continue;&#125;bool Flag=0;//puts("ok"); for(int i=1;i&lt;=K;i++)&#123; for(int j=1;j&lt;=26;j++)&#123; int pos=lst[now][j],ret=0;bool flag=0;//write(pos); for(int k=1;k&lt;=26;k++)ret+=max(L[k]-f[k],0); //write(ret); if(!pos||f[j]&gt;=R[j])continue;//printf("%d %d\n",ret,K-i+1); if(ret==K-i+1)&#123; if(f[j]&gt;=L[j])continue; for(int k=1;k&lt;=26;k++)if(sum[k][pos]&lt;L[k]-f[k])&#123;flag=1;break;&#125; &#125;else &#123;for(int k=1;k&lt;=26;k++)if(sum[k][pos]&lt;L[k]-f[k])&#123;flag=1;break;&#125;&#125; if(!flag)&#123;ans[i]=((char)j+'a'-1);f[j]++;now=pos;Flag=1;cnt++;break;&#125; &#125;if(!Flag)&#123;puts("-1");break;&#125; &#125;if(cnt&lt;K)puts("-1");else if(Flag)&#123;for(int i=1;i&lt;=K;i++)putchar(ans[i]);puts("");&#125; &#125; return 0; &#125;/*adddaaaabbbcccccccccbcdegfhijklmnopqrstuvwxyzbbbe 161 44 41 81 12 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0*/]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>判判判</tag>
      </tags>
  </entry>
</search>
