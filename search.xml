<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 5 1008]line symmetric]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-5-1008-line-symmetric%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 二维平面上有一个\(n\)个点的简单多边形，问能否改变一个点的坐标使其变成轴对称的简单多边形，点的连接顺序不改变，轴对称指图形对称。 解题思路 由于我计算几何太菜，所以直接用直线的一般式来写的这题... 我们先枚举相邻的点，以它们的垂直平分线作为对称轴，然后用两个指针\(l\)和\(r\)分别向两边枚举对称的点，将它们的直线解析式求出来，然后与对称轴比较，看是否被垂直平分，如果没有则这组不对称。由于我们并不关心改点的坐标到哪里去，所以我们只需要标记使用过修改次数了，如果后面又扫到了不对称的点，那么这个对称轴就不行，需要接着枚举下去。 最基本的做完了之后，我们发现如果最开始枚举来得到对称轴的点对所在的直线如果是平行于\(x\)轴或者\(y\)轴的话，我们是不好通过将点的坐标代入解析式来判断是否该点在这条直线上的，所以我们需要特判这种情况。 接着我们考虑一下这种“生草图”，注意到如果是按照我们之前的做法来判断这个图的话，会判断成能变成轴对称图形，我们发现坐标为\((7,4)\)的点可以移到点\((1,1)\)和\((4,2)\)所构成的直线的下面来与点\((0,0)\)对称。而这种移法是不合法的，因为移动之后图形并不是简单多边形了，我们需要特判这种移动之后不是简单多边形的情况。 我们可以用叉积来做这件事。我们设\((7,4)\)为\(a\)，\((0,0)\)为\(b\)，\((1,1)\)为\(x\)，\((4,2)\)为\(y\)，\(b\)关于对称轴对称的点为\(c\)，通过判断\(\vec {ax} \times \vec{ay}\)与\(\vec{cx} \times \vec{cy}\)的正负性是否相同来判断是否合法，然后我把如果是合法的对称情况满足的性质都判了一遍，这样就过了..... 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;#define sqr(x) ((x)*(x))using namespace std;const int maxn=2e3+10;double eps=1e-12;struct node&#123;double x,y;&#125;a[maxn];struct line&#123;double A,B,C;&#125;;int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;void Write(line x)&#123;printf("%.4lf %.4lf %.4lf\n",x.A,x.B,x.C);&#125;void Write1(node x)&#123;printf("%.4lf %.4lf\n",x.x,x.y);&#125;line calc(node x,node y)&#123; double A=y.y-x.y; double B=x.x-y.x; double C=y.x*x.y-x.x*y.y; return (line)&#123;A,B,C&#125;;&#125;node get_sym(node x,line y)&#123; int xx=((sqr(y.B)-sqr(y.A))*x.x-2*y.A*y.B*x.y-2*y.A*y.C); int yy=((sqr(y.A)-sqr(y.B))*x.y-2*y.A*y.B*x.x-2*y.B*y.C); return (node)&#123;xx/(sqr(y.A)+sqr(y.B)),yy/(sqr(y.A)+sqr(y.B))&#125;;&#125;bool pd(double x,double y)&#123;return fabs(x-y)&lt;eps;&#125;bool check(line x,line y)&#123;return pd(x.A,y.A)&amp;&amp;pd(x.B,y.B)&amp;&amp;pd(x.C,y.C);&#125;bool pdcz(line x,line y)&#123;return x.A*y.A+x.B*y.B==0;&#125;bool Check(node x,line y)&#123;return y.A*x.x+y.B*x.y+y.C==0;&#125;bool pdpx(line x,line y)&#123;return x.A*y.B-y.A*x.B==0;&#125;int zf(double x)&#123;if(pd(x,0.0))return 0;if(x&lt;0)return -1;else return 1;&#125;double get(node a1,node a2,node b1,node b2)&#123;return (a2.x-a1.x)*(b2.y-b1.y)-(b2.x-b1.x)*(a2.y-a1.y);&#125;bool pdch(line x,line y)&#123;return x.A/y.A==x.B/y.B&amp;&amp;x.A/y.A==x.C/y.C&amp;&amp;x.B/y.B==x.C/y.C;&#125;bool CHeck(node x,node y,line std,node xx,node yy)&#123; node symm=get_sym(xx,std); if(zf(get(x,xx,x,y))!=zf(get(x,symm,x,y)))return 0; if(zf(get(y,xx,y,x))!=zf(get(y,symm,y,x)))return 0; if(zf(get(xx,x,xx,y))!=zf(get(yy,x,yy,y)))return 0; if(zf(get(xx,x,xx,y))!=zf(get(symm,x,symm,y)))return 0; if(zf(get(xx,yy,xx,y))!=zf(get(xx,symm,xx,y)))return 0; if(zf(get(xx,yy,xx,x))!=zf(get(xx,symm,xx,x)))return 0; return 1;&#125;int main()&#123; //freopen("1008.in","r",stdin); //freopen("1008.out","w",stdout); int T=read(); while(T--)&#123; int n=read(); for(int i=1;i&lt;=n;i++)scanf("%lf%lf",&amp;a[i].x,&amp;a[i].y); if(n&lt;=4)&#123;puts("Y");continue;&#125;bool flagg=0; for(int i=1;i&lt;=n;i++)&#123; int xx=i,yy=i==n?1:i+1;line std=calc(a[xx],a[yy]); node mid=(node)&#123;(a[xx].x+a[yy].x)/2,(a[xx].y+a[yy].y)/2&#125;; line vert=(line)&#123;std.B,-std.A,std.A*mid.y-std.B*mid.x&#125;; int l=(xx-1)?(xx-1):n,r=(yy+1==n+1)?1:yy+1; bool opt1=0,opt2=0; if(a[xx].y==a[yy].y)opt1=1; if(a[xx].x==a[yy].x)opt2=1; bool flag=0,Flag=0; while(1)&#123; line Std=calc(a[l],a[r]); node Mid=(node)&#123;(a[l].x+a[r].x)/2,(a[l].y+a[r].y)/2&#125;; if(Check(a[l],vert)&amp;&amp;Check(a[r],vert))&#123;Flag=1;break;&#125; if(opt1||opt2)&#123; if(opt1)&#123; if(a[l].y!=a[r].y)&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125;else &#123; if(a[l].x!=a[r].x)&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125; &#125;else &#123; if(!pdpx(std,Std))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125; int ll=(l-1)?(l-1):n,rr=(r+1==n+1)?1:r+1; if(ll==rr)&#123; if(!Check(a[ll],vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)Flag=1;else flag=1; &#125;break; &#125;else if(ll==r&amp;&amp;rr==l)break; l=ll;r=rr; &#125;if(!Flag)&#123;puts("Y");flagg=1;break;&#125; &#125;if(!flagg)&#123; for(int i=1;i&lt;=n;i++)&#123; int xx=i,yy=(i+2&lt;=n)?i+2:((i+2)%n);line std=calc(a[xx],a[yy]); node mid=(node)&#123;(a[xx].x+a[yy].x)/2,(a[xx].y+a[yy].y)/2&#125;; line vert=(line)&#123;std.B,-std.A,std.A*mid.y-std.B*mid.x&#125;; int l=(xx-1)?(xx-1):n,r=(yy+1==n+1)?1:yy+1; bool opt1=0,opt2=0; if(a[xx].y==a[yy].y)opt1=1; if(a[xx].x==a[yy].x)opt2=1; bool flag=0,Flag=0; while(1)&#123; line Std=calc(a[l],a[r]); node Mid=(node)&#123;(a[l].x+a[r].x)/2,(a[l].y+a[r].y)/2&#125;; if(Check(a[l],vert)&amp;&amp;Check(a[r],vert))&#123;Flag=1;break;&#125; if(opt1||opt2)&#123; if(opt1)&#123; if(a[l].x==mid.x&amp;&amp;a[r].x==mid.x)&#123;Flag=1;break;&#125; if(a[l].y!=a[r].y)&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125;else &#123; if(a[l].y==mid.y&amp;&amp;a[r].y==mid.y)&#123;Flag=1;break;&#125; if(a[l].x!=a[r].x)&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125; &#125;else &#123; if(!pdpx(std,Std))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(pdch(std,vert))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125;else &#123; if(!Check(Mid,vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)&#123;Flag=1;break;&#125; else flag=1; &#125; &#125; &#125;int ll=(l-1)?(l-1):n,rr=(r+1==n+1)?1:r+1; if(ll==rr)&#123; int half=(xx+1&lt;=n)?xx+1:1; line STd=calc(a[ll],a[half]); if(pdcz(STd,std))&#123; if(!Check(a[half],vert)&amp;&amp;!Check(a[ll],vert))&#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)Flag=1;else flag=1; &#125; &#125;else &#123; if(!CHeck(a[xx],a[yy],vert,a[l],a[r]))&#123;Flag=1;break;&#125; if(flag)Flag=1;else flag=1; &#125;break; &#125;else if(ll==r&amp;&amp;rr==l)&#123; if(!Check(a[xx==n?1:xx+1],vert))&#123; if(flag)Flag=1;else flag=1; &#125;break; &#125;l=ll;r=rr; &#125;if(!Flag)&#123;puts("Y");flagg=1;break;&#125; &#125;if(!flagg)puts("N"); &#125;for(int i=1;i&lt;=n;i++)a[i].x=0.0,a[i].y=0.0; &#125; return 0;&#125;/*150 04 21 16 42 3 */]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 3 1007]Find the answer]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-3-1007-Find-the-answer%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 给定一个长度为\(n\)值域为\([1,m]\)的序列\(W\)，对于所有\(i (1 \leqslant i \leqslant n)\)，可以选择一些元素\(W_k(1 \leqslant k &lt; i)\)将它们变成\(0\)使得\(\sum_{j=1}^iW_j \leqslant m\)，对于所有\(i\)，求选择的元素的最小数目。 解题思路 碰到最小数目，我们可以想到二分，二分出最小数目，然后显然我们最优的选择方案就是选最大的那几个数，所以我们现在需要一个数据结构快速找到区间内最大的\(mid\)个数，很显然我们可以使用权值线段树。我们枚举\(i\)，二分\(mid\)，依次插入\(W_i\)，然后查询前\(mid\)大的数删去就好了。注意值域很大，要离散化。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*Program from Luvwgyx*/#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn=2e5+10;int n,m,tot,lst[maxn],a[maxn];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;void print(int x)&#123; if(x&lt;0)putchar('-'),x=-x; if(x&gt;9)print(x/10); putchar(x%10+'0');&#125;void write(int x)&#123;print(x);puts("");&#125;struct Segment_Tree&#123; struct node&#123;ll w;int cnt;&#125;tree[maxn&lt;&lt;2]; void clear()&#123;memset(tree,0,sizeof(tree));&#125; void update(int k)&#123; tree[k].w=tree[k&lt;&lt;1].w+tree[k&lt;&lt;1|1].w; tree[k].cnt=tree[k&lt;&lt;1].cnt+tree[k&lt;&lt;1|1].cnt; &#125; void change(int k,int l,int r,int x)&#123; if(l==r)&#123;tree[k].w+=lst[l];tree[k].cnt++;return ;&#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid)change(k&lt;&lt;1,l,mid,x); else change(k&lt;&lt;1|1,mid+1,r,x); update(k); &#125; ll query(int k,int l,int r,int x)&#123; if(tree[k].cnt==x)return tree[k].w; if(l==r&amp;&amp;tree[k].cnt&gt;x)return 1ll*(tree[k].w/tree[k].cnt)*x; int mid=(l+r)&gt;&gt;1;ll ret=0; if(tree[k&lt;&lt;1|1].cnt&gt;=x)return query(k&lt;&lt;1|1,mid+1,r,x); else &#123; ret+=query(k&lt;&lt;1|1,mid+1,r,tree[k&lt;&lt;1|1].cnt); ret+=query(k&lt;&lt;1,l,mid,x-tree[k&lt;&lt;1|1].cnt); &#125;return ret; &#125; void dfs(int k,int l,int r)&#123; if(l==r)&#123;printf("%d %lld %d\n",l,tree[k].w,tree[k].cnt);return ;&#125; int mid=(l+r)&gt;&gt;1; dfs(k&lt;&lt;1,l,mid);dfs(k&lt;&lt;1|1,mid+1,r); &#125;&#125;T;int main()&#123; int Q=read(); while(Q--)&#123; tot=0;memset(lst,0,sizeof(lst)); n=read();m=read();ll sum=0;T.clear(); for(int i=1;i&lt;=n;i++)a[i]=lst[i]=read(); sort(lst+1,lst+n+1);tot=unique(lst+1,lst+n+1)-lst-1; for(int i=1;i&lt;=n;i++)a[i]=lower_bound(lst+1,lst+tot+1,a[i])-lst; //for(int i=1;i&lt;=n;i++)printf("%d ",a[i]);puts(""); for(int i=1;i&lt;=n;i++)&#123; sum+=lst[a[i]];//cerr&lt;&lt;sum&lt;&lt;endl; int l=0,r=i; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1;ll val=T.query(1,1,n,mid); //cerr&lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt;endl; //printf("%d %d %lld\n",i,mid,val); if(sum-val&lt;=m)r=mid-1; else l=mid+1; &#125;printf("%d ",l);T.change(1,1,n,a[i]); &#125;puts(""); //T.dfs(1,1,n); &#125; return 0;&#125;/*2 7 15 1 2 3 4 5 6 7 5 100 80 40 40 40 60 */]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 2 1009]I Love Palindrome String]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-2-1009-I-Love-Palindrome-String%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 给定一个串\(S\)，要你统计所有长度为\(i \in [1,|S|]\)的子串\(s=s_ls_{l+1}...s_r\)满足\(s\)回文，\(s_ls_{l + 1}...s_{ \lfloor (l + r) / 2 \rfloor }\)也回文的个数。 解题思路 回文自动机裸题。 PS：话说这是我接触回文自动机之后第一次用回文自动机写题欸... 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define write(x) printf("%d\n",x)using namespace std;const int maxn=3e5+10;char s[maxn];struct node&#123;int to,nxt;&#125;e[maxn&lt;&lt;1];int cnt,lst,tot,f[maxn],ans[maxn],ret[maxn],head[maxn],len[maxn],fail[maxn],trie[maxn][26];int read()&#123; int x=0,f=1;char trie=getchar(); while(trie&lt;'0'||trie&gt;'9')&#123;if(trie=='-')f=-1;trie=getchar();&#125; while(trie&gt;='0'&amp;&amp;trie&lt;='9')&#123;x=x*10+trie-'0';trie=getchar();&#125; return x*f;&#125;void add(int u,int v)&#123;e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;&#125;void dfs(int x)&#123; f[len[x]]++;if(f[(len[x]&amp;1)?(len[x]/2+1):(len[x]/2)])ans[len[x]]+=ret[x]; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to)dfs(v);f[len[x]]--;&#125;int main()&#123; while(scanf("%s",s+1)!=EOF)&#123; cnt=1;lst=tot=0; memset(f,0,sizeof(f)); memset(ans,0,sizeof(ans)); memset(ret,0,sizeof(ret)); memset(len,0,sizeof(len)); memset(head,0,sizeof(head)); memset(fail,0,sizeof(fail)); memset(trie,0,sizeof(trie)); s[0]='#';fail[0]=1;len[1]=-1;int n=strlen(s+1); for(int i=1;i&lt;=n;i++)&#123; int p,ch=s[i]-'0'; while(s[i-len[lst]-1]!=s[i])lst=fail[lst]; if(!trie[lst][ch])&#123; len[++cnt]=len[lst]+2;ret[cnt]=1;p=fail[lst];//puts("ok"); while(s[i-len[p]-1]!=s[i])p=fail[p]; fail[cnt]=trie[p][ch]; lst=trie[lst][ch]=cnt; &#125;else ret[lst=trie[lst][ch]]++; &#125;for(int i=cnt;i&gt;=2;i--)ret[fail[i]]+=ret[i]; for(int i=cnt;i&gt;=2;i--)add(fail[i],i);dfs(0); for(int i=1;i&lt;n;i++)printf("%d ",ans[i]);printf("%d\n",ans[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 1 1009]string]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-1-1009-string%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 给定一个串\(S\)，要求从中选出一个长度为\(K\)的子序列串，该串满足第\(i\)个字母出现的次数在区间\([L_i,R_i]\)之间，且是所有满足条件的串中字典序最小的。 解题思路 记一个后缀和\(sum_{i,j}\)表示在位置\(i\)，字母\(j\)在\(i\)之后出现了多少次。记一个辅助数组\(lst_{i,j}\)表示在位置\(i\)之后\(j\)字母第一次出现的位置。 然后很显然的一个贪心想法就是从\(a\)到\(z\)，如果当前除了每个字母要求出现次数的下界之外还有剩余位置可以填，那么就填当前的位置，不过值得注意的是，在这里需要判断一下填了这个字母之后，在当前位置之后第一次出现这个字母的位置之后还能不能满足其他字母的下界，如果不能就不能填这个字母。再判断一下当前余下的需要填的字母数是否刚好是字母要求出现次数的下界和，如果是则不需要贪心了。注意前面这个判断需要在每一个位置填的时候都要判断一下，因此这道题实际上是一道判判判题（这辈子都不想写判判判题了！！！）。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define write(x) printf("%d\n",x)using namespace std;const int maxm=50;const int maxn=3e5+10;char s[maxn],ans[maxn];int sum[maxm][maxn],lst[maxn][maxm],L[maxm],R[maxm],f[maxm];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;int main()&#123; while(scanf("%s",s+1)!=EOF)&#123; memset(f,0,sizeof(f)); memset(lst,0,sizeof(lst)); memset(sum,0,sizeof(sum)); int K=read(),len=strlen(s+1),now=0,cnt=0; for(int i=1;i&lt;=26;i++)L[i]=read(),R[i]=read(); for(int i=1;i&lt;=26;i++)for(int j=len;j;j--)sum[i][j]=sum[i][j]+sum[i][j+1]+((s[j]-'a'+1)==i); for(int i=len;i&gt;=0;i--)for(int j=1;j&lt;=26;j++)&#123;if(s[i+1]=='a'+j-1)lst[i][j]=i+1;else lst[i][j]=lst[i+1][j];&#125; //for(int i=0;i&lt;=len;i++)&#123;for(int j=1;j&lt;=26;j++)printf("%d ",lst[i][j]);puts("");&#125; //for(int i=1;i&lt;=26;i++)&#123;for(int j=1;j&lt;=len;j++)printf("%d ",sum[i][j]);puts("");&#125; int ret=0;for(int i=1;i&lt;=26;i++)ret+=L[i];if(ret&gt;K)&#123;puts("-1");continue;&#125;bool Flag=0;//puts("ok"); for(int i=1;i&lt;=K;i++)&#123; for(int j=1;j&lt;=26;j++)&#123; int pos=lst[now][j],ret=0;bool flag=0;//write(pos); for(int k=1;k&lt;=26;k++)ret+=max(L[k]-f[k],0); //write(ret); if(!pos||f[j]&gt;=R[j])continue;//printf("%d %d\n",ret,K-i+1); if(ret==K-i+1)&#123; if(f[j]&gt;=L[j])continue; for(int k=1;k&lt;=26;k++)if(sum[k][pos]&lt;L[k]-f[k])&#123;flag=1;break;&#125; &#125;else &#123;for(int k=1;k&lt;=26;k++)if(sum[k][pos]&lt;L[k]-f[k])&#123;flag=1;break;&#125;&#125; if(!flag)&#123;ans[i]=((char)j+'a'-1);f[j]++;now=pos;Flag=1;cnt++;break;&#125; &#125;if(!Flag)&#123;puts("-1");break;&#125; &#125;if(cnt&lt;K)puts("-1");else if(Flag)&#123;for(int i=1;i&lt;=K;i++)putchar(ans[i]);puts("");&#125; &#125; return 0; &#125;/*adddaaaabbbcccccccccbcdegfhijklmnopqrstuvwxyzbbbe 161 44 41 81 12 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0*/]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>判判判</tag>
      </tags>
  </entry>
</search>
