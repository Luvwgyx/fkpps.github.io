<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 2 1009]I Love Palindrome String]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-2-1009-I-Love-Palindrome-String%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 给定一个串\(S\)，要你统计所有长度为\(i \in [1,|S|]\)的子串\(s=s_ls_{l+1}...s_r\)满足\(s\)回文，\(s_ls_{l + 1}...s_{ \lfloor (l + r) / 2 \rfloor }\)也回文的个数。 解题思路 回文自动机裸题。 PS：话说这是我接触回文自动机之后第一次用回文自动机写题欸... 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define write(x) printf("%d\n",x)using namespace std;const int maxn=3e5+10;char s[maxn];struct node&#123;int to,nxt;&#125;e[maxn&lt;&lt;1];int cnt,lst,tot,f[maxn],ans[maxn],ret[maxn],head[maxn],len[maxn],fail[maxn],trie[maxn][26];int read()&#123; int x=0,f=1;char trie=getchar(); while(trie&lt;'0'||trie&gt;'9')&#123;if(trie=='-')f=-1;trie=getchar();&#125; while(trie&gt;='0'&amp;&amp;trie&lt;='9')&#123;x=x*10+trie-'0';trie=getchar();&#125; return x*f;&#125;void add(int u,int v)&#123;e[++tot].to=v;e[tot].nxt=head[u];head[u]=tot;&#125;void dfs(int x)&#123; f[len[x]]++;if(f[(len[x]&amp;1)?(len[x]/2+1):(len[x]/2)])ans[len[x]]+=ret[x]; for(int i=head[x],v=e[i].to;i;i=e[i].nxt,v=e[i].to)dfs(v);f[len[x]]--;&#125;int main()&#123; while(scanf("%s",s+1)!=EOF)&#123; cnt=1;lst=tot=0; memset(f,0,sizeof(f)); memset(ans,0,sizeof(ans)); memset(ret,0,sizeof(ret)); memset(len,0,sizeof(len)); memset(head,0,sizeof(head)); memset(fail,0,sizeof(fail)); memset(trie,0,sizeof(trie)); s[0]='#';fail[0]=1;len[1]=-1;int n=strlen(s+1); for(int i=1;i&lt;=n;i++)&#123; int p,ch=s[i]-'0'; while(s[i-len[lst]-1]!=s[i])lst=fail[lst]; if(!trie[lst][ch])&#123; len[++cnt]=len[lst]+2;ret[cnt]=1;p=fail[lst];//puts("ok"); while(s[i-len[p]-1]!=s[i])p=fail[p]; fail[cnt]=trie[p][ch]; lst=trie[lst][ch]=cnt; &#125;else ret[lst=trie[lst][ch]]++; &#125;for(int i=cnt;i&gt;=2;i--)ret[fail[i]]+=ret[i]; for(int i=cnt;i&gt;=2;i--)add(fail[i],i);dfs(0); for(int i=1;i&lt;n;i++)printf("%d ",ans[i]);printf("%d\n",ans[n]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[2019 Multi-University Training Contest 1 1009]string]]></title>
    <url>%2F2019%2F09%2F01%2F2019-Multi-University-Training-Contest-1-1009-string%2F</url>
    <content type="text"><![CDATA[题目链接 HDU 题意简述 给定一个串\(S\)，要求从中选出一个长度为\(K\)的子序列串，该串满足第\(i\)个字母出现的次数在区间\([L_i,R_i]\)之间，且是所有满足条件的串中字典序最小的。 解题思路 记一个后缀和\(sum_{i,j}\)表示在位置\(i\)，字母\(j\)在\(i\)之后出现了多少次。记一个辅助数组\(lst_{i,j}\)表示在位置\(i\)之后\(j\)字母第一次出现的位置。 然后很显然的一个贪心想法就是从\(a\)到\(z\)，如果当前除了每个字母要求出现次数的下界之外还有剩余位置可以填，那么就填当前的位置，不过值得注意的是，在这里需要判断一下填了这个字母之后，在当前位置之后第一次出现这个字母的位置之后还能不能满足其他字母的下界，如果不能就不能填这个字母。再判断一下当前余下的需要填的字母数是否刚好是字母要求出现次数的下界和，如果是则不需要贪心了。注意前面这个判断需要在每一个位置填的时候都要判断一下，因此这道题实际上是一道判判判题（这辈子都不想写判判判题了！！！）。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*Program from Luvwgyx*/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define write(x) printf("%d\n",x)using namespace std;const int maxm=50;const int maxn=3e5+10;char s[maxn],ans[maxn];int sum[maxm][maxn],lst[maxn][maxm],L[maxm],R[maxm],f[maxm];int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;int main()&#123; while(scanf("%s",s+1)!=EOF)&#123; memset(f,0,sizeof(f)); memset(lst,0,sizeof(lst)); memset(sum,0,sizeof(sum)); int K=read(),len=strlen(s+1),now=0,cnt=0; for(int i=1;i&lt;=26;i++)L[i]=read(),R[i]=read(); for(int i=1;i&lt;=26;i++)for(int j=len;j;j--)sum[i][j]=sum[i][j]+sum[i][j+1]+((s[j]-'a'+1)==i); for(int i=len;i&gt;=0;i--)for(int j=1;j&lt;=26;j++)&#123;if(s[i+1]=='a'+j-1)lst[i][j]=i+1;else lst[i][j]=lst[i+1][j];&#125; //for(int i=0;i&lt;=len;i++)&#123;for(int j=1;j&lt;=26;j++)printf("%d ",lst[i][j]);puts("");&#125; //for(int i=1;i&lt;=26;i++)&#123;for(int j=1;j&lt;=len;j++)printf("%d ",sum[i][j]);puts("");&#125; int ret=0;for(int i=1;i&lt;=26;i++)ret+=L[i];if(ret&gt;K)&#123;puts("-1");continue;&#125;bool Flag=0;//puts("ok"); for(int i=1;i&lt;=K;i++)&#123; for(int j=1;j&lt;=26;j++)&#123; int pos=lst[now][j],ret=0;bool flag=0;//write(pos); for(int k=1;k&lt;=26;k++)ret+=max(L[k]-f[k],0); //write(ret); if(!pos||f[j]&gt;=R[j])continue;//printf("%d %d\n",ret,K-i+1); if(ret==K-i+1)&#123; if(f[j]&gt;=L[j])continue; for(int k=1;k&lt;=26;k++)if(sum[k][pos]&lt;L[k]-f[k])&#123;flag=1;break;&#125; &#125;else &#123;for(int k=1;k&lt;=26;k++)if(sum[k][pos]&lt;L[k]-f[k])&#123;flag=1;break;&#125;&#125; if(!flag)&#123;ans[i]=((char)j+'a'-1);f[j]++;now=pos;Flag=1;cnt++;break;&#125; &#125;if(!Flag)&#123;puts("-1");break;&#125; &#125;if(cnt&lt;K)puts("-1");else if(Flag)&#123;for(int i=1;i&lt;=K;i++)putchar(ans[i]);puts("");&#125; &#125; return 0; &#125;/*adddaaaabbbcccccccccbcdegfhijklmnopqrstuvwxyzbbbe 161 44 41 81 12 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0*/]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>判判判</tag>
      </tags>
  </entry>
</search>
